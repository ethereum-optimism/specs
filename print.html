<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OP Stack Specification</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="root.html"><strong aria-hidden="true">1.</strong> Root</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="protocol/overview.html"><strong aria-hidden="true">3.</strong> OP Stack Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/bridges.html"><strong aria-hidden="true">3.1.</strong> Bridges</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/messengers.html"><strong aria-hidden="true">3.1.1.</strong> Messengers</a></li><li class="chapter-item expanded "><a href="protocol/deposits.html"><strong aria-hidden="true">3.1.2.</strong> Deposits</a></li><li class="chapter-item expanded "><a href="protocol/withdrawals.html"><strong aria-hidden="true">3.1.3.</strong> Withdrawals</a></li><li class="chapter-item expanded "><a href="protocol/guaranteed-gas-market.html"><strong aria-hidden="true">3.1.4.</strong> Guaranteed Gas Market</a></li><li class="chapter-item expanded "><a href="protocol/proposals.html"><strong aria-hidden="true">3.1.5.</strong> Proposals</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Clients</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/exec-engine.html"><strong aria-hidden="true">3.2.1.</strong> Execution Engine</a></li><li class="chapter-item expanded "><a href="protocol/rollup-node.html"><strong aria-hidden="true">3.2.2.</strong> Rollup Node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/rollup-node-p2p.html"><strong aria-hidden="true">3.2.2.1.</strong> Rollup Node P2P</a></li><li class="chapter-item expanded "><a href="protocol/derivation.html"><strong aria-hidden="true">3.2.2.2.</strong> Derivation</a></li><li class="chapter-item expanded "><a href="protocol/span-batches.html"><strong aria-hidden="true">3.2.2.3.</strong> Span Batches</a></li></ol></li><li class="chapter-item expanded "><a href="protocol/batcher.html"><strong aria-hidden="true">3.2.3.</strong> Batch Submitter</a></li></ol></li><li class="chapter-item expanded "><a href="protocol/safe-liveness-checking.html"><strong aria-hidden="true">3.3.</strong> Safe Liveness Checking</a></li><li class="chapter-item expanded "><a href="protocol/predeploys.html"><strong aria-hidden="true">3.4.</strong> Predeploys</a></li><li class="chapter-item expanded "><a href="protocol/preinstalls.html"><strong aria-hidden="true">3.5.</strong> Preinstalls</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Superchain</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/superchain-configuration.html"><strong aria-hidden="true">3.6.1.</strong> Superchain Configuration</a></li><li class="chapter-item expanded "><a href="protocol/superchain-upgrades.html"><strong aria-hidden="true">3.6.2.</strong> Superchain Upgrades</a></li></ol></li><li class="chapter-item expanded "><a href="protocol/system_config.html"><strong aria-hidden="true">3.7.</strong> System Config</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Experimental</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="experimental/fault-proof/index.html"><strong aria-hidden="true">4.1.</strong> Fault Proof</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="experimental/fault-proof/cannon-fault-proof-vm.html"><strong aria-hidden="true">4.1.1.</strong> Cannon Fault Proof VM</a></li><li class="chapter-item expanded "><a href="experimental/fault-proof/dispute-game-interface.html"><strong aria-hidden="true">4.1.2.</strong> Dispute Game Interface</a></li><li class="chapter-item expanded "><a href="experimental/fault-proof/fault-dispute-game.html"><strong aria-hidden="true">4.1.3.</strong> Fault Dispute Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="experimental/fault-proof/honest-challenger-fdg.html"><strong aria-hidden="true">4.1.3.1.</strong> Honest Challenger</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">5.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="meta/index.html"><strong aria-hidden="true">6.</strong> Meta</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="meta/linting.html"><strong aria-hidden="true">6.1.</strong> Linting</a></li><li class="chapter-item expanded "><a href="meta/versioning.html"><strong aria-hidden="true">6.2.</strong> Versioning</a></li><li class="chapter-item expanded "><a href="meta/markdown-style.html"><strong aria-hidden="true">6.3.</strong> Markdown Style</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OP Stack Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="op-stack-specs"><a class="header" href="#op-stack-specs">OP Stack Specs</a></h1>
<p>This directory contains the plain english specs for Optimism, a minimal optimistic rollup protocol
that maintains 1:1 compatibility with Ethereum.</p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="root.html#specification-contents">Specification Contents</a>
<ul>
<li><a href="root.html#experimental">Experimental</a></li>
</ul>
</li>
<li><a href="root.html#design-goals">Design Goals</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="specification-contents"><a class="header" href="#specification-contents">Specification Contents</a></h2>
<ul>
<li><a href="introduction.html">Introduction</a></li>
<li><a href="protocol/overview.html">Overview</a></li>
<li><a href="protocol/deposits.html">Deposits</a></li>
<li><a href="protocol/withdrawals.html">Withdrawals</a></li>
<li><a href="protocol/exec-engine.html">Execution Engine</a></li>
<li><a href="protocol/proposals.html">L2 Output Root Proposals</a></li>
<li><a href="protocol/rollup-node.html">Rollup Node</a></li>
<li><a href="protocol/rollup-node-p2p.html">Rollup Node P2p</a></li>
<li><a href="protocol/derivation.html">L2 Chain Derivation</a></li>
<li><a href="protocol/superchain-upgrades.html">Superchain Upgrades</a></li>
<li><a href="protocol/system_config.html">System Config</a></li>
<li><a href="protocol/batcher.html">Batch Submitter</a></li>
<li><a href="protocol/guaranteed-gas-market.html">Guaranteed Gas Market</a></li>
<li><a href="protocol/messengers.html">Messengers</a></li>
<li><a href="protocol/bridges.html">Bridges</a></li>
<li><a href="protocol/predeploys.html">Predeploys</a></li>
<li><a href="glossary.html">Glossary</a></li>
</ul>
<h3 id="experimental"><a class="header" href="#experimental">Experimental</a></h3>
<p>Specifications of new features in active development.</p>
<ul>
<li><a href="./experimental/fault-proof/index.html">Fault Proof</a>
<ul>
<li><a href="./experimental/fault-proof/dispute-game-interface.html">Dispute Game Interface</a></li>
<li><a href="./experimental/fault-proof/fault-dispute-game.html">Fault Dispute Game</a>
<ul>
<li><a href="./experimental/fault-proof/honest-challenger-fdg.html">Honest Challenger Behavior</a></li>
</ul>
</li>
<li><a href="./experimental/fault-proof/cannon-fault-proof-vm.html">Cannon VM</a></li>
</ul>
</li>
</ul>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<p>Our aim is to design a protocol specification that is:</p>
<ul>
<li><strong>Fast:</strong> When users send transactions, they get reliable confirmations with low-latency.
For example when swapping on Uniswap you should see that your transaction succeed in less than 2
seconds.</li>
<li><strong>Scalable:</strong> It should be possible to handle an enormous number of transactions
per second which will enable the system to charge low fees.
V1.0 will enable Optimism to scale up to and even past the gas limit on L1.
Later iterations should scale much further.</li>
<li><strong>Modular:</strong> Our designs will use modularity to reduce complexity and enable parallel
contributions. Coming up with good conceptual frameworks &amp; composable atoms of software enables us
to build extremely complex software even when any one person cannot hold that much in their brain.</li>
<li><strong>Minimal:</strong> Rollups should be minimal to best take advantage of the battle-tested infrastructure
(like Geth) that already runs Ethereum. An ideal optimistic rollup design should be representable
as a <em>diff</em> against Ethereum client software.</li>
<li><strong>Developer Driven:</strong> Our designs will be developer driven to ensure we are actually building
something that people want to use. We must constantly engage with the developers who will be using
our software to avoid creating a system no one wants to use.</li>
<li><strong>Clear and Readable:</strong> The specs we write are written to be read. So tight feedback loop with the
systems team consuming the spec is also key!</li>
<li><strong>Secure:</strong> This is self-evident.
Userâ€™s assets are at stake. Every component of the system must be incredibly secure.</li>
<li><strong>Decentralizable:</strong> Optimism must be designed to avail itself of the security and
censorship-resistant guarantees achieved by a decentralized system.
Currently centralized components of the system should have a clear path towards decentralization.
Already decentralized components of the system should be protected and preserved.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Optimism is an <em>EVM equivalent</em>, <em>optimistic rollup</em> protocol designed to <em>scale Ethereum</em> while remaining maximally
compatible with existing Ethereum infrastructure. This document provides an overview of the protocol to provide context
for the rest of the specification.</p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="introduction.html#foundations">Foundations</a>
<ul>
<li><a href="introduction.html#what-is-ethereum-scalability">What is Ethereum scalability?</a></li>
<li><a href="introduction.html#what-is-an-optimistic-rollup">What is an Optimistic Rollup?</a></li>
<li><a href="introduction.html#what-is-evm-equivalence">What is EVM Equivalence?</a></li>
<li><a href="introduction.html#-all-together-now-">ðŸŽ¶ All together now ðŸŽ¶</a></li>
</ul>
</li>
<li><a href="introduction.html#protocol-guarantees">Protocol Guarantees</a></li>
<li><a href="introduction.html#network-participants">Network Participants</a>
<ul>
<li><a href="introduction.html#users">Users</a></li>
<li><a href="introduction.html#sequencers">Sequencers</a></li>
<li><a href="introduction.html#verifiers">Verifiers</a></li>
</ul>
</li>
<li><a href="introduction.html#key-interaction-diagrams">Key Interaction Diagrams</a>
<ul>
<li><a href="introduction.html#depositing-and-sending-transactions">Depositing and Sending Transactions</a></li>
<li><a href="introduction.html#withdrawing">Withdrawing</a></li>
</ul>
</li>
<li><a href="introduction.html#next-steps">Next Steps</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="foundations"><a class="header" href="#foundations">Foundations</a></h2>
<h3 id="what-is-ethereum-scalability"><a class="header" href="#what-is-ethereum-scalability">What is Ethereum scalability?</a></h3>
<p>Scaling Ethereum means increasing the number of useful transactions the Ethereum network can process. Ethereum's
limited resources, specifically bandwidth, computation, and storage, constrain the number of transactions which can be
processed on the network. Of the three resources, computation and storage are currently the most significant
bottlenecks. These bottlenecks limit the supply of transactions, leading to extremely high fees. Scaling ethereum and
reducing fees can be achieved by better utilizing bandwidth, computation and storage.</p>
<h3 id="what-is-an-optimistic-rollup"><a class="header" href="#what-is-an-optimistic-rollup">What is an Optimistic Rollup?</a></h3>
<p><a href="https://vitalik.ca/general/2021/01/05/rollup.html">Optimistic rollup</a> is a layer 2 scalability technique which
increases the computation &amp; storage capacity of Ethereum without sacrificing security or decentralization. Transaction
data is submitted on-chain but executed off-chain. If there is an error in the off-chain execution, a fault proof can
be submitted on-chain to correct the error and protect user funds. In the same way you don't go to court unless there
is a dispute, you don't execute transactions on on-chain unless there is an error.</p>
<h3 id="what-is-evm-equivalence"><a class="header" href="#what-is-evm-equivalence">What is EVM Equivalence?</a></h3>
<p><a href="https://medium.com/ethereum-optimism/introducing-evm-equivalence-5c2021deb306">EVM Equivalence</a> is complete compliance
with the state transition function described in the Ethereum yellow paper, the formal definition of the protocol. By
conforming to the Ethereum standard across EVM equivalent rollups, smart contract developers can write once and deploy
anywhere.</p>
<h3 id="-all-together-now-"><a class="header" href="#-all-together-now-">ðŸŽ¶ All together now ðŸŽ¶</a></h3>
<p><strong>Optimism is an <em>EVM equivalent</em>, <em>optimistic rollup</em> protocol designed to <em>scale Ethereum</em>.</strong></p>
<h2 id="protocol-guarantees"><a class="header" href="#protocol-guarantees">Protocol Guarantees</a></h2>
<p>In order to scale Ethereum without sacrificing security, we must preserve 3 critical properties of Ethereum layer 1:
liveness, availability, and validity.</p>
<ol>
<li><strong>Liveness</strong>
<ul>
<li>Anyone must be able to extend the rollup chain by sending transactions at any time.</li>
<li>There are two ways transactions can be sent to the rollup chain: 1) via the sequencer, and 2) directly on layer 1.
The sequencer provides low latency &amp; low cost transactions, while sending transactions directly to layer 1 provides
censorship resistance.</li>
</ul>
</li>
<li><strong>Availability</strong>
<ul>
<li>Anyone must be able to download the rollup chain.</li>
<li>All information required to derive the chain is embedded into layer 1 blocks. That way as long as the layer 1
chain is available, so is the rollup.</li>
</ul>
</li>
<li><strong>Validity</strong>
<ul>
<li>All transactions must be correctly executed and all withdrawals correctly processed.</li>
<li>The rollup state and withdrawals are managed on an L1 contract called the <code>L2OutputOracle</code>. This oracle is
guaranteed to <em>only</em> finalize correct (ie. valid) rollup block hashes given a <strong>single honest verifier</strong>
assumption. If there is ever an invalid block hash asserted on layer 1, an honest verifier will prove it is
invalid and win a bond.</li>
</ul>
</li>
</ol>
<p><strong>Footnote</strong>: There are two main ways to enforce validity of a rollup: fault proofs (optimistic rollup) and validity
proofs (zkRollup). For the purposes of this spec we only focus on fault proofs but it is worth noting that validity
proofs can also be plugged in once they have been made feasible.</p>
<h2 id="network-participants"><a class="header" href="#network-participants">Network Participants</a></h2>
<p>There are three actors in Optimism: users, sequencers, and verifiers.</p>
<p><img src="./static/assets/network-participants-overview.svg" alt="Network Overview" /></p>
<h3 id="users"><a class="header" href="#users">Users</a></h3>
<p>At the heart of the network are users (us!). Users can:</p>
<ol>
<li>Deposit or withdraw arbitrary transactions on L2 by sending data to a contract on Ethereum mainnet.</li>
<li>Use EVM smart contracts on layer 2 by sending transactions to the sequencers.</li>
<li>View the status of transactions using block explorers provided by network verifiers.</li>
</ol>
<h3 id="sequencers"><a class="header" href="#sequencers">Sequencers</a></h3>
<p>The sequencer is the primary block producer.
There may be one sequencer <strong>or</strong> many using a consensus protocol.
For 1.0.0, there is just one sequencer (currently operated under the oversight of the Optimism Foundation).
In general, specifications may use &quot;the sequencer&quot; to be a stand-in term
for the consensus protocol operated by multiple sequencers.</p>
<p>The sequencer:</p>
<ol>
<li>Accepts user off-chain transactions</li>
<li>Observes on-chain transactions (primarily, deposit events coming from L1)</li>
<li>Consolidates both kinds of transactions into L2 blocks with a specific ordering.</li>
<li>Propagates consolidated L2 blocks to L1, by submitting two things as calldata to L1:
<ul>
<li>The pending off-chain transactions accepted in step 1.</li>
<li>Sufficient information about the ordering of the on-chain transactions to successfully reconstruct the blocks
from step 3., purely by watching L1.</li>
</ul>
</li>
</ol>
<p>The sequencer also provides access to block data as early as step 3., so that users may access real-time state in
advance of L1 confirmation if they so choose.</p>
<h3 id="verifiers"><a class="header" href="#verifiers">Verifiers</a></h3>
<p>Verifiers serve two purposes:</p>
<ol>
<li>Serving rollup data to users; and</li>
<li>Verifying rollup integrity and disputing invalid assertions.</li>
</ol>
<p>In order for the network to remain secure there must be <strong>at least</strong> one honest verifier who is able to verify the
integrity of the rollup chain &amp; serve blockchain data to users.</p>
<h2 id="key-interaction-diagrams"><a class="header" href="#key-interaction-diagrams">Key Interaction Diagrams</a></h2>
<p>The following diagrams demonstrate how protocol components are utilized during key user interactions in order to
provide context when diving into any particular component specification.</p>
<h3 id="depositing-and-sending-transactions"><a class="header" href="#depositing-and-sending-transactions">Depositing and Sending Transactions</a></h3>
<p>Users will often begin their L2 journey by depositing ETH from L1.
Once they have ETH to pay fees, they'll start sending transactions on L2.
The following diagram demonstrates this interaction and all key Optimism components which are or should be utilized:</p>
<p><img src="./static/assets/sequencer-handling-deposits-and-transactions.svg" alt="Diagram of Depositing and Sending Transactions" /></p>
<p>Links to components mentioned in this diagram:</p>
<!-- - Batch Inbox (WIP) -->
<ul>
<li><a href="./protocol/rollup-node.html">Rollup Node</a></li>
<li><a href="./protocol/exec-engine.html">Execution Engine</a></li>
<li><a href="./protocol/proposals.html#l2-output-oracle-smart-contract">L2 Output Oracle</a></li>
<li><a href="./protocol/proposals.html#proposing-l2-output-commitments">L2 Output Submitter</a><!-- - Sequencer Batch Submitter (WIP) -->
<!-- - Fault Proof VM (WIP) -->
</li>
</ul>
<h3 id="withdrawing"><a class="header" href="#withdrawing">Withdrawing</a></h3>
<p>Just as important as depositing, it is critical that users can withdraw from the rollup. Withdrawals are initiated by
normal transactions on L2, but then completed using a transaction on L1 after the dispute period has elapsed.</p>
<p><img src="./static/assets/user-withdrawing-to-l1.svg" alt="Diagram of Withdrawing" /></p>
<p>Links to components mentioned in this diagram:</p>
<ul>
<li><a href="./protocol/proposals.html#l2-output-oracle-smart-contract">L2 Output Oracle</a></li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>This is a choose your own adventure. Are you interested in how a verifier works under the hood? Maybe you want to dive
deep into the bit flippin' Fault Proof VM? All key components have been linked at least once in this doc, so you should
now have the context you need to dive in deeper. <a href="https://www.youtube.com/watch?v=e5PnuIRnJW8">The world is yours</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="optimism-overview"><a class="header" href="#optimism-overview">Optimism Overview</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/overview.html#architecture-design-goals">Architecture Design Goals</a></li>
<li><a href="protocol/overview.html#components">Components</a>
<ul>
<li><a href="protocol/overview.html#l1-components">L1 Components</a></li>
<li><a href="protocol/overview.html#l2-components">L2 Components</a></li>
<li><a href="protocol/overview.html#transactionblock-propagation">Transaction/Block Propagation</a></li>
</ul>
</li>
<li><a href="protocol/overview.html#key-interactions-in-depth">Key Interactions In Depth</a>
<ul>
<li><a href="protocol/overview.html#deposits">Deposits</a></li>
<li><a href="protocol/overview.html#block-derivation">Block Derivation</a>
<ul>
<li><a href="protocol/overview.html#overview">Overview</a></li>
<li><a href="protocol/overview.html#epochs-and-the-sequencing-window">Epochs and the Sequencing Window</a></li>
<li><a href="protocol/overview.html#block-derivation-loop">Block Derivation Loop</a></li>
</ul>
</li>
<li><a href="protocol/overview.html#engine-api">Engine API</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<p>This document is a high-level technical overview of the Optimism protocol. It aims to explain how the protocol works in
an informal manner, and direct readers to other parts of the specification so that they may learn more.</p>
<p>This document assumes you've read the <a href="protocol/../introduction.html">introduction</a>.</p>
<h2 id="architecture-design-goals"><a class="header" href="#architecture-design-goals">Architecture Design Goals</a></h2>
<ul>
<li><strong>Execution-Level EVM Equivalence:</strong> The developer experience should be identical to L1 except where L2 introduces a
fundamental difference.
<ul>
<li>No special compiler.</li>
<li>No unexpected gas costs.</li>
<li>Transaction traces work out-of-the-box.</li>
<li>All existing Ethereum tooling works - all you have to do is change the chain ID.</li>
</ul>
</li>
<li><strong>Maximal compatibility with ETH1 nodes:</strong> The implementation should minimize any differences with a vanilla Geth
node, and leverage as many existing L1 standards as possible.
<ul>
<li>The execution engine/rollup node uses the ETH2 Engine API to build the canonical L2 chain.</li>
<li>The execution engine leverages Geth's existing mempool and sync implementations, including snap sync.</li>
</ul>
</li>
<li><strong>Minimize state and complexity:</strong>
<ul>
<li>Whenever possible, services contributing to the rollup infrastructure are stateless.</li>
<li>Stateful services can recover to full operation from a fresh DB using the peer-to-peer network and on-chain sync
mechanisms.</li>
<li>Running a replica is as simple as running a Geth node.</li>
</ul>
</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p><img src="protocol/../static/assets/components.svg" alt="Components" /></p>
<h3 id="l1-components"><a class="header" href="#l1-components">L1 Components</a></h3>
<ul>
<li>
<p><strong>OptimismPortal</strong>: A feed of L2 transactions which originated as smart contract calls in the L1 state.</p>
<ul>
<li>The <code>OptimismPortal</code> contract emits <code>TransactionDeposited</code> events, which the rollup driver reads in order to process
deposits.</li>
<li>Deposits are guaranteed to be reflected in the L2 state within the <em>sequencing window</em>.</li>
<li>Beware that <em>transactions</em> are deposited, not tokens. However deposited transactions are a key part of implementing
token deposits (tokens are locked on L1, then minted on L2 via a deposited transaction).</li>
</ul>
</li>
<li>
<p><strong>BatchInbox</strong>: An L1 address to which the Batch Submitter submits transaction batches.</p>
<ul>
<li>Transaction batches include L2 transaction calldata, timestamps, and ordering information.</li>
<li>The BatchInbox is a regular EOA address. This lets us pass on gas cost savings by not executing any EVM code.</li>
</ul>
</li>
<li>
<p><strong>L2OutputOracle</strong>: A smart contract that stores <a href="protocol/../glossary.html#l2-output">L2 output roots</a> for use with withdrawals
and fault proofs.</p>
</li>
</ul>
<h3 id="l2-components"><a class="header" href="#l2-components">L2 Components</a></h3>
<ul>
<li><strong>Rollup Node</strong>:
<ul>
<li>A standalone, stateless binary.</li>
<li>Receives L2 transactions from users.</li>
<li>Syncs and verifies rollup data on L1.</li>
<li>Applies rollup-specific block production rules to synthesize blocks from L1.</li>
<li>Appends blocks to the L2 chain using the Engine API.</li>
<li>Handles L1 reorgs.</li>
<li>Distributes unsubmitted blocks to other rollup nodes.</li>
</ul>
</li>
<li><strong>Execution Engine (EE)</strong>:
<ul>
<li>A vanilla Geth node with minor modifications to support Optimism.</li>
<li>Maintains L2 state.</li>
<li>Sync state to other L2 nodes for fast onboarding.</li>
<li>Serves the Engine API to the rollup node.</li>
</ul>
</li>
<li><strong>Batch Submitter</strong>
<ul>
<li>A background process that submits <a href="protocol/../glossary.html#sequencer-batch">transaction batches</a> to the <code>BatchInbox</code> address.</li>
</ul>
</li>
<li><strong>Output Submitter</strong>
<ul>
<li>A background process that submits L2 output commitments to the <code>L2OutputOracle</code>.</li>
</ul>
</li>
</ul>
<h3 id="transactionblock-propagation"><a class="header" href="#transactionblock-propagation">Transaction/Block Propagation</a></h3>
<p><strong>Spec links:</strong></p>
<ul>
<li><a href="protocol/exec-engine.html">Execution Engine</a></li>
</ul>
<p>Since the EE uses Geth under the hood, Optimism uses Geth's built-in peer-to-peer network and transaction pool to
propagate transactions. The same network can also be used to propagate submitted blocks and support snap-sync.</p>
<p>Unsubmitted blocks, however, are propagated using a separate peer-to-peer network of Rollup Nodes. This is optional,
however, and is provided as a convenience to lower latency for verifiers and their JSON-RPC clients.</p>
<p>The below diagram illustrates how the sequencer and verifiers fit together:</p>
<p><img src="protocol/../static/assets/propagation.svg" alt="Propagation" /></p>
<h2 id="key-interactions-in-depth"><a class="header" href="#key-interactions-in-depth">Key Interactions In Depth</a></h2>
<h3 id="deposits"><a class="header" href="#deposits">Deposits</a></h3>
<p><strong>Spec links:</strong></p>
<ul>
<li><a href="protocol/deposits.html">Deposits</a></li>
</ul>
<p>Optimism supports two types of deposits: user deposits, and L1 attributes deposits. To perform a user deposit, users
call the <code>depositTransaction</code> method on the <code>OptimismPortal</code> contract. This in turn emits <code>TransactionDeposited</code> events,
which the rollup node reads during block derivation.</p>
<p>L1 attributes deposits are used to register L1 block attributes (number, timestamp, etc.) on L2 via a call to the L1
Attributes Predeploy. They cannot be initiated by users, and are instead added to L2 blocks automatically by the rollup
node.</p>
<p>Both deposit types are represented by a single custom EIP-2718 transaction type on L2.</p>
<h3 id="block-derivation"><a class="header" href="#block-derivation">Block Derivation</a></h3>
<h4 id="overview"><a class="header" href="#overview">Overview</a></h4>
<p>The rollup chain can be deterministically derived given an L1 Ethereum chain. The fact that the entire rollup chain can
be derived based on L1 blocks is <em>what makes Optimism a rollup</em>. This process can be represented as:</p>
<pre><code class="language-text">derive_rollup_chain(l1_blockchain) -&gt; rollup_blockchain
</code></pre>
<p>Optimism's block derivation function is designed such that it:</p>
<ul>
<li>Requires no state other than what is easily accessible using L1 and L2 execution engine APIs.</li>
<li>Supports sequencers and sequencer consensus.</li>
<li>Is resilient to sequencer censorship.</li>
</ul>
<h4 id="epochs-and-the-sequencing-window"><a class="header" href="#epochs-and-the-sequencing-window">Epochs and the Sequencing Window</a></h4>
<p>The rollup chain is subdivided into epochs. There is a 1:1 correspondence between L1 block numbers and epoch numbers.</p>
<p>For L1 block number <code>n</code>, there is a corresponding rollup epoch <code>n</code> which can only be derived after a <em>sequencing window</em>
worth of blocks has passed, i.e. after L1 block number <code>n + SEQUENCING_WINDOW_SIZE</code> is added to the L1 chain.</p>
<p>Each epoch contains at least one block. Every block in the epoch contains an L1 info transaction which contains
contextual information about L1 such as the block hash and timestamp. The first block in the epoch also contains all
deposits initiated via the <code>OptimismPortal</code> contract on L1. All L2 blocks can also contain <em>sequenced transactions</em>,
i.e. transactions submitted directly to the sequencer.</p>
<p>Whenever the sequencer creates a new L2 block for a given epoch, it must submit it to L1 as part of a <em>batch</em>, within
the epoch's sequencing window (i.e. the batch must land before L1 block <code>n + SEQUENCING_WINDOW_SIZE</code>). These batches are
(along with the <code>TransactionDeposited</code> L1 events) what allows the derivation of the L2 chain from the L1 chain.</p>
<p>The sequencer does not need for a L2 block to be batch-submitted to L1 in order to build on top of it. In fact, batches
typically contain multiple L2 blocks worth of sequenced transactions. This is what enables
<em>fast transaction confirmations</em> on the sequencer.</p>
<p>Since transaction batches for a given epoch can be submitted anywhere within the sequencing window, verifiers must
search all blocks within the window for transaction batches. This protects against the uncertainty of transaction
inclusion of L1. This uncertainty is also why we need the sequencing window in the first place: otherwise the sequencer
could retroactively add blocks to an old epoch, and validators wouldn't know when they can finalize an epoch.</p>
<p>The sequencing window also prevents censorship by the sequencer: deposits made on a given L1 block will be included in
the L2 chain at worst after <code>SEQUENCING_WINDOW_SIZE</code> L1 blocks have passed.</p>
<p>The following diagram describes this relationship, and how L2 blocks are derived from L1 blocks (L1 info transactions
have been elided):</p>
<p><img src="protocol/../static/assets/sequencer-block-gen.svg" alt="Epochs and Sequencing Windows" /></p>
<h4 id="block-derivation-loop"><a class="header" href="#block-derivation-loop">Block Derivation Loop</a></h4>
<p>A sub-component of the rollup node called the <em>rollup driver</em> is actually responsible for performing block derivation.
The rollup driver is essentially an infinite loop that runs the block derivation function. For each epoch, the block
derivation function performs the following steps:</p>
<ol>
<li>Downloads deposit and transaction batch data for each block in the sequencing window.</li>
<li>Converts the deposit and transaction batch data into payload attributes for the Engine API.</li>
<li>Submits the payload attributes to the Engine API, where they are converted into blocks and added to the canonical
chain.</li>
</ol>
<p>This process is then repeated with incrementing epochs until the tip of L1 is reached.</p>
<h3 id="engine-api"><a class="header" href="#engine-api">Engine API</a></h3>
<p>The rollup driver doesn't actually create blocks. Instead, it directs the execution engine to do so via the Engine API.
For each iteration of the block derivation loop described above, the rollup driver will craft a <em>payload attributes</em>
object and send it to the execution engine. The execution engine will then convert the payload attributes object into a
block, and add it to the chain. The basic sequence of the rollup driver is as follows:</p>
<ol>
<li>Call <a href="protocol/derivation.html#engine-api-usage">fork choice updated</a> with the payload attributes object. We'll skip over the details of the
fork choice state parameter for now - just know that one of its fields is the L2 chain's <code>headBlockHash</code>, and that it
is set to the block hash of the tip of the L2 chain. The Engine API returns a payload ID.</li>
<li>Call <a href="protocol/derivation.html#engine-api-usage">get payload</a> with the payload ID returned in step 1. The engine API returns a payload object
that includes a block hash as one of its fields.</li>
<li>Call <a href="protocol/derivation.html#engine-api-usage">new payload</a> with the payload returned in step 2. (Ectone blocks, must use V3, pre-Ecotone
blocks MUST use the V2 version)</li>
<li>Call <a href="protocol/derivation.html#engine-api-usage">fork choice updated</a> with the fork choice parameter's <code>headBlockHash</code> set to the block hash
returned in step 2. The tip of the L2 chain is now the block created in step 1.</li>
</ol>
<p>The swimlane diagram below visualizes the process:</p>
<p><img src="protocol/../static/assets/engine.svg" alt="Engine API" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="standard-bridges"><a class="header" href="#standard-bridges">Standard Bridges</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/bridges.html#overview">Overview</a></li>
<li><a href="protocol/bridges.html#token-depositing">Token Depositing</a></li>
<li><a href="protocol/bridges.html#upgradability">Upgradability</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The standard bridges are responsible for allowing cross domain
ETH and ERC20 token transfers. They are built on top of the cross domain
messenger contracts and give a standard interface for depositing tokens.</p>
<p>The bridge works for both L1 native tokens and L2 native tokens. The legacy API
is preserved to ensure that existing applications will not experience any
problems with the Bedrock <code>StandardBridge</code> contracts.</p>
<p>The <code>L2StandardBridge</code> is a predeploy contract located at
<code>0x4200000000000000000000000000000000000010</code>.</p>
<pre><code class="language-solidity">interface StandardBridge {
    event ERC20BridgeFinalized(address indexed localToken, address indexed remoteToken, address indexed from, address to, uint256 amount, bytes extraData);
    event ERC20BridgeInitiated(address indexed localToken, address indexed remoteToken, address indexed from, address to, uint256 amount, bytes extraData);
    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes extraData);
    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes extraData);

    function bridgeERC20(address _localToken, address _remoteToken, uint256 _amount, uint32 _minGasLimit, bytes memory _extraData) external;
    function bridgeERC20To(address _localToken, address _remoteToken, address _to, uint256 _amount, uint32 _minGasLimit, bytes memory _extraData) external;
    function bridgeETH(uint32 _minGasLimit, bytes memory _extraData) payable external;
    function bridgeETHTo(address _to, uint32 _minGasLimit, bytes memory _extraData) payable external;
    function deposits(address, address) view external returns (uint256);
    function finalizeBridgeERC20(address _localToken, address _remoteToken, address _from, address _to, uint256 _amount, bytes memory _extraData) external;
    function finalizeBridgeETH(address _from, address _to, uint256 _amount, bytes memory _extraData) payable external;
    function messenger() view external returns (address);
    function OTHER_BRIDGE() view external returns (address);
}
</code></pre>
<h2 id="token-depositing"><a class="header" href="#token-depositing">Token Depositing</a></h2>
<p>The <code>bridgeERC20</code> function is used to send a token from one domain to another
domain. An <code>OptimismMintableERC20</code> token contract must exist on the remote
domain to be able to deposit tokens to that domain. One of these tokens can be
deployed using the <code>OptimismMintableERC20Factory</code> contract.</p>
<h2 id="upgradability"><a class="header" href="#upgradability">Upgradability</a></h2>
<p>Both the L1 and L2 standard bridges should be behind upgradable proxies.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cross-domain-messengers"><a class="header" href="#cross-domain-messengers">Cross Domain Messengers</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/messengers.html#overview">Overview</a></li>
<li><a href="protocol/messengers.html#message-passing">Message Passing</a></li>
<li><a href="protocol/messengers.html#upgradability">Upgradability</a></li>
<li><a href="protocol/messengers.html#message-versioning">Message Versioning</a>
<ul>
<li><a href="protocol/messengers.html#message-version-0">Message Version 0</a></li>
<li><a href="protocol/messengers.html#message-version-1">Message Version 1</a></li>
</ul>
</li>
<li><a href="protocol/messengers.html#backwards-compatibility-notes">Backwards Compatibility Notes</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The cross domain messengers are responsible for providing a higher level API for
developers who are interested in sending cross domain messages. They allow for
the ability to replay cross domain messages and sit directly on top of the lower
level system contracts responsible for cross domain messaging on L1 and L2.</p>
<p>The <code>CrossDomainMessenger</code> is extended to create both an
<code>L1CrossDomainMessenger</code> as well as a <code>L2CrossDomainMessenger</code>.
These contracts are then extended with their legacy APIs to provide backwards
compatibility for applications that integrated before the Bedrock system
upgrade.</p>
<p>The <code>L2CrossDomainMessenger</code> is a predeploy contract located at
<code>0x4200000000000000000000000000000000000007</code>.</p>
<p>The base <code>CrossDomainMessenger</code> interface is:</p>
<pre><code class="language-solidity">interface CrossDomainMessenger {
    event FailedRelayedMessage(bytes32 indexed msgHash);
    event RelayedMessage(bytes32 indexed msgHash);
    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);
    event SentMessageExtension1(address indexed sender, uint256 value);

    function MESSAGE_VERSION() external view returns (uint16);
    function MIN_GAS_CALLDATA_OVERHEAD() external view returns (uint64);
    function MIN_GAS_CONSTANT_OVERHEAD() external view returns (uint64);
    function MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR() external view returns (uint64);
    function MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR() external view returns (uint64);
    function OTHER_MESSENGER() external view returns (address);
    function baseGas(bytes memory _message, uint32 _minGasLimit) external pure returns (uint64);
    function failedMessages(bytes32) external view returns (bool);
    function messageNonce() external view returns (uint256);
    function relayMessage(
        uint256 _nonce,
        address _sender,
        address _target,
        uint256 _value,
        uint256 _minGasLimit,
        bytes memory _message
    ) external payable;
    function sendMessage(address _target, bytes memory _message, uint32 _minGasLimit) external payable;
    function successfulMessages(bytes32) external view returns (bool);
    function xDomainMessageSender() external view returns (address);
}
</code></pre>
<h2 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h2>
<p>The <code>sendMessage</code> function is used to send a cross domain message. To trigger
the execution on the other side, the <code>relayMessage</code> function is called.
Successful messages have their hash stored in the <code>successfulMessages</code> mapping
while unsuccessful messages have their hash stored in the <code>failedMessages</code>
mapping.</p>
<p>The user experience when sending from L1 to L2 is a bit different than when
sending a transaction from L2 to L1. When going into L1 from L2, the user does
not need to call <code>relayMessage</code> on L2 themselves. The user pays for L2 gas on L1
and the transaction is automatically pulled into L2 where it is executed on L2.
When going from L2 into L1, the user proves their withdrawal on OptimismPortal,
then waits for the finalization window to pass, and then finalizes the withdrawal
on the OptimismPortal, which calls <code>relayMessage</code> on the
<code>L1CrossDomainMessenger</code> to finalize the withdrawal.</p>
<h2 id="upgradability-1"><a class="header" href="#upgradability-1">Upgradability</a></h2>
<p>The L1 and L2 cross domain messengers should be deployed behind upgradable
proxies. This will allow for updating the message version.</p>
<h2 id="message-versioning"><a class="header" href="#message-versioning">Message Versioning</a></h2>
<p>Messages are versioned based on the first 2 bytes of their nonce. Depending on
the version, messages can have a different serialization and hashing scheme.
The first two bytes of the nonce are reserved for version metadata because
a version field was not originally included in the messages themselves, but
a <code>uint256</code> nonce is so large that we can very easily pack additional data
into that field.</p>
<h3 id="message-version-0"><a class="header" href="#message-version-0">Message Version 0</a></h3>
<pre><code class="language-solidity">abi.encodeWithSignature(
    &quot;relayMessage(address,address,bytes,uint256)&quot;,
    _target,
    _sender,
    _message,
    _messageNonce
);
</code></pre>
<h3 id="message-version-1"><a class="header" href="#message-version-1">Message Version 1</a></h3>
<pre><code class="language-solidity">abi.encodeWithSignature(
    &quot;relayMessage(uint256,address,address,uint256,uint256,bytes)&quot;,
    _nonce,
    _sender,
    _target,
    _value,
    _gasLimit,
    _data
);
</code></pre>
<h2 id="backwards-compatibility-notes"><a class="header" href="#backwards-compatibility-notes">Backwards Compatibility Notes</a></h2>
<p>An older version of the messenger contracts had the concept of blocked messages
in a <code>blockedMessages</code> mapping. This functionality was removed from the
messengers because a smart attacker could get around any message blocking
attempts. It also saves gas on finalizing withdrawals.</p>
<p>The concept of a &quot;relay id&quot; and the <code>relayedMessages</code> mapping was removed.
It was built as a way to be able to fund third parties who relayed messages
on the behalf of users, but it was improperly implemented as it was impossible
to know if the relayed message actually succeeded.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="deposits-1"><a class="header" href="#deposits-1">Deposits</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/deposits.html#overview">Overview</a></li>
<li><a href="protocol/deposits.html#the-deposited-transaction-type">The Deposited Transaction Type</a>
<ul>
<li><a href="protocol/deposits.html#source-hash-computation">Source hash computation</a></li>
<li><a href="protocol/deposits.html#kinds-of-deposited-transactions">Kinds of Deposited Transactions</a></li>
<li><a href="protocol/deposits.html#validation-and-authorization-of-deposited-transactions">Validation and Authorization of Deposited Transactions</a></li>
<li><a href="protocol/deposits.html#execution">Execution</a>
<ul>
<li><a href="protocol/deposits.html#nonce-handling">Nonce Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/deposits.html#deposit-receipt">Deposit Receipt</a></li>
<li><a href="protocol/deposits.html#l1-attributes-deposited-transaction">L1 Attributes Deposited Transaction</a>
<ul>
<li><a href="protocol/deposits.html#l1-attributes-deposited-transaction-calldata">L1 Attributes Deposited Transaction Calldata</a>
<ul>
<li><a href="protocol/deposits.html#l1-attributes---bedrock-canyon-delta">L1 Attributes - Bedrock, Canyon, Delta</a></li>
<li><a href="protocol/deposits.html#l1-attributes---ecotone">L1 Attributes - Ecotone</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/deposits.html#special-accounts-on-l2">Special Accounts on L2</a>
<ul>
<li><a href="protocol/deposits.html#l1-attributes-depositor-account">L1 Attributes Depositor Account</a></li>
<li><a href="protocol/deposits.html#l1-attributes-predeployed-contract">L1 Attributes Predeployed Contract</a>
<ul>
<li><a href="protocol/deposits.html#l1-attributes-predeployed-contract-reference-implementation">L1 Attributes Predeployed Contract: Reference Implementation</a></li>
<li><a href="protocol/deposits.html#ecotone-l1block-upgrade">Ecotone L1Block upgrade</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/deposits.html#user-deposited-transactions">User-Deposited Transactions</a>
<ul>
<li><a href="protocol/deposits.html#deposit-contract">Deposit Contract</a>
<ul>
<li><a href="protocol/deposits.html#address-aliasing">Address Aliasing</a></li>
<li><a href="protocol/deposits.html#deposit-contract-implementation-optimism-portal">Deposit Contract Implementation: Optimism Portal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p><a href="protocol/../glossary.html#deposited">Deposited transactions</a>, also known as <a href="protocol/../glossary.html#deposits">deposits</a> are transactions which
are initiated on L1, and executed on L2. This document outlines a new <a href="protocol/../glossary.html#transaction-type">transaction
type</a> for deposits. It also describes how deposits are initiated on L1, along
with the authorization and validation conditions on L2.</p>
<p><strong>Vocabulary note</strong>: <em>deposited transaction</em> refers specifically to an L2 transaction, while
<em>deposit</em> can refer to the transaction at various stages (for instance when it is deposited on L1).</p>
<h2 id="the-deposited-transaction-type"><a class="header" href="#the-deposited-transaction-type">The Deposited Transaction Type</a></h2>
<p><a href="protocol/../glossary.html#deposited">Deposited transactions</a> have the following notable distinctions from existing
transaction types:</p>
<ol>
<li>They are derived from Layer 1 blocks, and must be included as part of the protocol.</li>
<li>They do not include signature validation (see <a href="protocol/deposits.html#user-deposited-transactions">User-Deposited Transactions</a>
for the rationale).</li>
<li>They buy their L2 gas on L1 and, as such, the L2 gas is not refundable.</li>
</ol>
<p>We define a new <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a> compatible transaction type with the prefix <code>0x7E</code> to represent a deposit transaction.</p>
<p>A deposit has the following fields
(rlp encoded in the order they appear here):</p>
<ul>
<li><code>bytes32 sourceHash</code>: the source-hash, uniquely identifies the origin of the deposit.</li>
<li><code>address from</code>: The address of the sender account.</li>
<li><code>address to</code>: The address of the recipient account, or the null (zero-length) address if the
deposited transaction is a contract creation.</li>
<li><code>uint256 mint</code>: The ETH value to mint on L2.</li>
<li><code>uint256 value</code>: The ETH value to send to the recipient account.</li>
<li><code>uint64 gas</code>: The gas limit for the L2 transaction.</li>
<li><code>bool isSystemTx</code>: If true, the transaction does not interact with the L2 block gas pool.
<ul>
<li>Note: boolean is disabled (enforced to be <code>false</code>) starting from the Regolith upgrade.</li>
</ul>
</li>
<li><code>bytes data</code>: The calldata.</li>
</ul>
<p>In contrast to <a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155</a> transactions, this transaction type:</p>
<ul>
<li>Does not include a <code>nonce</code>, since it is identified by the <code>sourceHash</code>.
API responses still include a <code>nonce</code> attribute:
<ul>
<li>Before Regolith: the <code>nonce</code> is always <code>0</code></li>
<li>With Regolith: the <code>nonce</code> is set to the <code>depositNonce</code> attribute of the corresponding transaction receipt.</li>
</ul>
</li>
<li>Does not include signature information, and makes the <code>from</code> address explicit.
API responses contain zeroed signature <code>v</code>, <code>r</code>, <code>s</code> values for backwards compatibility.</li>
<li>Includes new <code>sourceHash</code>, <code>from</code>, <code>mint</code>, and <code>isSystemTx</code> attributes.
API responses contain these as additional fields.</li>
</ul>
<p>We select <code>0x7E</code> because transaction type identifiers are currently allowed to go up to <code>0x7F</code>.
Picking a high identifier minimizes the risk that the identifier will be used be claimed by another
transaction type on the L1 chain in the future. We don't pick <code>0x7F</code> itself in case it becomes used
for a variable-length encoding scheme.</p>
<h3 id="source-hash-computation"><a class="header" href="#source-hash-computation">Source hash computation</a></h3>
<p>The <code>sourceHash</code> of a deposit transaction is computed based on the origin:</p>
<ul>
<li>User-deposited:
<code>keccak256(bytes32(uint256(0)), keccak256(l1BlockHash, bytes32(uint256(l1LogIndex))))</code>.
Where the <code>l1BlockHash</code>, and <code>l1LogIndex</code> all refer to the inclusion of the deposit log event on L1.
<code>l1LogIndex</code> is the index of the deposit event log in the combined list of log events of the block.</li>
<li>L1 attributes deposited:
<code>keccak256(bytes32(uint256(1)), keccak256(l1BlockHash, bytes32(uint256(seqNumber))))</code>.
Where <code>l1BlockHash</code> refers to the L1 block hash of which the info attributes are deposited.
And <code>seqNumber = l2BlockNum - l2EpochStartBlockNum</code>,
where <code>l2BlockNum</code> is the L2 block number of the inclusion of the deposit tx in L2,
and <code>l2EpochStartBlockNum</code> is the L2 block number of the first L2 block in the epoch.</li>
<li>Upgrade-deposited: <code>keccak256(bytes32(uint256(2)), keccak256(intent))</code>.
Where <code>intent</code> is a UTF-8 byte string, identifying the upgrade intent.</li>
</ul>
<p>Without a <code>sourceHash</code> in a deposit, two different deposited transactions could have the same exact hash.</p>
<p>The outer <code>keccak256</code> hashes the actual uniquely identifying information with a domain,
to avoid collisions between different types of sources.</p>
<p>We do not use the sender's nonce to ensure uniqueness because this would require an extra L2 EVM state read from the
<a href="protocol/../glossary.html#execution-engine">execution engine</a> during block-derivation.</p>
<h3 id="kinds-of-deposited-transactions"><a class="header" href="#kinds-of-deposited-transactions">Kinds of Deposited Transactions</a></h3>
<p>Although we define only one new transaction type, we can distinguish between two kinds of deposited
transactions, based on their positioning in the L2 block:</p>
<ol>
<li>The first transaction MUST be a <a href="protocol/deposits.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a>, followed by</li>
<li>an array of zero-or-more <a href="protocol/deposits.html#user-deposited-transactions">user-deposited transactions</a>
submitted to the deposit feed contract on L1 (called <code>OptimismPortal</code>).
User-deposited transactions are only present in the first block of a L2 epoch.</li>
</ol>
<p>We only define a single new transaction type in order to minimize modifications to L1 client
software, and complexity in general.</p>
<h3 id="validation-and-authorization-of-deposited-transactions"><a class="header" href="#validation-and-authorization-of-deposited-transactions">Validation and Authorization of Deposited Transactions</a></h3>
<p>As noted above, the deposited transaction type does not include a signature for validation. Rather,
authorization is handled by the <a href="protocol/../glossary.html#L2-chain-derivation">L2 chain derivation</a> process, which when correctly
applied will only derive transactions with a <code>from</code> address attested to by the logs of the <a href="protocol/deposits.html#deposit-contract">L1
deposit contract</a>.</p>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>In order to execute a deposited transaction:</p>
<p>First, the balance of the <code>from</code> account MUST be increased by the amount of <code>mint</code>.
This is unconditional, and does not revert on deposit failure.</p>
<p>Then, the execution environment for a deposited transaction is initialized based on the
transaction's attributes, in exactly the same manner as it would be for an EIP-155 transaction.</p>
<p>The deposit transaction is processed exactly like a type-3 (EIP-1559) transaction, with the exception of:</p>
<ul>
<li>No fee fields are verified: the deposit does not have any, as it pays for gas on L1.</li>
<li>No <code>nonce</code> field is verified: the deposit does not have any, it's uniquely identified by its <code>sourceHash</code>.</li>
<li>No access-list is processed: the deposit has no access-list, and it is thus processed as if the access-list is empty.</li>
<li>No check if <code>from</code> is an Externally Owner Account (EOA): the deposit is ensured not to be an EOA through L1 address
masking, this may change in future L1 contract-deployments to e.g. enable an account-abstraction like mechanism.</li>
<li>Before the Regolith upgrade:
<ul>
<li>The execution output states a non-standard gas usage:
<ul>
<li>If <code>isSystemTx</code> is false: execution output states it uses <code>gasLimit</code> gas.</li>
<li>If <code>isSystemTx</code> is true: execution output states it uses <code>0</code> gas.</li>
</ul>
</li>
</ul>
</li>
<li>No gas is refunded as ETH. (either by not refunding or utilizing the fact the gas-price of the deposit is <code>0</code>)</li>
<li>No transaction priority fee is charged. No payment is made to the block fee-recipient.</li>
<li>No L1-cost fee is charged, as deposits are derived from L1 and do not have to be submitted as data back to it.</li>
<li>No base fee is charged. The total base fee accounting does not change.</li>
</ul>
<p>Note that this includes contract-deployment behavior like with regular transactions, and gas
metering is the same (with the exception of fee related changes above), including metering of
intrinsic gas.</p>
<p>Any non-EVM state-transition error emitted by the EVM execution is processed in a special way:</p>
<ul>
<li>It is transformed into an EVM-error:
i.e. the deposit will always be included, but its receipt will indicate a failure
if it runs into a non-EVM state-transition error, e.g. failure to transfer the specified
<code>value</code> amount of ETH due to insufficient account-balance.</li>
<li>The world state is rolled back to the start of the EVM processing, after the minting part of the deposit.</li>
<li>The <code>nonce</code> of <code>from</code> in the world state is incremented by 1, making the error equivalent to a native EVM failure.
Note that a previous <code>nonce</code> increment may have happened during EVM processing, but this would be rolled back first.</li>
</ul>
<p>Finally, after the above processing, the execution post-processing runs the same:
i.e. the gas pool and receipt are processed identical to a regular transaction.
Starting with the Regolith upgrade however, the receipt of deposit transactions is extended with an additional
<code>depositNonce</code> value, storing the <code>nonce</code> value of the <code>from</code> sender as registered <em>before</em> the EVM processing.</p>
<p>Note that the gas used as stated by the execution output is subtracted from the gas pool,
but this execution output value has special edge cases before the Regolith upgrade.</p>
<p>Note for application developers: because <code>CALLER</code> and <code>ORIGIN</code> are set to <code>from</code>, the
semantics of using the <code>tx.origin == msg.sender</code> check will not work to determine whether
or not a caller is an EOA during a deposit transaction. Instead, the check could only be useful for
identifying the first call in the L2 deposit transaction. However this check does still satisfy
the common case in which developers are using this check to ensure that the <code>CALLER</code> is unable to
execute code before and after the call.</p>
<h4 id="nonce-handling"><a class="header" href="#nonce-handling">Nonce Handling</a></h4>
<p>Despite the lack of signature validation, we still increment the nonce of the <code>from</code> account when a
deposit transaction is executed. In the context of a deposit-only roll up, this is not necessary
for transaction ordering or replay prevention, however it maintains consistency with the use of
nonces during <a href="https://github.com/ethereum/execution-specs/blob/617903a8f8d7b50cf71bf1aa733c37897c8d75c1/src/ethereum/frontier/utils/address.py#L40">contract creation</a>. It may also simplify integration with downstream
tooling (such as wallets and block explorers).</p>
<h2 id="deposit-receipt"><a class="header" href="#deposit-receipt">Deposit Receipt</a></h2>
<p>Transaction receipts use standard typing as per <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a>.
The Deposit transaction receipt type is equal to a regular receipt,
but extended with an optional <code>depositNonce</code> field.</p>
<p>The RLP-encoded consensus-enforced fields are:</p>
<ul>
<li><code>postStateOrStatus</code> (standard): this contains the transaction status, see <a href="https://eips.ethereum.org/EIPS/eip-658">EIP-658</a>.</li>
<li><code>cumulativeGasUsed</code> (standard): gas used in the block thus far, including this transaction.
<ul>
<li>The actual gas used is derived from the difference in <code>CumulativeGasUsed</code> with the previous transaction.</li>
<li>Starting with Regolith, this accounts for the actual gas usage by the deposit, like regular transactions.</li>
</ul>
</li>
<li><code>bloom</code> (standard): bloom filter of the transaction logs.</li>
<li><code>logs</code> (standard): log events emitted by the EVM processing.</li>
<li><code>depositNonce</code> (unique extension): Optional field. The deposit transaction persists the nonce used during execution.</li>
<li><code>depositNonceVersion</code> (unique extension): Optional field. The value must be 1 if the field is present
<ul>
<li>Before Canyon, these <code>depositNonce</code> &amp; <code>depositNonceVersion</code> fields must always be omitted.</li>
<li>With Canyon, these <code>depositNonce</code> &amp; <code>depositNonceVersion</code> fields must always be included.</li>
</ul>
</li>
</ul>
<p>Starting with Regolith, the receipt API responses utilize the receipt changes for more accurate response data:</p>
<ul>
<li>The <code>depositNonce</code> is included in the receipt JSON data in API responses</li>
<li>For contract-deployments (when <code>to == null</code>), the <code>depositNonce</code> helps derive the correct <code>contractAddress</code> meta-data,
instead of assuming the nonce was zero.</li>
<li>The <code>cumulativeGasUsed</code> accounts for the actual gas usage, as metered in the EVM processing.</li>
</ul>
<h2 id="l1-attributes-deposited-transaction"><a class="header" href="#l1-attributes-deposited-transaction">L1 Attributes Deposited Transaction</a></h2>
<p>An <a href="protocol/../glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a> is a deposit transaction sent to the <a href="protocol/deposits.html#l1-attributes-predeployed-contract">L1
attributes predeployed contract</a>.</p>
<p>This transaction MUST have the following values:</p>
<ol>
<li><code>from</code> is <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddead0001</code> (the address of the
<a href="protocol/deposits.html#l1-attributes-depositor-account">L1 Attributes depositor account</a>)</li>
<li><code>to</code> is <code>0x4200000000000000000000000000000000000015</code> (the address of the <a href="protocol/deposits.html#l1-attributes-predeployed-contract">L1 attributes predeployed
contract</a>).</li>
<li><code>mint</code> is <code>0</code></li>
<li><code>value</code> is <code>0</code></li>
<li><code>gasLimit</code> is set to 150,000,000 prior to the Regolith upgrade, and 1,000,000 after.</li>
<li><code>isSystemTx</code> is set to <code>true</code> prior to the Regolith upgrade, and <code>false</code> after.</li>
<li><code>data</code> is an encoded call to the <a href="protocol/deposits.html#l1-attributes-predeployed-contract">L1 attributes predeployed contract</a> that
depends on the upgrades that are active (see below).</li>
</ol>
<p>This system-initiated transaction for L1 attributes is not charged any ETH for its allocated
<code>gasLimit</code>, as it is considered part of state-transition processing.</p>
<h3 id="l1-attributes-deposited-transaction-calldata"><a class="header" href="#l1-attributes-deposited-transaction-calldata">L1 Attributes Deposited Transaction Calldata</a></h3>
<h4 id="l1-attributes---bedrock-canyon-delta"><a class="header" href="#l1-attributes---bedrock-canyon-delta">L1 Attributes - Bedrock, Canyon, Delta</a></h4>
<p>The <code>data</code> field of the L1 attributes deposited transaction is an <a href="https://docs.soliditylang.org/en/v0.8.10/abi-spec.html">ABI</a> encoded call to the
<code>setL1BlockValues()</code> function with correct values associated with the corresponding L1 block
(cf. <a href="protocol/deposits.html#l1-attributes-predeployed-contract-reference-implementation">reference implementation</a>).</p>
<h4 id="l1-attributes---ecotone"><a class="header" href="#l1-attributes---ecotone">L1 Attributes - Ecotone</a></h4>
<p>On the Ecotone activation block, and if Ecotone is not activated at Genesis,
the L1 Attributes Transaction includes a call to <code>setL1BlockValues()</code>
because the L1 Attributes transaction precedes the <a href="protocol/derivation.html#network-upgrade-automation-transactions">Ecotone Upgrade Transactions</a>,
meaning that <code>setL1BlockValuesEcotone</code> is not guaranteed to exist yet.</p>
<p>Every subsequent L1 Attributes transaction should include a call to the <code>setL1BlockValuesEcotone()</code> function.
The input args are no longer ABI encoded function parameters,
but are instead packed into 5 32-byte aligned segments (starting after the function selector).
Each unsigned integer argument is encoded as big-endian using a number of bytes corresponding to the underlying type.
The overall calldata layout is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Input arg</th><th>Type</th><th>Calldata bytes</th><th>Segment</th></tr></thead><tbody>
<tr><td>{0x440a5e20}</td><td></td><td>0-3</td><td>n/a</td></tr>
<tr><td>baseFeeScalar</td><td>uint32</td><td>4-7</td><td>1</td></tr>
<tr><td>blobBaseFeeScalar</td><td>uint32</td><td>8-11</td><td></td></tr>
<tr><td>sequenceNumber</td><td>uint64</td><td>12-19</td><td></td></tr>
<tr><td>l1BlockTimestamp</td><td>uint64</td><td>20-27</td><td></td></tr>
<tr><td>l1BlockNumber</td><td>uint64</td><td>28-35</td><td></td></tr>
<tr><td>basefee</td><td>uint256</td><td>36-67</td><td>2</td></tr>
<tr><td>blobBaseFee</td><td>uint256</td><td>68-99</td><td>3</td></tr>
<tr><td>l1BlockHash</td><td>bytes32</td><td>100-131</td><td>4</td></tr>
<tr><td>batcherHash</td><td>bytes32</td><td>132-163</td><td>5</td></tr>
</tbody></table>
</div>
<p>Total calldata length MUST be exactly 164 bytes, implying the sixth and final segment is only
partially filled. This helps to slow database growth as every L2 block includes a L1 Attributes
deposit transaction.</p>
<p>In the first L2 block after the Ecotone activation block, the Ecotone L1 attributes are first used.</p>
<p>The pre-Ecotone values are migrated over 1:1.
Blocks after the Ecotone activation block contain all pre-Ecotone values 1:1,
and also set the following new attributes:</p>
<ul>
<li>The <code>baseFeeScalar</code> is set to the pre-Ecotone <code>scalar</code> value.</li>
<li>The <code>blobBaseFeeScalar</code> is set to <code>0</code>.</li>
<li>The pre-Ecotone <code>overhead</code> attribute is dropped.</li>
<li>The <code>blobBaseFee</code> is set to the L1 blob base fee of the L1 origin block.
Or <code>1</code> if the L1 block does not support blobs.
The <code>1</code> value is derived from the EIP-4844 <code>MIN_BLOB_GASPRICE</code>.</li>
</ul>
<h2 id="special-accounts-on-l2"><a class="header" href="#special-accounts-on-l2">Special Accounts on L2</a></h2>
<p>The L1 attributes deposit transaction involves two special purpose accounts:</p>
<ol>
<li>The L1 attributes depositor account</li>
<li>The L1 attributes predeployed contract</li>
</ol>
<h3 id="l1-attributes-depositor-account"><a class="header" href="#l1-attributes-depositor-account">L1 Attributes Depositor Account</a></h3>
<p>The depositor account is an <a href="protocol/../glossary.html#eoa">EOA</a> with no known private key. It has the address
<code>0xdeaddeaddeaddeaddeaddeaddeaddeaddead0001</code>. Its value is returned by the <code>CALLER</code> and <code>ORIGIN</code>
opcodes during execution of the L1 attributes deposited transaction.</p>
<h3 id="l1-attributes-predeployed-contract"><a class="header" href="#l1-attributes-predeployed-contract">L1 Attributes Predeployed Contract</a></h3>
<p>A predeployed contract on L2 at address <code>0x4200000000000000000000000000000000000015</code>, which holds
certain block variables from the corresponding L1 block in storage, so that they may be accessed
during the execution of the subsequent deposited transactions.</p>
<p>The predeploy stores the following values:</p>
<ul>
<li>L1 block attributes:
<ul>
<li><code>number</code> (<code>uint64</code>)</li>
<li><code>timestamp</code> (<code>uint64</code>)</li>
<li><code>basefee</code> (<code>uint256</code>)</li>
<li><code>hash</code> (<code>bytes32</code>)</li>
</ul>
</li>
<li><code>sequenceNumber</code> (<code>uint64</code>): This equals the L2 block number relative to the start of the epoch,
i.e. the L2 block distance to the L2 block height that the L1 attributes last changed,
and reset to 0 at the start of a new epoch.</li>
<li>System configurables tied to the L1 block, see <a href="protocol/system_config.html">System configuration specification</a>:
<ul>
<li><code>batcherHash</code> (<code>bytes32</code>): A versioned commitment to the batch-submitter(s) currently operating.</li>
<li><code>overhead</code> (<code>uint256</code>): The L1 fee overhead to apply to L1 cost computation of transactions in this L2 block.
The <code>overhead</code> value is dropped as it is no longer used in the
<a href="protocol/exec-engine.html#ecotone-l1-cost-fee-changes-eip-4844-da">Ecotone L1 fee formula</a>.</li>
<li><code>scalar</code> (<code>uint256</code>): The L1 fee scalar to apply to L1 cost computation of transactions in this L2 block.</li>
</ul>
</li>
<li>With the Ecotone upgrade, the predeploy additionally stores:
<ul>
<li><code>blobBaseFee</code> (<code>uint256</code>)</li>
<li><code>baseFeeScalar</code> (<code>uint32</code>): system configurable to scale the <code>basefee</code> in the Ecotone l1 cost computation</li>
<li><code>blobBasefeeScalar</code> (<code>uint32</code>): system configurable to scale the <code>blobBaseFee</code> in the Ecotone l1 cost computation</li>
</ul>
</li>
</ul>
<p>The <code>overhead</code> and <code>scalar</code> values can continue to be accessed after the Ecotone activation block,
but no longer have any effect on system operation.</p>
<p>The contract implements an authorization scheme, such that it only accepts state-changing calls from
the <a href="protocol/deposits.html#l1-attributes-depositor-account">depositor account</a>.</p>
<p>The contract has the following solidity interface, and can be interacted with according to the
<a href="https://docs.soliditylang.org/en/v0.8.10/abi-spec.html">contract ABI specification</a>.</p>
<h4 id="l1-attributes-predeployed-contract-reference-implementation"><a class="header" href="#l1-attributes-predeployed-contract-reference-implementation">L1 Attributes Predeployed Contract: Reference Implementation</a></h4>
<p>A reference implementation of the L1 Attributes predeploy contract can be found in <a href="https://github.com/ethereum-optimism/optimism/blob/d48b45954c381f75a13e61312da68d84e9b41418/packages/contracts-bedrock/src/L2/L1Block.sol">L1Block.sol</a>.</p>
<p>After running <code>pnpm build</code> in the <code>packages/contracts-bedrock</code> directory, the bytecode to add to
the genesis file will be located in the <code>deployedBytecode</code> field of the build artifacts file at
<code>/packages/contracts-bedrock/forge-artifacts/L1Block.sol/L1Block.json</code>.</p>
<h4 id="ecotone-l1block-upgrade"><a class="header" href="#ecotone-l1block-upgrade">Ecotone L1Block upgrade</a></h4>
<p>The L1 Attributes Predeployed contract, <code>L1Block.sol</code>, is upgraded as part of the Ecotone upgrade.
The version is incremented to <code>1.2.0</code>, one new storage slot is introduced, and one existing slot
begins to store additional data:</p>
<ul>
<li><code>blobBaseFee</code> (<code>uint256</code>): The L1 blob base fee.</li>
<li><code>blobBaseFeeScalar</code> (<code>uint32</code>): The scalar value applied to the L1 blob base fee portion of the L1 cost.</li>
<li><code>baseFeeScalar</code> (<code>uint32</code>): The scalar value applied to the L1 base fee portion of the L1 cost.</li>
</ul>
<p>The function called by the L1 attributes transaction depends on the network upgrade:</p>
<ul>
<li>Before the Ecotone activation:
<ul>
<li><code>setL1BlockValues</code> is called, following the pre-Ecotone L1 attributes rules.</li>
</ul>
</li>
<li>At the Ecotone activation block:
<ul>
<li><code>setL1BlockValues</code> function MUST be called, except if activated at genesis.
The contract is upgraded later in this block, to support <code>setL1BlockValuesEcotone</code>.</li>
</ul>
</li>
<li>After the Ecotone activation:
<ul>
<li><code>setL1BlockValues</code> function is deprecated and MUST never be called.</li>
<li><code>setL1BlockValuesEcotone</code> MUST be called with the new Ecotone attributes.</li>
</ul>
</li>
</ul>
<p><code>setL1BlockValuesEcotone</code> uses a tightly packed encoding for its parameters, which is described in
<a href="protocol/deposits.html#l1-attributes-deposited-transaction-calldata">L1 Attributes Deposited Transaction Calldata</a>.</p>
<h2 id="user-deposited-transactions"><a class="header" href="#user-deposited-transactions">User-Deposited Transactions</a></h2>
<p><a href="protocol/../glossary.html#user-deposited-transaction">User-deposited transactions</a> are <a href="protocol/deposits.html#the-deposited-transaction-type">deposited transactions</a>
generated by the <a href="protocol/../glossary.html#L2-chain-derivation">L2 Chain Derivation</a> process. The content of each user-deposited
transaction are determined by the corresponding <code>TransactionDeposited</code> event emitted by the
<a href="protocol/deposits.html#deposit-contract">deposit contract</a> on L1.</p>
<ol>
<li><code>from</code> is unchanged from the emitted value (though it may
have been transformed to an alias in <code>OptimismPortal</code>, the deposit feed contract).</li>
<li><code>to</code> is any 20-byte address (including the zero address)
<ul>
<li>In case of a contract creation (cf. <code>isCreation</code>), this address is set to <code>null</code>.</li>
</ul>
</li>
<li><code>mint</code> is set to the emitted value.</li>
<li><code>value</code> is set to the emitted value.</li>
<li><code>gaslimit</code> is unchanged from the emitted value. It must be at least 21000.</li>
<li><code>isCreation</code> is set to <code>true</code> if the transaction is a contract creation, <code>false</code> otherwise.</li>
<li><code>data</code> is unchanged from the emitted value. Depending on the value of <code>isCreation</code> it is handled
as either calldata or contract initialization code.</li>
<li><code>isSystemTx</code> is set by the rollup node for certain transactions that have unmetered execution.
It is <code>false</code> for user deposited transactions</li>
</ol>
<h3 id="deposit-contract"><a class="header" href="#deposit-contract">Deposit Contract</a></h3>
<p>The deposit contract is deployed to L1. Deposited transactions are derived from the values in
the <code>TransactionDeposited</code> event(s) emitted by the deposit contract.</p>
<p>The deposit contract is responsible for maintaining the <a href="protocol/guaranteed-gas-market.html">guaranteed gas market</a>,
charging deposits for gas to be used on L2, and ensuring that the total amount of guaranteed
gas in a single L1 block does not exceed the L2 block gas limit.</p>
<p>The deposit contract handles two special cases:</p>
<ol>
<li>A contract creation deposit, which is indicated by setting the <code>isCreation</code> flag to <code>true</code>.
In the event that the <code>to</code> address is non-zero, the contract will revert.</li>
<li>A call from a contract account, in which case the <code>from</code> value is transformed to its L2
<a href="protocol/deposits.html#address-aliasing">alias</a>.</li>
</ol>
<h4 id="address-aliasing"><a class="header" href="#address-aliasing">Address Aliasing</a></h4>
<p>If the caller is a contract, the address will be transformed by adding
<code>0x1111000000000000000000000000000000001111</code> to it. The math is <code>unchecked</code> and done on a
Solidity <code>uint160</code> so the value will overflow. This prevents attacks in which a
contract on L1 has the same address as a contract on L2 but doesn't have the same code. We can safely ignore this
for EOAs because they're guaranteed to have the same &quot;code&quot; (i.e. no code at all). This also makes
it possible for users to interact with contracts on L2 even when the Sequencer is down.</p>
<h4 id="deposit-contract-implementation-optimism-portal"><a class="header" href="#deposit-contract-implementation-optimism-portal">Deposit Contract Implementation: Optimism Portal</a></h4>
<p>A reference implementation of the deposit contract can be found in <a href="https://github.com/ethereum-optimism/optimism/blob/d48b45954c381f75a13e61312da68d84e9b41418/packages/contracts-bedrock/src/L1/OptimismPortal.sol">OptimismPortal.sol</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="withdrawals"><a class="header" href="#withdrawals">Withdrawals</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/withdrawals.html#overview">Overview</a></li>
<li><a href="protocol/withdrawals.html#withdrawal-flow">Withdrawal Flow</a>
<ul>
<li><a href="protocol/withdrawals.html#on-l2">On L2</a></li>
<li><a href="protocol/withdrawals.html#on-l1">On L1</a></li>
</ul>
</li>
<li><a href="protocol/withdrawals.html#the-l2tol1messagepasser-contract">The L2ToL1MessagePasser Contract</a>
<ul>
<li><a href="protocol/withdrawals.html#addresses-are-not-aliased-on-withdrawals">Addresses are not Aliased on Withdrawals</a></li>
</ul>
</li>
<li><a href="protocol/withdrawals.html#the-optimism-portal-contract">The Optimism Portal Contract</a></li>
<li><a href="protocol/withdrawals.html#withdrawal-verification-and-finalization">Withdrawal Verification and Finalization</a></li>
<li><a href="protocol/withdrawals.html#security-considerations">Security Considerations</a>
<ul>
<li><a href="protocol/withdrawals.html#key-properties-of-withdrawal-verification">Key Properties of Withdrawal Verification</a></li>
<li><a href="protocol/withdrawals.html#handling-successfully-verified-messages-that-fail-when-relayed">Handling Successfully Verified Messages That Fail When Relayed</a></li>
<li><a href="protocol/withdrawals.html#optimismportal-can-send-arbitrary-messages-on-l1">OptimismPortal can send arbitrary messages on L1</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p><a href="protocol/../glossary.html#withdrawal">Withdrawals</a> are cross domain transactions which are initiated on L2, and finalized by a transaction
executed on L1. Notably, withdrawals may be used by an L2 account to call an L1 contract, or to transfer ETH from
an L2 account to an L1 account.</p>
<p><strong>Vocabulary note</strong>: <em>withdrawal</em> can refer to the transaction at various stages of the process, but we introduce
more specific terms to differentiate:</p>
<ul>
<li>A <em>withdrawal initiating transaction</em> refers specifically to a transaction on L2 sent to the Withdrawals predeploy.</li>
<li>A <em>withdrawal proving transaction</em> refers specifically to an L1 transaction
which proves the withdrawal is correct (that it has been included in a merkle
tree whose root is available on L1).</li>
<li>A <em>withdrawal finalizing transaction</em> refers specifically to an L1 transaction which finalizes and relays the
withdrawal.</li>
</ul>
<p>Withdrawals are initiated on L2 via a call to the Message Passer predeploy contract, which records the important
properties of the message in its storage.
Withdrawals are proven on L1 via a call to the <code>OptimismPortal</code>, which proves the inclusion of this withdrawal message.
Withdrawals are finalized on L1 via a call to the <code>OptimismPortal</code> contract,
which verifies that the fault challenge period has passed since the withdrawal message has been proved.</p>
<p>In this way, withdrawals are different from <a href="protocol/../glossary.html#deposits">deposits</a> which make use of a special transaction type in the
<a href="protocol/../glossary.html#execution-engine">execution engine</a> client. Rather, withdrawals transaction must use smart contracts on L1 for
finalization.</p>
<h2 id="withdrawal-flow"><a class="header" href="#withdrawal-flow">Withdrawal Flow</a></h2>
<p>We first describe the end to end flow of initiating and finalizing a withdrawal:</p>
<h3 id="on-l2"><a class="header" href="#on-l2">On L2</a></h3>
<p>An L2 account sends a withdrawal message (and possibly also ETH) to the <code>L2ToL1MessagePasser</code> predeploy contract.
This is a very simple contract that stores the hash of the withdrawal data.</p>
<h3 id="on-l1"><a class="header" href="#on-l1">On L1</a></h3>
<ol>
<li>A <a href="protocol/../glossary.html#withdrawals">relayer</a> submits a withdrawal proving transaction with the required inputs
to the <code>OptimismPortal</code> contract.
The relayer is not necessarily the same entity which initiated the withdrawal on L2.
These inputs include the withdrawal transaction data, inclusion proofs, and a block number. The block number
must be one for which an L2 output root exists, which commits to the withdrawal as registered on L2.</li>
<li>The <code>OptimismPortal</code> contract retrieves the output root for the given block number from the <code>L2OutputOracle</code>'s
<code>getL2Output()</code> function, and performs the remainder of the verification process internally.</li>
<li>If proof verification fails, the call reverts. Otherwise the hash is recorded to prevent it from being re-proven.
Note that the withdrawal can be proven more than once if the corresponding output root changes.</li>
<li>After the withdrawal is proven, it enters a 7 day challenge period, allowing time for other network participants
to challenge the integrity of the corresponding output root.</li>
<li>Once the challenge period has passed, a relayer submits a withdrawal finalizing transaction to the
<code>OptimismPortal</code> contract.
The relayer doesn't need to be the same entity that initiated the withdrawal on L2.</li>
<li>The <code>OptimismPortal</code> contract receives the withdrawal transaction data and verifies that the withdrawal has
both been proven and passed the challenge period.</li>
<li>If the requirements are not met, the call reverts. Otherwise the call is forwarded, and the hash is recorded to
prevent it from being replayed.</li>
</ol>
<h2 id="the-l2tol1messagepasser-contract"><a class="header" href="#the-l2tol1messagepasser-contract">The L2ToL1MessagePasser Contract</a></h2>
<p>A withdrawal is initiated by calling the L2ToL1MessagePasser contract's <code>initiateWithdrawal</code> function.
The L2ToL1MessagePasser is a simple predeploy contract at <code>0x4200000000000000000000000000000000000016</code>
which stores messages to be withdrawn.</p>
<pre><code class="language-js">interface L2ToL1MessagePasser {
    event MessagePassed(
        uint256 indexed nonce, // this is a global nonce value for all withdrawal messages
        address indexed sender,
        address indexed target,
        uint256 value,
        uint256 gasLimit,
        bytes data,
        bytes32 withdrawalHash
    );

    event WithdrawerBalanceBurnt(uint256 indexed amount);

    function burn() external;

    function initiateWithdrawal(address _target, uint256 _gasLimit, bytes memory _data) payable external;

    function messageNonce() public view returns (uint256);

    function sentMessages(bytes32) view external returns (bool);
}

</code></pre>
<p>The <code>MessagePassed</code> event includes all of the data that is hashed and
stored in the <code>sentMessages</code> mapping, as well as the hash itself.</p>
<h3 id="addresses-are-not-aliased-on-withdrawals"><a class="header" href="#addresses-are-not-aliased-on-withdrawals">Addresses are not Aliased on Withdrawals</a></h3>
<p>When a contract makes a deposit, the sender's address is <a href="protocol/deposits.html#address-aliasing">aliased</a>. The same is not true
of withdrawals, which do not modify the sender's address. The difference is that:</p>
<ul>
<li>on L2, the deposit sender's address is returned by the <code>CALLER</code> opcode, meaning a contract cannot easily tell if the
call originated on L1 or L2, whereas</li>
<li>on L1, the withdrawal sender's address is accessed by calling the <code>l2Sender()</code> function on the <code>OptimismPortal</code>
contract.</li>
</ul>
<p>Calling <code>l2Sender()</code> removes any ambiguity about which domain the call originated from. Still, developers will need to
recognize that having the same address does not imply that a contract on L2 will behave the same as a contract on L1.</p>
<h2 id="the-optimism-portal-contract"><a class="header" href="#the-optimism-portal-contract">The Optimism Portal Contract</a></h2>
<p>The Optimism Portal serves as both the entry and exit point to the Optimism L2. It is a contract which inherits from
the <a href="protocol/deposits.html#deposit-contract">OptimismPortal</a> contract, and in addition provides the following interface for
withdrawals:</p>
<ul>
<li><a href="https://github.com/ethereum-optimism/optimism/blob/08daf8dbd38c9ffdbd18fc9a211c227606cdb0ad/packages/contracts-bedrock/src/libraries/Types.sol#L62-L69"><code>WithdrawalTransaction</code> type</a></li>
<li><a href="https://github.com/ethereum-optimism/optimism/blob/08daf8dbd38c9ffdbd18fc9a211c227606cdb0ad/packages/contracts-bedrock/src/libraries/Types.sol#L25-L30"><code>OutputRootProof</code> type</a></li>
</ul>
<pre><code class="language-js">interface OptimismPortal {

    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);


    function l2Sender() returns(address) external;

    function proveWithdrawalTransaction(
        Types.WithdrawalTransaction memory _tx,
        uint256 _l2OutputIndex,
        Types.OutputRootProof calldata _outputRootProof,
        bytes[] calldata _withdrawalProof
    ) external;

    function finalizeWithdrawalTransaction(
        Types.WithdrawalTransaction memory _tx
    ) external;
}
</code></pre>
<h2 id="withdrawal-verification-and-finalization"><a class="header" href="#withdrawal-verification-and-finalization">Withdrawal Verification and Finalization</a></h2>
<p>The following inputs are required to prove and finalize a withdrawal:</p>
<ul>
<li>Withdrawal transaction data:
<ul>
<li><code>nonce</code>: Nonce for the provided message.</li>
<li><code>sender</code>: Message sender address on L2.</li>
<li><code>target</code>: Target address on L1.</li>
<li><code>value</code>: ETH to send to the target.</li>
<li><code>data</code>: Data to send to the target.</li>
<li><code>gasLimit</code>: Gas to be forwarded to the target.</li>
</ul>
</li>
<li>Proof and verification data:
<ul>
<li><code>l2OutputIndex</code>: The index in the L2 outputs where the applicable output root may be found.</li>
<li><code>outputRootProof</code>: Four <code>bytes32</code> values which are used to derive the output root.</li>
<li><code>withdrawalProof</code>: An inclusion proof for the given withdrawal in the L2ToL1MessagePasser contract.</li>
</ul>
</li>
</ul>
<p>These inputs must satisfy the following conditions:</p>
<ol>
<li>The <code>l2OutputIndex</code> must be the index in the L2 outputs that contains the applicable output root.</li>
<li><code>L2OutputOracle.getL2Output(l2OutputIndex)</code> returns a non-zero <code>OutputProposal</code>.</li>
<li>The keccak256 hash of the <code>outputRootProof</code> values is equal to the <code>outputRoot</code>.</li>
<li>The <code>withdrawalProof</code> is a valid inclusion proof demonstrating that a hash of the Withdrawal transaction data
is contained in the storage of the L2ToL1MessagePasser contract on L2.</li>
</ol>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="key-properties-of-withdrawal-verification"><a class="header" href="#key-properties-of-withdrawal-verification">Key Properties of Withdrawal Verification</a></h3>
<ol>
<li>
<p>It should not be possible to 'double spend' a withdrawal, ie. to relay a withdrawal on L1 which does not
correspond to a message initiated on L2. For reference, see <a href="https://gerhard-wagner.medium.com/double-spending-bug-in-polygons-plasma-bridge-2e0954ccadf1">this writeup</a> of a vulnerability
of this type found on Polygon.</p>
</li>
<li>
<p>For each withdrawal initiated on L2 (i.e. with a unique <code>messageNonce()</code>), the following properties must hold:</p>
<ol>
<li>It should only be possible to prove the withdrawal once, unless the outputRoot for the withdrawal
has changed.</li>
<li>It should only be possible to finalize the withdrawal once.</li>
<li>It should not be possible to relay the message with any of its fields modified, ie.
<ol>
<li>Modifying the <code>sender</code> field would enable a 'spoofing' attack.</li>
<li>Modifying the <code>target</code>, <code>data</code>, or <code>value</code> fields would enable an attacker to dangerously change the
intended outcome of the withdrawal.</li>
<li>Modifying the <code>gasLimit</code> could make the cost of relaying too high, or allow the relayer to cause execution
to fail (out of gas) in the <code>target</code>.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="handling-successfully-verified-messages-that-fail-when-relayed"><a class="header" href="#handling-successfully-verified-messages-that-fail-when-relayed">Handling Successfully Verified Messages That Fail When Relayed</a></h3>
<p>If the execution of the relayed call fails in the <code>target</code> contract, it is unfortunately not possible to determine
whether or not it was 'supposed' to fail, and whether or not it should be 'replayable'. For this reason, and to
minimize complexity, we have not provided any replay functionality, this may be implemented in external utility
contracts if desired.</p>
<h3 id="optimismportal-can-send-arbitrary-messages-on-l1"><a class="header" href="#optimismportal-can-send-arbitrary-messages-on-l1">OptimismPortal can send arbitrary messages on L1</a></h3>
<p>The <code>L2ToL1MessagePasser</code> contract's <code>initiateWithdrawal</code> function accepts a <code>_target</code> address and <code>_data</code> bytes,
which is passed to a <code>CALL</code> opcode on L1 when <code>finalizeWithdrawalTransaction</code> is called after the challenge
period. This means that, by design, the <code>OptimismPortal</code> contract can be used to send arbitrary transactions on
the L1, with the <code>OptimismPortal</code> as the <code>msg.sender</code>.</p>
<p>This means users of the <code>OptimismPortal</code> contract should be careful what permissions they grant to the portal.
For example, any ERC20 tokens mistakenly sent to the <code>OptimismPortal</code> contract are essentially lost, as they can
be claimed by anybody that pre-approves transfers of this token out of the portal, using the L2 to initiate the
approval and the L1 to prove and finalize the approval (after the challenge period).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="guaranteed-gas-fee-market"><a class="header" href="#guaranteed-gas-fee-market">Guaranteed Gas Fee Market</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/guaranteed-gas-market.html#overview">Overview</a></li>
<li><a href="protocol/guaranteed-gas-market.html#gas-stipend">Gas Stipend</a></li>
<li><a href="protocol/guaranteed-gas-market.html#default-values">Default Values</a></li>
<li><a href="protocol/guaranteed-gas-market.html#limiting-guaranteed-gas">Limiting Guaranteed Gas</a></li>
<li><a href="protocol/guaranteed-gas-market.html#rationale-for-burning-l1-gas">Rationale for burning L1 Gas</a></li>
<li><a href="protocol/guaranteed-gas-market.html#on-preventing-griefing-attacks">On Preventing Griefing Attacks</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p><a href="protocol/../glossary.html#deposited-transaction">Deposited transactions</a> are transactions on L2 that are
initiated on L1. The gas that they use on L2 is bought on L1 via a gas burn (or a direct payment
in the future). We maintain a fee market and hard cap on the amount of gas provided to all deposits
in a single L1 block.</p>
<p>The gas provided to deposited transactions is sometimes called &quot;guaranteed gas&quot;. The gas provided to
deposited transactions is unique in the regard that it is not refundable. It cannot be refunded as
it is sometimes paid for with a gas burn and there may not be any ETH left to refund.</p>
<p>The <strong>guaranteed gas</strong> is composed of a gas stipend, and of any guaranteed gas the user would like
to purchase (on L1) on top of that.</p>
<p>Guaranteed gas on L2 is bought in the following manner. An L2 gas price is calculated via an
EIP-1559-style algorithm. The total amount of ETH required to buy that gas is then calculated as
(<code>guaranteed gas * L2 deposit base fee</code>). The contract then accepts that amount of ETH (in a future
upgrade) or (only method right now), burns an amount of L1 gas that corresponds to the L2 cost (<code>L2 cost / L1 base fee</code>). The L2 gas price for guaranteed gas is not synchronized with the base fee on
L2 and will likely be different.</p>
<h2 id="gas-stipend"><a class="header" href="#gas-stipend">Gas Stipend</a></h2>
<p>To offset the gas spent on the deposit event, we credit <code>gas spent * L1 base fee</code> ETH to the cost
of the L2 gas, where <code>gas spent</code> is the amount of L1 gas spent processing the deposit. If the ETH
value of this credit is greater than the ETH value of the requested guaranteed gas (<code>requested guaranteed gas * L2 gas price</code>), no L1 gas is burnt.</p>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Value</th></tr></thead><tbody>
<tr><td><code>MAX_RESOURCE_LIMIT</code></td><td>20,000,000</td></tr>
<tr><td><code>ELASTICITY_MULTIPLIER</code></td><td>10</td></tr>
<tr><td><code>BASE_FEE_MAX_CHANGE_DENOMINATOR</code></td><td>8</td></tr>
<tr><td><code>MINIMUM_BASE_FEE</code></td><td>1 gwei</td></tr>
<tr><td><code>MAXIMUM_BASE_FEE</code></td><td>type(uint128).max</td></tr>
<tr><td><code>SYSTEM_TX_MAX_GAS</code></td><td>1,000,000</td></tr>
<tr><td><code>TARGET_RESOURCE_LIMIT</code></td><td><code>MAX_RESOURCE_LIMIT</code> / <code>ELASTICITY_MULTIPLIER</code></td></tr>
</tbody></table>
</div>
<h2 id="limiting-guaranteed-gas"><a class="header" href="#limiting-guaranteed-gas">Limiting Guaranteed Gas</a></h2>
<p>The total amount of guaranteed gas that can be bought in a single L1 block must be limited to
prevent a denial of service attack against L2 as well as ensure the total amount of guaranteed gas
stays below the L2 block gas limit.</p>
<p>We set a guaranteed gas limit of <code>MAX_RESOURCE_LIMIT</code> gas per L1 block and a target of
<code>MAX_RESOURCE_LIMIT</code> / <code>ELASTICITY_MULTIPLIER</code> gas per L1 block. These numbers enabled
occasional large transactions while staying within our target and maximum gas usage on L2.</p>
<p>Because the amount of guaranteed L2 gas that can be purchased in a single block is now limited,
we implement an EIP-1559-style fee market to reduce congestion on deposits. By setting the limit
at a multiple of the target, we enable deposits to temporarily use more L2 gas at a greater cost.</p>
<pre><code class="language-python"># Pseudocode to update the L2 deposit base fee and cap the amount of guaranteed gas
# bought in a block. Calling code must handle the gas burn and validity checks on
# the ability of the account to afford this gas.

# prev_base fee is a u128, prev_bought_gas and prev_num are u64s
prev_base_fee, prev_bought_gas, prev_num = &lt;values from previous update&gt;
now_num = block.number

# Clamp the full base fee to a specific range. The minimum value in the range should be around 100-1000
# to enable faster responses in the base fee. This replaces the `max` mechanism in the ethereum 1559
# implementation (it also serves to enable the base fee to increase if it is very small).
def clamp(v: i256, min: u128, max: u128) -&gt; u128:
    if v &lt; i256(min):
        return min
    elif v &gt; i256(max):
        return max
    else:
        return u128(v)

# If this is a new block, update the base fee and reset the total gas
# If not, just update the total gas
if prev_num == now_num:
    now_base_fee = prev_base_fee
    now_bought_gas = prev_bought_gas + requested_gas
elif prev_num != now_num:
    # Width extension and conversion to signed integer math
    gas_used_delta = int128(prev_bought_gas) - int128(TARGET_RESOURCE_LIMIT)
    # Use truncating (round to 0) division - solidity's default.
    # Sign extend gas_used_delta &amp; prev_base_fee to 256 bits to avoid overflows here.
    base_fee_per_gas_delta = prev_base_fee * gas_used_delta / TARGET_RESOURCE_LIMIT / BASE_FEE_MAX_CHANGE_DENOMINATOR
    now_base_fee_wide = prev_base_fee + base_fee_per_gas_delta

    now_base_fee = clamp(now_base_fee_wide, min=MINIMUM_BASE_FEE, max=UINT_128_MAX_VALUE)
    now_bought_gas =  requested_gas

    # If we skipped multiple blocks between the previous block and now update the base fee again.
    # This is not exactly the same as iterating the above function, but quite close for reasonable
    # gas target values. It is also constant time wrt the number of missed blocks which is important
    # for keeping gas usage stable.
    if prev_num + 1 &lt; now_num:
        n = now_num - prev_num - 1
        # Apply 7/8 reduction to prev_base_fee for the n empty blocks in a row.
        now_base_fee_wide = now_base_fee * pow(1-(1/BASE_FEE_MAX_CHANGE_DENOMINATOR), n)
        now_base_fee = clamp(now_base_fee_wide, min=MINIMUM_BASE_FEE, max=type(uint128).max)

require(now_bought_gas &lt; MAX_RESOURCE_LIMIT)

store_values(now_base_fee, now_bought_gas, now_num)
</code></pre>
<h2 id="rationale-for-burning-l1-gas"><a class="header" href="#rationale-for-burning-l1-gas">Rationale for burning L1 Gas</a></h2>
<p>There must be a sybil resistance mechanism for usage of the network. If it is very cheap to get
guaranteed gas on L2, then it would be possible to spam the network. Burning a dynamic amount
of gas on L1 acts as a sybil resistance mechanism as it becomes more expensive with more demand.</p>
<p>If we collect ETH directly to pay for L2 gas, every (indirect) caller of the deposit function will need
to be marked with the payable selector. This won't be possible for many existing projects. Unfortunately
this is quite wasteful. As such, we will provide two options to buy L2 gas:</p>
<ol>
<li>Burn L1 Gas</li>
<li>Send ETH to the Optimism Portal (Not yet supported)</li>
</ol>
<p>The payable version (Option 2) will likely have discount applied to it (or conversely, #1 has a
premium applied to it).</p>
<p>For the initial release of bedrock, only #1 is supported.</p>
<h2 id="on-preventing-griefing-attacks"><a class="header" href="#on-preventing-griefing-attacks">On Preventing Griefing Attacks</a></h2>
<p>The cost of purchasing all of the deposit gas in every block must be expensive
enough to prevent attackers from griefing all deposits to the network.
An attacker would observe a deposit in the mempool and frontrun it with a deposit
that purchases enough gas such that the other deposit reverts.
The smaller the max resource limit is, the easier this attack is to pull off.
This attack is mitigated by having a large resource limit as well as a large
elasticity multiplier. This means that the target resource usage is kept small,
giving a lot of room for the deposit base fee to rise when the max resource limit
is being purchased.</p>
<p>This attack should be too expensive to pull off in practice, but if an extremely
wealthy adversary does decide to grief network deposits for an extended period
of time, efforts will be placed to ensure that deposits are able to be processed
on the network.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="l2-output-root-proposals-specification"><a class="header" href="#l2-output-root-proposals-specification">L2 Output Root Proposals Specification</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/proposals.html#overview">Overview</a></li>
<li><a href="protocol/proposals.html#proposing-l2-output-commitments">Proposing L2 Output Commitments</a>
<ul>
<li><a href="protocol/proposals.html#l2outputoracle-v100">L2OutputOracle v1.0.0</a></li>
</ul>
</li>
<li><a href="protocol/proposals.html#l2-output-commitment-construction">L2 Output Commitment Construction</a></li>
<li><a href="protocol/proposals.html#l2-output-oracle-smart-contract">L2 Output Oracle Smart Contract</a>
<ul>
<li><a href="protocol/proposals.html#configuration">Configuration</a></li>
</ul>
</li>
<li><a href="protocol/proposals.html#security-considerations">Security Considerations</a>
<ul>
<li><a href="protocol/proposals.html#l1-reorgs">L1 Reorgs</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>After processing one or more blocks the outputs will need to be synchronized with the settlement layer (L1)
for trustless execution of L2-to-L1 messaging, such as withdrawals.
These output proposals act as the bridge's view into the L2 state.
Actors called &quot;Proposers&quot; submit the output roots to the settlement layer (L1) and can be contested with a fault proof,
with a bond at stake if the proof is wrong. The <a href="https://github.com/ethereum-optimism/optimism/tree/d48b45954c381f75a13e61312da68d84e9b41418/op-proposer">op-proposer</a> in one such implementation of a proposer.</p>
<p><em>Note</em>: Fault proofs on Optimism are not fully specified at this time. Although fault proof
construction and verification <a href="https://github.com/ethereum-optimism/cannon">is implemented in Cannon</a>,
the fault proof game specification and integration of a output-root challenger into the <a href="protocol/../glossary.html#rollup-node">rollup-node</a>
are part of later specification milestones.</p>
<h2 id="proposing-l2-output-commitments"><a class="header" href="#proposing-l2-output-commitments">Proposing L2 Output Commitments</a></h2>
<p>The proposer's role is to construct and submit output roots, which are commitments to the L2's state,
to the <code>L2OutputOracle</code> contract on L1 (the settlement layer). To do this, the proposer periodically
queries the <a href="protocol/rollup-node.html">rollup node</a> for the latest output root derived from the latest
<a href="protocol/rollup-node.html#finalization-guarantees">finalized</a> L1 block. It then takes the output root and
submits it to the <code>L2OutputOracle</code> contract on the settlement layer (L1).</p>
<h3 id="l2outputoracle-v100"><a class="header" href="#l2outputoracle-v100">L2OutputOracle v1.0.0</a></h3>
<p>The submission of output proposals is permissioned to a single account. It is expected that this
account will continue to submit output proposals over time to ensure that user withdrawals do not halt.</p>
<p>The <a href="https://github.com/ethereum-optimism/optimism/tree/d48b45954c381f75a13e61312da68d84e9b41418/op-proposer">L2 output proposer</a> is expected to submit output roots on a deterministic
interval based on the configured <code>SUBMISSION_INTERVAL</code> in the <code>L2OutputOracle</code>. The larger
the <code>SUBMISSION_INTERVAL</code>, the less often L1 transactions need to be sent to the <code>L2OutputOracle</code>
contract, but L2 users will need to wait a bit longer for an output root to be included in L1 (the settlement layer)
that includes their intention to withdraw from the system.</p>
<p>The honest <code>op-proposer</code> algorithm assumes a connection to the <code>L2OutputOracle</code> contract to know
the L2 block number that corresponds to the next output proposal that must be submitted. It also
assumes a connection to an <code>op-node</code> to be able to query the <code>optimism_syncStatus</code> RPC endpoint.</p>
<pre><code class="language-python">import time

while True:
    next_checkpoint_block = L2OutputOracle.nextBlockNumber()
    rollup_status = op_node_client.sync_status()
    if rollup_status.finalized_l2.number &gt;= next_checkpoint_block:
        output = op_node_client.output_at_block(next_checkpoint_block)
        tx = send_transaction(output)
    time.sleep(poll_interval)
</code></pre>
<p>A <code>CHALLENGER</code> account can delete multiple output roots by calling the <code>deleteL2Outputs()</code> function
and specifying the index of the first output to delete, this will also delete all subsequent outputs.</p>
<h2 id="l2-output-commitment-construction"><a class="header" href="#l2-output-commitment-construction">L2 Output Commitment Construction</a></h2>
<p>The <code>output_root</code> is a 32 byte string, which is derived based on the a versioned scheme:</p>
<pre><code class="language-pseudocode">output_root = keccak256(version_byte || payload)
</code></pre>
<p>where:</p>
<ol>
<li>
<p><code>version_byte</code> (<code>bytes32</code>) a simple version string which increments anytime the construction of the output root
is changed.</p>
</li>
<li>
<p><code>payload</code> (<code>bytes</code>) is a byte string of arbitrary length.</p>
</li>
</ol>
<p>In the initial version of the output commitment construction, the version is <code>bytes32(0)</code>, and the payload is defined
as:</p>
<pre><code class="language-pseudocode">payload = state_root || withdrawal_storage_root || latest_block_hash
</code></pre>
<p>where:</p>
<ol>
<li>
<p>The <code>latest_block_hash</code> (<code>bytes32</code>) is the block hash for the latest L2 block.</p>
</li>
<li>
<p>The <code>state_root</code> (<code>bytes32</code>) is the Merkle-Patricia-Trie (<a href="protocol/../glossary.html#merkle-patricia-trie">MPT</a>) root of all execution-layer accounts.
This value is frequently used and thus elevated closer to the L2 output root, which removes the need to prove its
inclusion in the pre-image of the <code>latest_block_hash</code>. This reduces the merkle proof depth and cost of accessing the
L2 state root on L1.</p>
</li>
<li>
<p>The <code>withdrawal_storage_root</code> (<code>bytes32</code>) elevates the Merkle-Patricia-Trie (<a href="protocol/../glossary.html#merkle-patricia-trie">MPT</a>) root of the <a href="protocol/withdrawals.html#the-l2tol1messagepasser-contract">Message
Passer contract</a> storage. Instead of making an MPT proof for a
withdrawal against the state root (proving first the storage root of the L2toL1MessagePasser against the state root,
then the withdrawal against that storage root), we can prove against the L2toL1MessagePasser's storage root directly,
thus reducing the verification cost of withdrawals on L1.</p>
</li>
</ol>
<h2 id="l2-output-oracle-smart-contract"><a class="header" href="#l2-output-oracle-smart-contract">L2 Output Oracle Smart Contract</a></h2>
<p>L2 blocks are produced at a constant rate of <code>L2_BLOCK_TIME</code> (2 seconds).
A new L2 output MUST be appended to the chain once per <code>SUBMISSION_INTERVAL</code> which is based on a number of blocks.
The exact number is yet to be determined, and will depend on the design of the fault proving game.</p>
<p>The L2 Output Oracle contract implements the following interface:</p>
<pre><code class="language-solidity">/**
 * @notice The number of the first L2 block recorded in this contract.
 */
uint256 public startingBlockNumber;

/**
 * @notice The timestamp of the first L2 block recorded in this contract.
 */
uint256 public startingTimestamp;

/**
 * @notice Accepts an L2 outputRoot and the timestamp of the corresponding L2 block. The
 * timestamp must be equal to the current value returned by `nextTimestamp()` in order to be
 * accepted.
 * This function may only be called by the Proposer.
 *
 * @param _l2Output      The L2 output of the checkpoint block.
 * @param _l2BlockNumber The L2 block number that resulted in _l2Output.
 * @param _l1Blockhash   A block hash which must be included in the current chain.
 * @param _l1BlockNumber The block number with the specified block hash.
*/
  function proposeL2Output(
      bytes32 _l2Output,
      uint256 _l2BlockNumber,
      bytes32 _l1Blockhash,
      uint256 _l1BlockNumber
  )

/**
 * @notice Deletes all output proposals after and including the proposal that corresponds to
 *         the given output index. Only the challenger address can delete outputs.
 *
 * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this
 *                       output will also be deleted.
 */
function deleteL2Outputs(uint256 _l2OutputIndex) external

/**
 * @notice Computes the block number of the next L2 block that needs to be checkpointed.
 */
function nextBlockNumber() public view returns (uint256)
</code></pre>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The <code>startingBlockNumber</code> must be at least the number of the first Bedrock block.
The <code>startingTimestamp</code> MUST be the same as the timestamp of the start block.</p>
<p>The first <code>outputRoot</code> proposed will thus be at height <code>startingBlockNumber + SUBMISSION_INTERVAL</code></p>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="l1-reorgs"><a class="header" href="#l1-reorgs">L1 Reorgs</a></h3>
<p>If the L1 has a reorg after an output has been generated and submitted, the L2 state and correct output may change
leading to a faulty proposal. This is mitigated against by allowing the proposer to submit an
L1 block number and hash to the Output Oracle when appending a new output; in the event of a reorg, the block hash
will not match that of the block with that number and the call will revert.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="l2-execution-engine"><a class="header" href="#l2-execution-engine">L2 Execution Engine</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/exec-engine.html#1559-parameters">1559 Parameters</a></li>
<li><a href="protocol/exec-engine.html#deposited-transaction-processing">Deposited transaction processing</a>
<ul>
<li><a href="protocol/exec-engine.html#deposited-transaction-boundaries">Deposited transaction boundaries</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#fees">Fees</a>
<ul>
<li><a href="protocol/exec-engine.html#fee-vaults">Fee Vaults</a></li>
<li><a href="protocol/exec-engine.html#priority-fees-sequencer-fee-vault">Priority fees (Sequencer Fee Vault)</a></li>
<li><a href="protocol/exec-engine.html#base-fees-base-fee-vault">Base fees (Base Fee Vault)</a></li>
<li><a href="protocol/exec-engine.html#l1-cost-fees-l1-fee-vault">L1-Cost fees (L1 Fee Vault)</a>
<ul>
<li><a href="protocol/exec-engine.html#pre-ecotone">Pre-Ecotone</a></li>
<li><a href="protocol/exec-engine.html#ecotone-l1-cost-fee-changes-eip-4844-da">Ecotone L1-Cost fee changes (EIP-4844 DA)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#engine-api">Engine API</a>
<ul>
<li><a href="protocol/exec-engine.html#engine_forkchoiceupdatedv2"><code>engine_forkchoiceUpdatedV2</code></a>
<ul>
<li><a href="protocol/exec-engine.html#extended-payloadattributesv2">Extended PayloadAttributesV2</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#engine_forkchoiceupdatedv3"><code>engine_forkchoiceUpdatedV3</code></a>
<ul>
<li><a href="protocol/exec-engine.html#extended-payloadattributesv3">Extended PayloadAttributesV3</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#engine_newpayloadv2"><code>engine_newPayloadV2</code></a></li>
<li><a href="protocol/exec-engine.html#engine_newpayloadv3"><code>engine_newPayloadV3</code></a></li>
<li><a href="protocol/exec-engine.html#engine_getpayloadv2"><code>engine_getPayloadV2</code></a></li>
<li><a href="protocol/exec-engine.html#engine_getpayloadv3"><code>engine_getPayloadV3</code></a>
<ul>
<li><a href="protocol/exec-engine.html#extended-response">Extended Response</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#engine_signalsuperchainv1"><code>engine_signalSuperchainV1</code></a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#networking">Networking</a></li>
<li><a href="protocol/exec-engine.html#sync">Sync</a>
<ul>
<li><a href="protocol/exec-engine.html#happy-path-sync">Happy-path sync</a></li>
<li><a href="protocol/exec-engine.html#worst-case-sync">Worst-case sync</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#ecotone-disable-blob-transactions">Ecotone: disable Blob-transactions</a></li>
<li><a href="protocol/exec-engine.html#ecotone-beacon-block-root">Ecotone: Beacon Block Root</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<p>This document outlines the modifications, configuration and usage of a L1 execution engine for L2.</p>
<h2 id="1559-parameters"><a class="header" href="#1559-parameters">1559 Parameters</a></h2>
<p>The execution engine must be able to take a per chain configuration which specifies the EIP-1559 Denominator
and EIP-1559 elasticity. After Canyon it should also take a new value <code>EIP1559DenominatorCanyon</code> and use that as
the denominator in the 1559 formula rather than the prior denominator.</p>
<p>The formula for EIP-1559 is not otherwise modified.</p>
<h2 id="deposited-transaction-processing"><a class="header" href="#deposited-transaction-processing">Deposited transaction processing</a></h2>
<p>The Engine interfaces abstract away transaction types with <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a>.</p>
<p>To support rollup functionality, processing of a new Deposit <a href="https://eips.ethereum.org/EIPS/eip-2718#transactions"><code>TransactionType</code></a>
is implemented by the engine, see the <a href="protocol/deposits.html">deposits specification</a>.</p>
<p>This type of transaction can mint L2 ETH, run EVM,
and introduce L1 information to enshrined contracts in the execution state.</p>
<h3 id="deposited-transaction-boundaries"><a class="header" href="#deposited-transaction-boundaries">Deposited transaction boundaries</a></h3>
<p>Transactions cannot be blindly trusted, trust is established through authentication.
Unlike other transaction types deposits are not authenticated by a signature:
the rollup node authenticates them, outside of the engine.</p>
<p>To process deposited transactions safely, the deposits MUST be authenticated first:</p>
<ul>
<li>Ingest directly through trusted Engine API</li>
<li>Part of sync towards a trusted block hash (trusted through previous Engine API instruction)</li>
</ul>
<p>Deposited transactions MUST never be consumed from the transaction pool.
<em>The transaction pool can be disabled in a deposits-only rollup</em></p>
<h2 id="fees"><a class="header" href="#fees">Fees</a></h2>
<p>Sequenced transactions (i.e. not applicable to deposits) are charged with 3 types of fees:
priority fees, base fees, and L1-cost fees.</p>
<h3 id="fee-vaults"><a class="header" href="#fee-vaults">Fee Vaults</a></h3>
<p>The three types of fees are collected in 3 distinct L2 fee-vault deployments for accounting purposes:
fee payments are not registered as internal EVM calls, and thus distinguished better this way.</p>
<p>These are hardcoded addresses, pointing at pre-deployed proxy contracts.
The proxies are backed by vault contract deployments, based on <code>FeeVault</code>, to route vault funds to L1 securely.</p>
<div class="table-wrapper"><table><thead><tr><th>Vault Name</th><th>Predeploy</th></tr></thead><tbody>
<tr><td>Sequencer Fee Vault</td><td><a href="protocol/predeploys.html#SequencerFeeVault"><code>SequencerFeeVault</code></a></td></tr>
<tr><td>Base Fee Vault</td><td><a href="protocol/predeploys.html#BaseFeeVault"><code>BaseFeeVault</code></a></td></tr>
<tr><td>L1 Fee Vault</td><td><a href="protocol/predeploys.html#L1FeeVault"><code>L1FeeVault</code></a></td></tr>
</tbody></table>
</div>
<h3 id="priority-fees-sequencer-fee-vault"><a class="header" href="#priority-fees-sequencer-fee-vault">Priority fees (Sequencer Fee Vault)</a></h3>
<p>Priority fees follow the <a href="https://eips.ethereum.org/EIPS/eip-1559">eip-1559</a> specification, and are collected by the fee-recipient of the L2 block.
The block fee-recipient (a.k.a. coinbase address) is set to the Sequencer Fee Vault address.</p>
<h3 id="base-fees-base-fee-vault"><a class="header" href="#base-fees-base-fee-vault">Base fees (Base Fee Vault)</a></h3>
<p>Base fees largely follow the <a href="https://eips.ethereum.org/EIPS/eip-1559">eip-1559</a> specification, with the exception that base fees are not burned,
but add up to the Base Fee Vault ETH account balance.</p>
<h3 id="l1-cost-fees-l1-fee-vault"><a class="header" href="#l1-cost-fees-l1-fee-vault">L1-Cost fees (L1 Fee Vault)</a></h3>
<p>The protocol funds batch-submission of sequenced L2 transactions by charging L2 users an additional fee
based on the estimated batch-submission costs.
This fee is charged from the L2 transaction-sender ETH balance, and collected into the L1 Fee Vault.</p>
<p>The exact L1 cost function to determine the L1-cost fee component of a L2 transaction depends on
the upgrades that are active.</p>
<h4 id="pre-ecotone"><a class="header" href="#pre-ecotone">Pre-Ecotone</a></h4>
<p>Before Ecotone activation, L1 cost is calculated as:
<code>(rollupDataGas + l1FeeOverhead) * l1BaseFee * l1FeeScalar / 1e6</code> (big-int computation, result
in Wei and <code>uint256</code> range)
Where:</p>
<ul>
<li><code>rollupDataGas</code> is determined from the <em>full</em> encoded transaction
(standard EIP-2718 transaction encoding, including signature fields):
<ul>
<li>Before Regolith fork: <code>rollupDataGas = zeroes * 4 + (ones + 68) * 16</code>
<ul>
<li>The addition of <code>68</code> non-zero bytes is a remnant of a pre-Bedrock L1-cost accounting function,
which accounted for the worst-case non-zero bytes addition to complement unsigned transactions, unlike Bedrock.</li>
</ul>
</li>
<li>With Regolith fork: <code>rollupDataGas = zeroes * 4 + ones * 16</code></li>
</ul>
</li>
<li><code>l1FeeOverhead</code> is the Gas Price Oracle <code>overhead</code> value.</li>
<li><code>l1FeeScalar</code> is the Gas Price Oracle <code>scalar</code> value.</li>
<li><code>l1BaseFee</code> is the L1 base fee of the latest L1 origin registered in the L2 chain.</li>
</ul>
<p>Note that the <code>rollupDataGas</code> uses the same byte cost accounting as defined in <a href="https://eips.ethereum.org/EIPS/eip-2028">eip-2028</a>,
except the full L2 transaction now counts towards the bytes charged in the L1 calldata.
This behavior matches pre-Bedrock L1-cost estimation of L2 transactions.</p>
<p>Compression, batching, and intrinsic gas costs of the batch transactions are accounted for by the protocol
with the Gas Price Oracle <code>overhead</code> and <code>scalar</code> parameters.</p>
<p>The Gas Price Oracle <code>l1FeeOverhead</code> and <code>l1FeeScalar</code>, as well as the <code>l1BaseFee</code> of the L1 origin,
can be accessed in two interchangeable ways:</p>
<ul>
<li>read from the deposited L1 attributes (<code>l1FeeOverhead</code>, <code>l1FeeScalar</code>, <code>basefee</code>) of the current L2 block</li>
<li>read from the L1 Block Info contract (<code>0x4200000000000000000000000000000000000015</code>)
<ul>
<li>using the respective solidity <code>uint256</code>-getter functions (<code>l1FeeOverhead</code>, <code>l1FeeScalar</code>, <code>basefee</code>)</li>
<li>using direct storage-reads:
<ul>
<li>L1 basefee as big-endian <code>uint256</code> in slot <code>1</code></li>
<li>Overhead as big-endian <code>uint256</code> in slot <code>5</code></li>
<li>Scalar as big-endian <code>uint256</code> in slot <code>6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ecotone-l1-cost-fee-changes-eip-4844-da"><a class="header" href="#ecotone-l1-cost-fee-changes-eip-4844-da">Ecotone L1-Cost fee changes (EIP-4844 DA)</a></h4>
<p>Ecotone allows posting batches via Blobs which are subject to a new fee market. To account for this feature,
L1 cost is computed as:</p>
<p><code>(zeroes*4 + ones*16) * (16*l1BaseFee*l1BaseFeeScalar + l1BlobBaseFee*l1BlobBaseFeeScalar) / 16e6</code></p>
<p>Where:</p>
<ul>
<li>
<p>the computation is an unlimited precision integer computation, with the result in Wei and having
<code>uint256</code> range.</p>
</li>
<li>
<p>zeoroes and ones are the count of zero and non-zero bytes respectively in the <em>full</em> encoded
signed transaction.</p>
</li>
<li>
<p><code>l1BaseFee</code> is the L1 base fee of the latest L1 origin registered in the L2 chain.</p>
</li>
<li>
<p><code>l1BlobBaseFee</code> is the blob gas price, computed as described in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#gas-accounting">EIP-4844</a> from the
header of the latest registered L1 origin block.</p>
</li>
</ul>
<p>Conceptually what the above function captures is the formula below, where <code>compressedTxSize = (zeroes*4 + ones*16) / 16</code> can be thought of as a rough approximation of how many bytes the
transaction occupies in a compressed batch.</p>
<p><code>(compressedTxSize) * (16*l1BaseFee*lBaseFeeScalar + l1BlobBaseFee*l1BlobBaseFeeScalar) / 1e6</code></p>
<p>The precise cost function used by Ecotone at the top of this section preserves precision under
integer arithmetic by postponing the inner division by 16 until the very end.</p>
<p>The two base fee values and their respective scalars can be accessed in two interchangeable ways:</p>
<ul>
<li>read from the deposited L1 attributes (<code>l1BaseFeeScalar</code>, <code>l1BlobBaseFeeScalar</code>, <code>basefee</code>,
<code>blobBaseFee</code>) of the current L2 block</li>
<li>read from the L1 Block Info contract (<code>0x4200000000000000000000000000000000000015</code>)
<ul>
<li>using the respective solidity getter functions</li>
<li>using direct storage-reads:
<ul>
<li>basefee <code>uint256</code> in slot <code>1</code></li>
<li>blobBaseFee <code>uint256</code> in slot <code>7</code></li>
<li>l1BaseFeeScalar big-endian <code>uint32</code> slot <code>3</code> at offset <code>12</code></li>
<li>l1BlobBaseFeeScalar big-endian <code>uint32</code> in slot <code>3</code> at offset <code>8</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="engine-api-1"><a class="header" href="#engine-api-1">Engine API</a></h2>
<h3 id="engine_forkchoiceupdatedv2"><a class="header" href="#engine_forkchoiceupdatedv2"><code>engine_forkchoiceUpdatedV2</code></a></h3>
<p>This updates which L2 blocks the engine considers to be canonical (<code>forkchoiceState</code> argument),
and optionally initiates block production (<code>payloadAttributes</code> argument).</p>
<p>Within the rollup, the types of forkchoice updates translate as:</p>
<ul>
<li><code>headBlockHash</code>: block hash of the head of the canonical chain. Labeled <code>&quot;unsafe&quot;</code> in user JSON-RPC.
Nodes may apply L2 blocks out of band ahead of time, and then reorg when L1 data conflicts.</li>
<li><code>safeBlockHash</code>: block hash of the canonical chain, derived from L1 data, unlikely to reorg.</li>
<li><code>finalizedBlockHash</code>: irreversible block hash, matches lower boundary of the dispute period.</li>
</ul>
<p>To support rollup functionality, one backwards-compatible change is introduced
to <a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#engine_forkchoiceupdatedv2"><code>engine_forkchoiceUpdatedV2</code></a>: the extended <code>PayloadAttributesV2</code></p>
<h4 id="extended-payloadattributesv2"><a class="header" href="#extended-payloadattributesv2">Extended PayloadAttributesV2</a></h4>
<p><a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#PayloadAttributesV2"><code>PayloadAttributesV2</code></a> is extended to:</p>
<pre><code class="language-js">PayloadAttributesV2: {
    timestamp: QUANTITY
    random: DATA (32 bytes)
    suggestedFeeRecipient: DATA (20 bytes)
    withdrawals: array of WithdrawalV1
    transactions: array of DATA
    noTxPool: bool
    gasLimit: QUANTITY or null
}
</code></pre>
<p>The type notation used here refers to the <a href="https://eth.wiki/json-rpc/API#hex-value-encoding">HEX value encoding</a> used by the <a href="https://github.com/ethereum/execution-apis">Ethereum JSON-RPC API
specification</a>, as this structure will need to be sent over JSON-RPC. <code>array</code> refers
to a JSON array.</p>
<p>Each item of the <code>transactions</code> array is a byte list encoding a transaction: <code>TransactionType || TransactionPayload</code> or <code>LegacyTransaction</code>, as defined in <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a>.
This is equivalent to the <code>transactions</code> field in <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/shanghai.md#executionpayloadv2"><code>ExecutionPayloadV2</code></a></p>
<p>The <code>transactions</code> field is optional:</p>
<ul>
<li>If empty or missing: no changes to engine behavior. The sequencers will (if enabled) build a block
by consuming transactions from the transaction pool.</li>
<li>If present and non-empty: the payload MUST be produced starting with this exact list of transactions.
The <a href="protocol/rollup-node.html">rollup driver</a> determines the transaction list based on deterministic L1 inputs.</li>
</ul>
<p>The <code>noTxPool</code> is optional as well, and extends the <code>transactions</code> meaning:</p>
<ul>
<li>If <code>false</code>, the execution engine is free to pack additional transactions from external sources like the tx pool
into the payload, after any of the <code>transactions</code>. This is the default behavior a L1 node implements.</li>
<li>If <code>true</code>, the execution engine must not change anything about the given list of <code>transactions</code>.</li>
</ul>
<p>If the <code>transactions</code> field is present, the engine must execute the transactions in order and return <code>STATUS_INVALID</code>
if there is an error processing the transactions. It must return <code>STATUS_VALID</code> if all of the transactions could
be executed without error. <strong>Note</strong>: The state transition rules have been modified such that deposits will never fail
so if <code>engine_forkchoiceUpdatedV2</code> returns <code>STATUS_INVALID</code> it is because a batched transaction is invalid.</p>
<p>The <code>gasLimit</code> is optional w.r.t. compatibility with L1, but required when used as rollup.
This field overrides the gas limit used during block-building.
If not specified as rollup, a <code>STATUS_INVALID</code> is returned.</p>
<h3 id="engine_forkchoiceupdatedv3"><a class="header" href="#engine_forkchoiceupdatedv3"><code>engine_forkchoiceUpdatedV3</code></a></h3>
<p>See <a href="protocol/exec-engine.html#engine_forkchoiceUpdatedV2"><code>engine_forkchoiceUpdatedV2</code></a> for a description of the forkchoice updated method.
<code>engine_forkchoiceUpdatedV3</code> <strong>must only be called with Ecotone payload.</strong></p>
<p>To support rollup functionality, one backwards-compatible change is introduced
to <a href="https://github.com/ethereum/execution-apis/blob/cea7eeb642052f4c2e03449dc48296def4aafc24/src/engine/cancun.md#engine_forkchoiceupdatedv3"><code>engine_forkchoiceUpdatedV3</code></a>: the extended <code>PayloadAttributesV3</code></p>
<h4 id="extended-payloadattributesv3"><a class="header" href="#extended-payloadattributesv3">Extended PayloadAttributesV3</a></h4>
<p><a href="https://github.com/ethereum/execution-apis/blob/cea7eeb642052f4c2e03449dc48296def4aafc24/src/engine/cancun.md#payloadattributesv3"><code>PayloadAttributesV3</code></a> is extended to:</p>
<pre><code class="language-js">PayloadAttributesV3: {
    timestamp: QUANTITY
    random: DATA (32 bytes)
    suggestedFeeRecipient: DATA (20 bytes)
    withdrawals: array of WithdrawalV1
    parentBeaconBlockRoot: DATA (32 bytes)
    transactions: array of DATA
    noTxPool: bool
    gasLimit: QUANTITY or null
}
</code></pre>
<p>The requirements of this object are the same as extended <a href="protocol/exec-engine.html#extended-payloadattributesv2"><code>PayloadAttributesV2</code></a> with
the addition of <code>parentBeaconBlockRoot</code> which is the parent beacon block root from the L1 origin block of the L2 block.</p>
<p>Starting at Ecotone, the <code>parentBeaconBlockRoot</code> must be set to the L1 origin <code>parentBeaconBlockRoot</code>,
or a zero <code>bytes32</code> if the Dencun functionality with <code>parentBeaconBlockRoot</code> is not active on L1.</p>
<h3 id="engine_newpayloadv2"><a class="header" href="#engine_newpayloadv2"><code>engine_newPayloadV2</code></a></h3>
<p>No modifications to <a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#engine_newpayloadv2"><code>engine_newPayloadV2</code></a>.
Applies a L2 block to the engine state.</p>
<h3 id="engine_newpayloadv3"><a class="header" href="#engine_newpayloadv3"><code>engine_newPayloadV3</code></a></h3>
<p><a href="https://github.com/ethereum/execution-apis/blob/cea7eeb642052f4c2e03449dc48296def4aafc24/src/engine/cancun.md#engine_newpayloadv3"><code>engine_newPayloadV3</code></a> applies an Ecotone L2 block to the engine state. There are no
modifications to this API.
<code>engine_newPayloadV3</code> <strong>must only be called with Ecotone payload.</strong></p>
<p>The additional parameters should be set as follows:</p>
<ul>
<li><code>expectedBlobVersionedHashes</code> MUST be an empty array.</li>
<li><code>parentBeaconBlockRoot</code> MUST be the parent beacon block root from the L1 origin block of the L2 block.</li>
</ul>
<h3 id="engine_getpayloadv2"><a class="header" href="#engine_getpayloadv2"><code>engine_getPayloadV2</code></a></h3>
<p>No modifications to <a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#engine_getpayloadv2"><code>engine_getPayloadV2</code></a>.
Retrieves a payload by ID, prepared by <code>engine_forkchoiceUpdatedV2</code> when called with <code>payloadAttributes</code>.</p>
<h3 id="engine_getpayloadv3"><a class="header" href="#engine_getpayloadv3"><code>engine_getPayloadV3</code></a></h3>
<p><a href="https://github.com/ethereum/execution-apis/blob/a0d03086564ab1838b462befbc083f873dcf0c0f/src/engine/cancun.md#engine_getpayloadv3"><code>engine_getPayloadV3</code></a> retrieves a payload by ID, prepared by <code>engine_forkchoiceUpdatedV3</code>
when called with <code>payloadAttributes</code>.
<code>engine_getPayloadV3</code> <strong>must only be called with Ecotone payload.</strong></p>
<h4 id="extended-response"><a class="header" href="#extended-response">Extended Response</a></h4>
<p>The <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/cancun.md#response-2">response</a> is extended to:</p>
<pre><code class="language-js">{
    executionPayload: ExecutionPayload
    blockValue: QUANTITY
    blobsBundle: BlobsBundle
    shouldOverrideBuilder: BOOLEAN
    parentBeaconBlockRoot: DATA (32 bytes)
}
</code></pre>
<p>In Ecotone it MUST be set to the parentBeaconBlockRoot from the L1 Origin block of the L2 block.</p>
<h3 id="engine_signalsuperchainv1"><a class="header" href="#engine_signalsuperchainv1"><code>engine_signalSuperchainV1</code></a></h3>
<p>Optional extension to the Engine API. Signals superchain information to the Engine:
V1 signals which protocol version is recommended and required.</p>
<p>Types:</p>
<pre><code class="language-javascript">SuperchainSignal: {
  recommended: ProtocolVersion;
  required: ProtocolVersion;
}
</code></pre>
<p><code>ProtocolVersion</code>: encoded for RPC as defined in
<a href="protocol/superchain-upgrades.html#protocol-version-format">Protocol Version format specification</a>.</p>
<p>Parameters:</p>
<ul>
<li><code>signal</code>: <code>SuperchainSignal</code>, the signaled superchain information.</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>ProtocolVersion</code>: the latest supported OP-Stack protocol version of the execution engine.</li>
</ul>
<p>The execution engine SHOULD warn the user when the recommended version is newer than
the current version supported by the execution engine.</p>
<p>The execution engine SHOULD take safety precautions if it does not meet the required protocol version.
This may include halting the engine, with consent of the execution engine operator.</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<p>The execution engine can acquire all data through the rollup node, as derived from L1:
<em>P2P networking is strictly optional.</em></p>
<p>However, to not bottleneck on L1 data retrieval speed, the P2P network functionality SHOULD be enabled, serving:</p>
<ul>
<li>Peer discovery (<a href="https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md">Disc v5</a>)</li>
<li><a href="https://github.com/ethereum/devp2p/blob/master/caps/eth.md"><code>eth/66</code></a>:
<ul>
<li>Transaction pool (consumed by sequencer nodes)</li>
<li>State sync (happy-path for fast trustless db replication)</li>
<li>Historical block header and body retrieval</li>
<li><em>New blocks are acquired through the consensus layer instead (rollup node)</em></li>
</ul>
</li>
</ul>
<p>No modifications to L1 network functionality are required, except configuration:</p>
<ul>
<li><a href="https://github.com/ethereum/devp2p/blob/master/caps/eth.md#status-0x00"><code>networkID</code></a>: Distinguishes the L2 network from L1 and testnets.
Equal to the <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md"><code>chainID</code></a> of the rollup network.</li>
<li>Activate Merge fork: Enables Engine API and disables propagation of blocks,
as block headers cannot be authenticated without consensus layer.</li>
<li>Bootnode list: DiscV5 is a shared network,
<a href="https://github.com/ethereum/devp2p/blob/master/discv5/discv5-rationale.md">bootstrap</a> is faster through connecting with L2 nodes first.</li>
</ul>
<h2 id="sync"><a class="header" href="#sync">Sync</a></h2>
<p>The execution engine can operate sync in different ways:</p>
<ul>
<li>Happy-path: rollup node informs engine of the desired chain head as determined by L1, completes through engine P2P.</li>
<li>Worst-case: rollup node detects stalled engine, completes sync purely from L1 data, no peers required.</li>
</ul>
<p>The happy-path is more suitable to bring new nodes online quickly,
as the engine implementation can sync state faster through methods like <a href="https://github.com/ethereum/devp2p/blob/master/caps/snap.md">snap-sync</a>.</p>
<h3 id="happy-path-sync"><a class="header" href="#happy-path-sync">Happy-path sync</a></h3>
<ol>
<li>The rollup node informs the engine of the L2 chain head, unconditionally (part of regular node operation):
<ul>
<li>Bedrock / Canyon / Delta Payloads
<ul>
<li><a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#engine_newpayloadv2"><code>engine_newPayloadV2</code></a> is called with latest L2 block received from P2P.</li>
<li><a href="https://github.com/ethereum/execution-apis/blob/584905270d8ad665718058060267061ecfd79ca5/src/engine/shanghai.md#engine_forkchoiceupdatedv2"><code>engine_forkchoiceUpdatedV2</code></a> is called with the current
<code>unsafe</code>/<code>safe</code>/<code>finalized</code> L2 block hashes.</li>
</ul>
</li>
<li>Ecotone Payloads
<ul>
<li><a href="https://github.com/ethereum/execution-apis/blob/cea7eeb642052f4c2e03449dc48296def4aafc24/src/engine/cancun.md#engine_newpayloadv3"><code>engine_newPayloadV3</code></a> is called with latest L2 block received from P2P.</li>
<li><a href="https://github.com/ethereum/execution-apis/blob/cea7eeb642052f4c2e03449dc48296def4aafc24/src/engine/cancun.md#engine_forkchoiceupdatedv3"><code>engine_forkchoiceUpdatedV3</code></a> is called with the current
<code>unsafe</code>/<code>safe</code>/<code>finalized</code> L2 block hashes.</li>
</ul>
</li>
</ul>
</li>
<li>The engine requests headers from peers, in reverse till the parent hash matches the local chain</li>
<li>The engine catches up:
a) A form of state sync is activated towards the finalized or head block hash
b) A form of block sync pulls block bodies and processes towards head block hash</li>
</ol>
<p>The exact P2P based sync is out of scope for the L2 specification:
the operation within the engine is the exact same as with L1 (although with an EVM that supports deposits).</p>
<h3 id="worst-case-sync"><a class="header" href="#worst-case-sync">Worst-case sync</a></h3>
<ol>
<li>Engine is out of sync, not peered and/or stalled due other reasons.</li>
<li>The rollup node maintains latest head from engine (poll <code>eth_getBlockByNumber</code> and/or maintain a header subscription)</li>
<li>The rollup node activates sync if the engine is out of sync but not syncing through P2P (<code>eth_syncing</code>)</li>
<li>The rollup node inserts blocks, derived from L1, one by one, potentially adapting to L1 reorg(s),
as outlined in the <a href="protocol/rollup-node.html">rollup node spec</a>.</li>
</ol>
<h2 id="ecotone-disable-blob-transactions"><a class="header" href="#ecotone-disable-blob-transactions">Ecotone: disable Blob-transactions</a></h2>
<p><a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a> introduces Blob transactions: featuring all the functionality of an <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a> transaction,
plus a list of &quot;blobs&quot;: &quot;Binary Large Object&quot;, i.e. a dedicated data type for serving Data-Availability as base-layer.</p>
<p>With the Ecotone upgrade, all Cancun L1 execution features are enabled, with <a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a> as exception:
as a L2, the OP-Stack does not serve blobs, and thus disables this new transaction type.</p>
<p>EIP-4844 is disabled as following:</p>
<ul>
<li>Transaction network-layer announcements, announcing blob-type transactions, are ignored.</li>
<li>Transactions of the blob-type, through the RPC or otherwise, are not allowed into the transaction pool.</li>
<li>Block-building code does not select EIP-4844 transactions.</li>
<li>An L2 block state-transition with EIP-4844 transactions is invalid.</li>
</ul>
<p>The <a href="https://eips.ethereum.org/EIPS/eip-7516">BLOBBASEFEE opcode</a> is present but its semantics are
altered because there are no blobs processed by L2. The opcode will always push a value of 1 onto
the stack.</p>
<h2 id="ecotone-beacon-block-root"><a class="header" href="#ecotone-beacon-block-root">Ecotone: Beacon Block Root</a></h2>
<p><a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788</a> introduces a &quot;beacon block root&quot; into the execution-layer block-header and EVM.
This block root is an <a href="https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization">SSZ hash-tree-root</a> of the consensus-layer contents of the previous consensus block.</p>
<p>With the adoption of <a href="https://eips.ethereum.org/EIPS/eip-4399">EIP-4399</a> in the Bedrock upgrade the OP-Stack already includes the <code>PREVRANDAO</code> of L1.
And thus with <a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788</a> the L1 beacon block root is made available.</p>
<p>For the Ecotone upgrade, this entails that:</p>
<ul>
<li>The <code>parent_beacon_block_root</code> of the L1 origin is now embedded in the L2 block header.</li>
<li>The &quot;Beacon roots contract&quot; is deployed at Ecotone upgrade-time, or embedded at genesis if activated at genesis.</li>
<li>The block state-transition process now includes the same special beacon-block-root EVM processing as L1 ethereum.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="rollup-node-specification"><a class="header" href="#rollup-node-specification">Rollup Node Specification</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/rollup-node.html#overview">Overview</a></li>
<li><a href="protocol/rollup-node.html#driver">Driver</a>
<ul>
<li><a href="protocol/rollup-node.html#derivation">Derivation</a></li>
</ul>
</li>
<li><a href="protocol/rollup-node.html#l2-output-rpc-method">L2 Output RPC method</a>
<ul>
<li><a href="protocol/rollup-node.html#structures">Structures</a>
<ul>
<li><a href="protocol/rollup-node.html#blockid">BlockID</a></li>
<li><a href="protocol/rollup-node.html#l1blockref">L1BlockRef</a></li>
<li><a href="protocol/rollup-node.html#l2blockref">L2BlockRef</a></li>
<li><a href="protocol/rollup-node.html#syncstatus">SyncStatus</a></li>
</ul>
</li>
<li><a href="protocol/rollup-node.html#output-method-api">Output Method API</a></li>
</ul>
</li>
<li><a href="protocol/rollup-node.html#protocol-version-tracking">Protocol Version tracking</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>The <a href="protocol/../glossary.html#rollup-node">rollup node</a> is the component responsible for <a href="protocol/../glossary.html#L2-chain-derivation">deriving the L2 chain</a> from L1 blocks
(and their associated <a href="protocol/../glossary.html#receipt">receipts</a>).</p>
<p>The part of the rollup node that derives the L2 chain is called the <a href="protocol/../glossary.html#rollup-driver">rollup driver</a>. This document is
currently only concerned with the specification of the rollup driver.</p>
<h2 id="driver"><a class="header" href="#driver">Driver</a></h2>
<p>The task of the <a href="protocol/../glossary.html#rollup-driver">driver</a> in the <a href="protocol/../glossary.html#rollup-node">rollup node</a>
is to manage the <a href="protocol/../glossary.html#L2-chain-derivation">derivation</a> process:</p>
<ul>
<li>Keep track of L1 head block</li>
<li>Keep track of the L2 chain sync progress</li>
<li>Iterate over the derivation steps as new inputs become available</li>
</ul>
<h3 id="derivation"><a class="header" href="#derivation">Derivation</a></h3>
<p>This process happens in three steps:</p>
<ol>
<li>Select inputs from the L1 chain, on top of the last L2 block:
a list of blocks, with transactions and associated data and receipts.</li>
<li>Read L1 information, deposits, and sequencing batches in order to generate <a href="protocol/../glossary.html#payload-attributes">payload attributes</a>
(essentially <a href="protocol/../glossary.html#block">a block without output properties</a>).</li>
<li>Pass the payload attributes to the <a href="protocol/../glossary.html#execution-engine">execution engine</a>, so that the L2 block (including <a href="protocol/../glossary.html#block">output block
properties</a>) may be computed.</li>
</ol>
<p>While this process is conceptually a pure function from the L1 chain to the L2 chain, it is in practice incremental. The
L2 chain is extended whenever new L1 blocks are added to the L1 chain. Similarly, the L2 chain re-organizes whenever the
L1 chain <a href="protocol/../glossary.html#re-organization">re-organizes</a>.</p>
<p>For a complete specification of the L2 block derivation, refer to the <a href="protocol/derivation.html">L2 block derivation document</a>.</p>
<h2 id="l2-output-rpc-method"><a class="header" href="#l2-output-rpc-method">L2 Output RPC method</a></h2>
<p>The Rollup node has its own RPC method, <code>optimism_outputAtBlock</code> which returns a 32
byte hash corresponding to the <a href="protocol/proposals.html#l2-output-commitment-construction">L2 output root</a>.</p>
<h3 id="structures"><a class="header" href="#structures">Structures</a></h3>
<p>These define the types used by rollup node API methods.
The types defined here are extended from the <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/paris.md#structures">engine API specs</a>.</p>
<h4 id="blockid"><a class="header" href="#blockid">BlockID</a></h4>
<ul>
<li><code>hash</code>: <code>DATA</code>, 32 Bytes</li>
<li><code>number</code>: <code>QUANTITY</code>, 64 Bits</li>
</ul>
<h4 id="l1blockref"><a class="header" href="#l1blockref">L1BlockRef</a></h4>
<ul>
<li><code>hash</code>: <code>DATA</code>, 32 Bytes</li>
<li><code>number</code>: <code>QUANTITY</code>, 64 Bits</li>
<li><code>parentHash</code>: <code>DATA</code>, 32 Bytes</li>
<li><code>timestamp</code>: <code>QUANTITY</code>, 64 Bits</li>
</ul>
<h4 id="l2blockref"><a class="header" href="#l2blockref">L2BlockRef</a></h4>
<ul>
<li><code>hash</code>: <code>DATA</code>, 32 Bytes</li>
<li><code>number</code>: <code>QUANTITY</code>, 64 Bits</li>
<li><code>parentHash</code>: <code>DATA</code>, 32 Bytes</li>
<li><code>timestamp</code>: <code>QUANTITY</code>, 64 Bits</li>
<li><code>l1origin</code>: <code>BlockID</code></li>
<li><code>sequenceNumber</code>: <code>QUANTITY</code>, 64 Bits - distance to first block of epoch</li>
</ul>
<h4 id="syncstatus"><a class="header" href="#syncstatus">SyncStatus</a></h4>
<p>Represents a snapshot of the rollup driver.</p>
<ul>
<li><code>current_l1</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l1blockref"><code>L1BlockRef</code></a>.</li>
<li><code>current_l1_finalized</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l1blockref"><code>L1BlockRef</code></a>.</li>
<li><code>head_l1</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l1blockref"><code>L1BlockRef</code></a>.</li>
<li><code>safe_l1</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l1blockref"><code>L1BlockRef</code></a>.</li>
<li><code>finalized_l1</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l1blockref"><code>L1BlockRef</code></a>.</li>
<li><code>unsafe_l2</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
<li><code>safe_l2</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
<li><code>finalized_l2</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
<li><code>pending_safe_l2</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
<li><code>queued_unsafe_l2</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
</ul>
<h3 id="output-method-api"><a class="header" href="#output-method-api">Output Method API</a></h3>
<p>The input and return types here are as defined by the <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/paris.md#structures">engine API specs</a>.</p>
<ul>
<li>method: <code>optimism_outputAtBlock</code></li>
<li>params:
<ol>
<li><code>blockNumber</code>: <code>QUANTITY</code>, 64 bits - L2 integer block number.</li>
</ol>
</li>
<li>returns:
<ol>
<li><code>version</code>: <code>DATA</code>, 32 Bytes - the output root version number, beginning with 0.</li>
<li><code>outputRoot</code>: <code>DATA</code>, 32 Bytes - the output root.</li>
<li><code>blockRef</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#l2blockref"><code>L2BlockRef</code></a>.</li>
<li><code>withdrawalStorageRoot</code>: 32 bytes - storage root of the <code>L2toL1MessagePasser</code> contract.</li>
<li><code>stateRoot</code>: <code>DATA</code>: 32 bytes - the state root.</li>
<li><code>syncStatus</code>: <code>Object</code> - instance of <a href="protocol/rollup-node.html#syncstatus"><code>SyncStatus</code></a>.</li>
</ol>
</li>
</ul>
<h2 id="protocol-version-tracking"><a class="header" href="#protocol-version-tracking">Protocol Version tracking</a></h2>
<p>The rollup-node should monitor the recommended and required protocol version by monitoring
the Protocol Version contract on L1, as specified in the <a href="protocol/superchain-upgrades.html#superchain-version-signaling">Superchain Version Signaling specifications</a>.</p>
<p>This can be implemented through polling in the <a href="protocol/rollup-node.html#driver">Driver</a> loop.
After polling the Protocol Version, the rollup node SHOULD communicate it with the execution-engine through an
<a href="protocol/exec-engine.html#enginesignalsuperchainv1"><code>engine_signalSuperchainV1</code></a> call.</p>
<p>The rollup node SHOULD warn the user when the recommended version is newer than
the current version supported by the rollup node.</p>
<p>The rollup node SHOULD take safety precautions if it does not meet the required protocol version.
This may include halting the engine, with consent of the rollup node operator.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="rollup-node-p2p-interface"><a class="header" href="#rollup-node-p2p-interface">Rollup-node P2P interface</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/rollup-node-p2p.html#overview">Overview</a></li>
<li><a href="protocol/rollup-node-p2p.html#p2p-configuration">P2P configuration</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#identification">Identification</a></li>
<li><a href="protocol/rollup-node-p2p.html#discv5">Discv5</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#structure">Structure</a></li>
</ul>
</li>
<li><a href="protocol/rollup-node-p2p.html#libp2p">LibP2P</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#transport">Transport</a></li>
<li><a href="protocol/rollup-node-p2p.html#dialing">Dialing</a></li>
<li><a href="protocol/rollup-node-p2p.html#nat">NAT</a></li>
<li><a href="protocol/rollup-node-p2p.html#peer-management">Peer management</a></li>
<li><a href="protocol/rollup-node-p2p.html#transport-security">Transport security</a></li>
<li><a href="protocol/rollup-node-p2p.html#protocol-negotiation">Protocol negotiation</a></li>
<li><a href="protocol/rollup-node-p2p.html#identify">Identify</a></li>
<li><a href="protocol/rollup-node-p2p.html#ping">Ping</a></li>
<li><a href="protocol/rollup-node-p2p.html#multiplexing">Multiplexing</a></li>
<li><a href="protocol/rollup-node-p2p.html#gossipsub">GossipSub</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#content-based-message-identification">Content-based message identification</a></li>
<li><a href="protocol/rollup-node-p2p.html#message-compression-and-limits">Message compression and limits</a></li>
<li><a href="protocol/rollup-node-p2p.html#message-id-computation">Message ID computation</a></li>
</ul>
</li>
<li><a href="protocol/rollup-node-p2p.html#heartbeat-and-parameters">Heartbeat and parameters</a></li>
<li><a href="protocol/rollup-node-p2p.html#topic-configuration">Topic configuration</a></li>
<li><a href="protocol/rollup-node-p2p.html#topic-validation">Topic validation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/rollup-node-p2p.html#gossip-topics">Gossip Topics</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#blocksv1"><code>blocksv1</code></a></li>
<li><a href="protocol/rollup-node-p2p.html#blocksv2"><code>blocksv2</code></a></li>
<li><a href="protocol/rollup-node-p2p.html#blocksv3"><code>blocksv3</code></a></li>
<li><a href="protocol/rollup-node-p2p.html#block-encoding">Block encoding</a></li>
<li><a href="protocol/rollup-node-p2p.html#block-signatures">Block signatures</a></li>
<li><a href="protocol/rollup-node-p2p.html#block-validation">Block validation</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#block-processing">Block processing</a></li>
<li><a href="protocol/rollup-node-p2p.html#block-topic-scoring-parameters">Block topic scoring parameters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/rollup-node-p2p.html#req-resp">Req-Resp</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#payload_by_number"><code>payload_by_number</code></a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The <a href="protocol/rollup-node.html">rollup node</a> has an optional peer-to-peer (P2P) network service to improve the latency between
the view of sequencers and the rest of the network by bypassing the L1 in the happy case,
without relying on a single centralized endpoint.</p>
<p>This also enables faster historical sync to be bootstrapped by providing block headers to sync towards,
and only having to compare the L2 chain inputs to the L1 data as compared to processing everything one block at a time.</p>
<p>The rollup node will <em>always</em> prioritize L1 and reorganize to match the canonical chain.
The L2 data retrieved via the P2P interface is strictly a speculative extension, also known as the &quot;unsafe&quot; chain,
to improve the happy case performance.</p>
<p>This also means that P2P behavior is a soft-rule: nodes keep each other in check with scoring and eventual banning
of malicious peers by identity or IP. Any behavior on the P2P layer does not affect the rollup security, at worst nodes
rely on higher-latency data from L1 to serve.</p>
<p>In summary, the P2P stack looks like:</p>
<ul>
<li>Discovery to find peers: <a href="https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md">Discv5</a></li>
<li>Connections, peering, transport security, multiplexing, gossip: <a href="https://libp2p.io/">LibP2P</a></li>
<li>Application-layer publishing and validation of gossiped messages like L2 blocks.</li>
</ul>
<p>This document only specifies the composition and configuration of these network libraries.
These components have their own standards, implementations in Go/Rust/Java/Nim/JS/more,
and are adopted by several other blockchains, most notably the <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md">L1 consensus layer (Eth2)</a>.</p>
<h2 id="p2p-configuration"><a class="header" href="#p2p-configuration">P2P configuration</a></h2>
<h3 id="identification"><a class="header" href="#identification">Identification</a></h3>
<p>Nodes have a <strong>separate</strong> network- and consensus-identity.
The network identity is a <code>secp256k1</code> key, used for both discovery and active LibP2P connections.</p>
<p>Common representations of network identity:</p>
<ul>
<li><code>PeerID</code>: a LibP2P specific ID derived from the pubkey (through protobuf encoding, typing and hashing)</li>
<li><code>NodeID</code>: a Discv5 specific ID derived from the pubkey (through hashing, used in the DHT)</li>
<li><code>Multi-address</code>: an unsigned address, containing: IP, TCP port, PeerID</li>
<li><code>ENR</code>: a signed record used for discovery, containing: IP, TCP port, UDP port, signature (pubkey can be derived)
and L2 network identification. Generally encoded in base64.</li>
</ul>
<h3 id="discv5"><a class="header" href="#discv5">Discv5</a></h3>
<h4 id="structure"><a class="header" href="#structure">Structure</a></h4>
<p>The Ethereum Node Record (ENR) for an Optimism rollup node must contain the following values, identified by unique keys:</p>
<ul>
<li>An IPv4 address (<code>ip</code> field) and/or IPv6 address (<code>ip6</code> field).</li>
<li>A TCP port (<code>tcp</code> field) representing the local libp2p listening port.</li>
<li>A UDP port (<code>udp</code> field) representing the local discv5 listening port.</li>
<li>An OpStack (<code>opstack</code> field) L2 network identifier</li>
</ul>
<p>The <code>opstack</code> value is encoded as a single RLP <code>bytes</code> value, the concatenation of:</p>
<ul>
<li>chain ID (<code>unsigned varint</code>)</li>
<li>fork ID (<code>unsigned varint</code>)</li>
</ul>
<p>Note that DiscV5 is a shared DHT (Distributed Hash Table): the L1 consensus and execution nodes,
as well as testnet nodes, and even external IOT nodes, all communicate records in this large common DHT.
This makes it more difficult to censor the discovery of node records.</p>
<p>The discovery process in Optimism is a pipeline of node records:</p>
<ol>
<li>Fill the table with <code>FINDNODES</code> if necessary (Performed by Discv5 library)</li>
<li>Pull additional records with searches to random Node IDs if necessary
(e.g. iterate <a href="https://pkg.go.dev/github.com/ethereum/go-ethereum@v1.10.12/p2p/discover#UDPv5.RandomNodes"><code>RandomNodes()</code></a> in Go implementation)</li>
<li>Pull records from the DiscV5 module when looking for peers</li>
<li>Check if the record contains the <code>opstack</code> entry, verify it matches the chain ID and current or future fork number</li>
<li>If not already connected, and not recently disconnected or put on deny-list, attempt to dial.</li>
</ol>
<h3 id="libp2p"><a class="header" href="#libp2p">LibP2P</a></h3>
<h4 id="transport"><a class="header" href="#transport">Transport</a></h4>
<p>TCP transport. Additional transports are supported by LibP2P, but not required.</p>
<h4 id="dialing"><a class="header" href="#dialing">Dialing</a></h4>
<p>Nodes should be publicly dialable, not rely on relay extensions, and able to dial both IPv4 and IPv6.</p>
<h4 id="nat"><a class="header" href="#nat">NAT</a></h4>
<p>The listening endpoint must be publicly facing, but may be configured behind a NAT.
LibP2P will use PMP / UPNP based techniques to track the external IP of the node.
It is recommended to disable the above if the external IP is static and configured manually.</p>
<h4 id="peer-management"><a class="header" href="#peer-management">Peer management</a></h4>
<p>The default is to maintain a peer count with a tide-system based on active peer count:</p>
<ul>
<li>At &quot;low tide&quot; the node starts to actively search for additional peer connections.</li>
<li>At &quot;high tide&quot; the node starts to prune active connections,
except those that are marked as trusted or have a grace period.</li>
</ul>
<p>Peers will have a grace period for a configurable amount of time after joining.
In an emergency, when memory runs low, the node should start pruning more aggressively.</p>
<p>Peer records can be persisted to disk to quickly reconnect with known peers after restarting the rollup node.</p>
<p>The discovery process feeds the peerstore with peer records to connect to, tagged with a time-to-live (TTL).
The current P2P processes do not require selective topic-specific peer connections,
other than filtering for the basic network participation requirement.</p>
<p>Peers may be banned if their performance score is too low, or if an objectively malicious action was detected.</p>
<p>Banned peers will be persisted to the same data-store as the peerstore records.</p>
<p>TODO: the connection gater does currently not gate by IP address on the dial Accept-callback.</p>
<h4 id="transport-security"><a class="header" href="#transport-security">Transport security</a></h4>
<p><a href="https://github.com/libp2p/specs/tree/master/noise">Libp2p-noise</a>, <code>XX</code> handshake, with the <code>secp256k1</code> P2P identity, as popularized in Eth2.
The TLS option is available as well, but <code>noise</code> should be prioritized in negotiation.</p>
<h4 id="protocol-negotiation"><a class="header" href="#protocol-negotiation">Protocol negotiation</a></h4>
<p><a href="https://github.com/multiformats/multistream-select/">Multistream-select 1.0</a> (<code>/multistream/1.0.0</code>) is an interactive protocol
used to negotiate sub-protocols supported in LibP2P peers. Multistream-select 2.0 may be used in the future.</p>
<h4 id="identify"><a class="header" href="#identify">Identify</a></h4>
<p>LibP2P offers a minimal identification module to share client version and programming language.
This is optional and can be disabled for enhanced privacy.
It also includes the same protocol negotiation information, which can speed up initial connections.</p>
<h4 id="ping"><a class="header" href="#ping">Ping</a></h4>
<p>LibP2P includes a simple ping protocol to track latency between connections.
This should be enabled to help provide insight into the network health.</p>
<h4 id="multiplexing"><a class="header" href="#multiplexing">Multiplexing</a></h4>
<p>For async communication over different channels over the same connection, multiplexing is used.
<a href="https://github.com/libp2p/specs/tree/master/mplex">mplex</a> (<code>/mplex/6.7.0</code>) is required, and <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a> (<code>/yamux/1.0.0</code>) is recommended but optional</p>
<h4 id="gossipsub"><a class="header" href="#gossipsub">GossipSub</a></h4>
<p><a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md">GossipSub 1.1</a> (<code>/meshsub/1.1.0</code>, i.e. with peer-scoring extension) is a pubsub protocol for mesh-networks,
deployed on L1 consensus (Eth2) and other protocols such as Filecoin, offering lots of customization options.</p>
<h5 id="content-based-message-identification"><a class="header" href="#content-based-message-identification">Content-based message identification</a></h5>
<p>Messages are deduplicated, and filtered through application-layer signature verification.
Thus origin-stamping is disabled and published messages must only contain application data,
enforced through a <a href="https://github.com/libp2p/specs/blob/master/pubsub/README.md#signature-policy-options"><code>StrictNoSign</code> Signature Policy</a></p>
<p>This provides greater privacy, and allows sequencers (consensus identity) to maintain
multiple network identities for redundancy.</p>
<h5 id="message-compression-and-limits"><a class="header" href="#message-compression-and-limits">Message compression and limits</a></h5>
<p>The application contents are compressed with <a href="https://github.com/google/snappy">snappy</a> single-block-compression
(as opposed to frame-compression), and constrained to 10 MiB.</p>
<h5 id="message-id-computation"><a class="header" href="#message-id-computation">Message ID computation</a></h5>
<p><a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#topics-and-messages">Same as L1</a>, with recognition of compression:</p>
<ul>
<li>If <code>message.data</code> has a valid snappy decompression, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of
the concatenation of <code>MESSAGE_DOMAIN_VALID_SNAPPY</code> with the snappy decompressed message data,
i.e. <code>SHA256(MESSAGE_DOMAIN_VALID_SNAPPY + snappy_decompress(message.data))[:20]</code>.</li>
<li>Otherwise, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of
the concatenation of <code>MESSAGE_DOMAIN_INVALID_SNAPPY</code> with the raw message data,
i.e. <code>SHA256(MESSAGE_DOMAIN_INVALID_SNAPPY + message.data)[:20]</code>.</li>
</ul>
<h4 id="heartbeat-and-parameters"><a class="header" href="#heartbeat-and-parameters">Heartbeat and parameters</a></h4>
<p>GossipSub <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#parameters">parameters</a>:</p>
<ul>
<li><code>D</code> (topic stable mesh target count): 8</li>
<li><code>D_low</code> (topic stable mesh low watermark): 6</li>
<li><code>D_high</code> (topic stable mesh high watermark): 12</li>
<li><code>D_lazy</code> (gossip target): 6</li>
<li><code>heartbeat_interval</code> (interval of heartbeat, in seconds): 0.5</li>
<li><code>fanout_ttl</code> (ttl for fanout maps for topics we are not subscribed to but have published to, in seconds): 24</li>
<li><code>mcache_len</code> (number of windows to retain full messages in cache for <code>IWANT</code> responses): 12</li>
<li><code>mcache_gossip</code> (number of windows to gossip about): 3</li>
<li><code>seen_ttl</code> (number of heartbeat intervals to retain message IDs): 130 (= 65 seconds)</li>
</ul>
<p>Notable differences from L1 consensus (Eth2):</p>
<ul>
<li><code>seen_ttl</code> does not need to cover a full L1 epoch (6.4 minutes), but rather just a small window covering latest blocks</li>
<li><code>fanout_ttl</code>: adjusted to lower than <code>seen_ttl</code></li>
<li><code>mcache_len</code>: a larger number of heartbeats can be retained since the gossip is much less noisy.</li>
<li><code>heartbeat_interval</code>: faster interval to reduce latency, bandwidth should still be reasonable since
there are far fewer messages to gossip about each interval than on L1 which uses an interval of 0.7 seconds.</li>
</ul>
<h4 id="topic-configuration"><a class="header" href="#topic-configuration">Topic configuration</a></h4>
<p>Topics have string identifiers and are communicated with messages and subscriptions.
<code>/optimism/chain_id/hardfork_version/Name</code></p>
<ul>
<li><code>chain_id</code>: replace with decimal representation of chain ID</li>
<li><code>hardfork_version</code>: replace with decimal representation of hardfork, starting at <code>0</code></li>
<li><code>Name</code>: topic application-name</li>
</ul>
<p>Note that the topic encoding depends on the topic, unlike L1,
since there are less topics, and all are snappy-compressed.</p>
<h4 id="topic-validation"><a class="header" href="#topic-validation">Topic validation</a></h4>
<p>To ensure only valid messages are relayed, and malicious peers get scored based on application behavior,
an <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#extended-validators">extended validator</a> checks the message before it is relayed or processed.
The extended validator emits one of the following validation signals:</p>
<ul>
<li><code>ACCEPT</code> valid, relayed to other peers and passed to local topic subscriber</li>
<li><code>IGNORE</code> scored like inactivity, message is dropped and not processed</li>
<li><code>REJECT</code> score penalties, message is dropped</li>
</ul>
<h2 id="gossip-topics"><a class="header" href="#gossip-topics">Gossip Topics</a></h2>
<p>There are three topics for distributing blocks to other nodes faster than proxying through L1 would. These are:</p>
<h3 id="blocksv1"><a class="header" href="#blocksv1"><code>blocksv1</code></a></h3>
<p>Pre-Canyon/Shanghai blocks are broadcast on <code>/optimism/&lt;chainId&gt;/0/blocks</code>.</p>
<h3 id="blocksv2"><a class="header" href="#blocksv2"><code>blocksv2</code></a></h3>
<p>Canyon/Delta blocks are broadcast on <code>/optimism/&lt;chainId&gt;/1/blocks</code>.</p>
<h3 id="blocksv3"><a class="header" href="#blocksv3"><code>blocksv3</code></a></h3>
<p>Ecotone blocks are broadcast on <code>/optimism/&lt;chainId&gt;/2/blocks</code>.</p>
<h3 id="block-encoding"><a class="header" href="#block-encoding">Block encoding</a></h3>
<p>A block is structured as the concatenation of:</p>
<ul>
<li>V1 and V2 topics
<ul>
<li><code>signature</code>: A <code>secp256k1</code> signature, always 65 bytes, <code>r (uint256), s (uint256), y_parity (uint8)</code></li>
<li><code>payload</code>: A SSZ-encoded <code>ExecutionPayload</code>, always the remaining bytes.</li>
</ul>
</li>
<li>V3 topic
<ul>
<li><code>signature</code>: A <code>secp256k1</code> signature, always 65 bytes, <code>r (uint256), s (uint256), y_parity (uint8)</code></li>
<li><code>parentBeaconBlockRoot</code>: L1 origin parent beacon block root, always 32 bytes</li>
<li><code>payload</code>: A SSZ-encoded <code>ExecutionPayload</code>, always the remaining bytes.</li>
</ul>
</li>
</ul>
<p>All topics use Snappy block-compression (i.e. no snappy frames):
the above needs to be compressed after encoding, and decompressed before decoding.</p>
<h3 id="block-signatures"><a class="header" href="#block-signatures">Block signatures</a></h3>
<p>The <code>signature</code> is a <code>secp256k1</code> signature, and signs over a message:
<code>keccak256(domain ++ chain_id ++ payload_hash)</code>, where:</p>
<ul>
<li><code>domain</code> is 32 bytes, reserved for message types and versioning info. All zero for this signature.</li>
<li><code>chain_id</code> is a big-endian encoded <code>uint256</code>.</li>
<li><code>payload_hash</code> is <code>keccak256(payload)</code>, where <code>payload</code> is the remaining bytes of the payload.</li>
</ul>
<p>The <code>secp256k1</code> signature must have <code>y_parity = 1 or 0</code>, the <code>chain_id</code> is already signed over.</p>
<h3 id="block-validation"><a class="header" href="#block-validation">Block validation</a></h3>
<p>An <a href="https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#extended-validators">extended-validator</a> checks the incoming messages as follows, in order of operation:</p>
<ul>
<li><code>[REJECT]</code> if the compression is not valid</li>
<li><code>[REJECT]</code> if the block encoding is not valid</li>
<li><code>[REJECT]</code> if the <code>payload.timestamp</code> is older than 60 seconds in the past
(graceful boundary for worst-case propagation and clock skew)</li>
<li><code>[REJECT]</code> if the <code>payload.timestamp</code> is more than 5 seconds into the future</li>
<li><code>[REJECT]</code> if the <code>block_hash</code> in the <code>payload</code> is not valid</li>
<li><code>[REJECT]</code> if the block is on the V1 topic and has withdrawals</li>
<li><code>[REJECT]</code> if the block is on the V1 topic and has a withdrawals list</li>
<li><code>[REJECT]</code> if the block is on a topic &gt;= V2 and does not have an empty withdrawals list</li>
<li><code>[REJECT]</code> if the block is on a topic &lt;= V2 and has a blob gas-used value set</li>
<li><code>[REJECT]</code> if the block is on a topic &lt;= V2 and has an excess blob gas value set</li>
<li><code>[REJECT]</code> if the block is on a topic &gt;= V3 and has a blob gas-used value that is not zero</li>
<li><code>[REJECT]</code> if the block is on a topic &gt;= V3 and has an excess blob gas value that is not zero</li>
<li><code>[REJECT]</code> if the block is on a topic &lt;= V2 and the parent beacon block root is not nil</li>
<li><code>[REJECT]</code> if the block is on a topic &gt;= V3 and the parent beacon block root is nil</li>
<li><code>[REJECT]</code> if more than 5 different blocks have been seen with the same block height</li>
<li><code>[IGNORE]</code> if the block has already been seen</li>
<li><code>[REJECT]</code> if the signature by the sequencer is not valid</li>
<li>Mark the block as seen for the given block height</li>
</ul>
<p>The block is signed by the corresponding sequencer, to filter malicious messages.
The sequencer model is singular but may change to multiple sequencers in the future.
A default sequencer pubkey is distributed with rollup nodes and should be configurable.</p>
<p>Note that blocks that a block may still be propagated even if the L1 already confirmed a different block.
The local L1 view of the node may be wrong, and the time and signature validation will prevent spam.
Hence, calling into the execution engine with a block lookup every propagation step is not worth the added delay.</p>
<h4 id="block-processing"><a class="header" href="#block-processing">Block processing</a></h4>
<p>A node may apply the block to their local engine ahead of L1 availability, if it ensures that:</p>
<ul>
<li>The application of the block is reversible, in case of a conflict with delayed L1 information</li>
<li>The subsequent forkchoice-update ensures this block is recognized as &quot;unsafe&quot;
(see <a href="protocol/derivation.html#engine-api-usage">fork choice updated</a>)</li>
</ul>
<h4 id="block-topic-scoring-parameters"><a class="header" href="#block-topic-scoring-parameters">Block topic scoring parameters</a></h4>
<p>TODO: GossipSub per-topic scoring to fine-tune incentives for ideal propagation delay and bandwidth usage.</p>
<h2 id="req-resp"><a class="header" href="#req-resp">Req-Resp</a></h2>
<p>The op-node implements a similar request-response encoding for its sync protocols as the L1 ethereum Beacon-Chain.
See <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#the-reqresp-domain">L1 P2P-interface req-resp specification</a> and <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/p2p-interface.md#the-reqresp-domain">Altair P2P update</a>.</p>
<p>However, the protocol is simplified, to avoid several issues seen in L1:</p>
<ul>
<li>Error strings in responses, if there is any alternative response,
should not need to be compressed or have an artificial global length limit.</li>
<li>Payload lengths should be fixed-length: byte-by-byte uvarint reading from the underlying stream is undesired.</li>
<li><code>&lt;context-bytes&gt;</code> are relaxed to encode a <code>uint32</code>, rather than a beacon-chain <code>ForkDigest</code>.</li>
<li>Payload-encoding may change per hardfork, so is not part of the protocol-ID.</li>
<li>Usage of response-chunks is specific to the req-resp method: most basic req-resp does not need chunked responses.</li>
<li>Compression is encouraged to be part of the payload-encoding, specific to the req-resp method, where necessary:
pings and such do not need streaming frame compression etc.</li>
</ul>
<p>And the protocol ID format follows the same scheme as L1,
except the trailing encoding schema part, which is now message-specific:</p>
<pre><code class="language-text">/ProtocolPrefix/MessageName/SchemaVersion/
</code></pre>
<p>The req-resp protocols served by the op-node all have <code>/ProtocolPrefix</code> set to <code>/opstack/req</code>.</p>
<p>Individual methods may include the chain ID as part of the <code>/MessageName</code> segment,
so it's immediately clear which chain the method applies to, if the communication is chain-specific.
Other methods may include chain-information in the request and/or response data,
such as the <code>ForkDigest</code> <code>&lt;context-bytes&gt;</code> in L1 beacon chain req-resp protocols.</p>
<p>Each segment starts with a <code>/</code>, and may contain multiple <code>/</code>, and the final protocol ID is suffixed with a <code>/</code>.</p>
<h3 id="payload_by_number"><a class="header" href="#payload_by_number"><code>payload_by_number</code></a></h3>
<p>This is an optional chain syncing method, to request/serve execution payloads by number.
This serves as a method to fill gaps upon missed gossip, and sync short to medium ranges of unsafe L2 blocks.</p>
<p>Protocol ID: <code>/opstack/req/payload_by_number/&lt;chain-id&gt;/0/</code></p>
<ul>
<li><code>/MessageName</code> is <code>/block_by_number/&lt;chain-id&gt;</code> where <code>&lt;chain-id&gt;</code> is set to the op-node L2 chain ID.</li>
<li><code>/SchemaVersion</code> is <code>/0</code></li>
</ul>
<p>Request format: <code>&lt;num&gt;</code>: a little-endian <code>uint64</code> - the block number to request.</p>
<p>Response format: <code>&lt;response&gt; = &lt;res&gt;&lt;version&gt;&lt;payload&gt;</code></p>
<ul>
<li><code>&lt;res&gt;</code> is a byte code describing the result.
<ul>
<li><code>0</code> on success, <code>&lt;version&gt;&lt;payload&gt;</code> should follow.</li>
<li><code>1</code> if valid request, but unavailable payload.</li>
<li><code>2</code> if invalid request</li>
<li><code>3+</code> if other error</li>
<li>The <code>&gt;= 128</code> range is reserved for future use.</li>
</ul>
</li>
<li><code>&lt;version&gt;</code> is a little-endian <code>uint32</code>, identifying the response type (fork-specific)</li>
<li><code>&lt;payload&gt;</code> is an encoded block, read till stream EOF.</li>
</ul>
<p>The input of <code>&lt;response&gt;</code> should be limited, as well as any generated decompressed output,
to avoid unexpected resource usage or zip-bomb type attacks.
A 10 MB limit is recommended, to ensure all blocks may be synced.
Implementations may opt for a different limit, since this sync method is optional.</p>
<p><code>&lt;version&gt;</code> list:</p>
<ul>
<li><code>0</code>: SSZ-encoded <code>ExecutionPayload</code>, with Snappy framing compression,
matching the <code>ExecutionPayload</code> SSZ definition of the L1 Merge, L2 Bedrock and L2 Regolith, L2 Canyon versions.</li>
<li><code>1</code>: SSZ-encoded <code>ExecutionPayloadEnvelope</code> with Snappy framing compression,
matching the <code>ExecutionPayloadEnvelope</code> SSZ definition of the L2 Ecotone version.</li>
</ul>
<p>The request is by block-number, enabling parallel fetching of a chain across many peers.</p>
<p>A <code>res = 0</code> response should be verified to:</p>
<ul>
<li>Have a block-number matching the requested block number.</li>
<li>Have a consistent <code>blockhash</code> w.r.t. the other block contents.</li>
<li>Build towards a known canonical block.
<ul>
<li>This can be verified by checking if the parent-hash of a previous trusted canonical block matches
that of the verified hash of the retrieved block.</li>
<li>For unsafe blocks this may be relaxed to verification against the parent-hash of any previously trusted block:
<ul>
<li>The gossip validation process limits the amount of blocks that may be trusted to sync towards.</li>
<li>The unsafe blocks should be queued for processing, the latest received L2 unsafe blocks should always
override any previous chain, until the final L2 chain can be reproduced from L1 data.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A <code>res &gt; 0</code> response code should not be accepted. The result code is helpful for debugging,
but the client should regard any error like any other unanswered request, as the responding peer cannot be trusted.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="l2-chain-derivation-specification"><a class="header" href="#l2-chain-derivation-specification">L2 Chain Derivation Specification</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/derivation.html#overview">Overview</a>
<ul>
<li><a href="protocol/derivation.html#eager-block-derivation">Eager Block Derivation</a></li>
</ul>
</li>
<li><a href="protocol/derivation.html#batch-submission">Batch Submission</a>
<ul>
<li><a href="protocol/derivation.html#sequencing--batch-submission-overview">Sequencing &amp; Batch Submission Overview</a></li>
<li><a href="protocol/derivation.html#batch-submission-wire-format">Batch Submission Wire Format</a>
<ul>
<li><a href="protocol/derivation.html#batcher-transaction-format">Batcher Transaction Format</a></li>
<li><a href="protocol/derivation.html#frame-format">Frame Format</a></li>
<li><a href="protocol/derivation.html#channel-format">Channel Format</a></li>
<li><a href="protocol/derivation.html#batch-format">Batch Format</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/derivation.html#architecture">Architecture</a>
<ul>
<li><a href="protocol/derivation.html#l2-chain-derivation-pipeline">L2 Chain Derivation Pipeline</a>
<ul>
<li><a href="protocol/derivation.html#l1-traversal">L1 Traversal</a></li>
<li><a href="protocol/derivation.html#l1-retrieval">L1 Retrieval</a>
<ul>
<li><a href="protocol/derivation.html#ecotone-blob-retrieval">Ecotone: Blob Retrieval</a>
<ul>
<li><a href="protocol/derivation.html#blob-encoding">Blob Encoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/derivation.html#frame-queue">Frame Queue</a></li>
<li><a href="protocol/derivation.html#channel-bank">Channel Bank</a>
<ul>
<li><a href="protocol/derivation.html#pruning">Pruning</a></li>
<li><a href="protocol/derivation.html#timeouts">Timeouts</a></li>
<li><a href="protocol/derivation.html#reading">Reading</a></li>
<li><a href="protocol/derivation.html#loading-frames">Loading frames</a></li>
</ul>
</li>
<li><a href="protocol/derivation.html#channel-reader-batch-decoding">Channel Reader (Batch Decoding)</a></li>
<li><a href="protocol/derivation.html#batch-queue">Batch Queue</a></li>
<li><a href="protocol/derivation.html#payload-attributes-derivation">Payload Attributes Derivation</a></li>
<li><a href="protocol/derivation.html#engine-queue">Engine Queue</a>
<ul>
<li><a href="protocol/derivation.html#engine-api-usage">Engine API usage</a>
<ul>
<li><a href="protocol/derivation.html#bedrock-canyon-delta-api-usage">Bedrock, Canyon, Delta: API Usage</a></li>
<li><a href="protocol/derivation.html#ecotone-api-usage">Ecotone: API Usage</a></li>
</ul>
</li>
<li><a href="protocol/derivation.html#forkchoice-synchronization">Forkchoice synchronization</a></li>
<li><a href="protocol/derivation.html#l1-consolidation-payload-attributes-matching">L1-consolidation: payload attributes matching</a></li>
<li><a href="protocol/derivation.html#l1-sync-payload-attributes-processing">L1-sync: payload attributes processing</a></li>
<li><a href="protocol/derivation.html#processing-unsafe-payload-attributes">Processing unsafe payload attributes</a></li>
</ul>
</li>
<li><a href="protocol/derivation.html#resetting-the-pipeline">Resetting the Pipeline</a>
<ul>
<li><a href="protocol/derivation.html#finding-the-sync-starting-point">Finding the sync starting point</a></li>
<li><a href="protocol/derivation.html#resetting-derivation-stages">Resetting derivation stages</a></li>
<li><a href="protocol/derivation.html#about-reorgs-post-merge">About reorgs Post-Merge</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/derivation.html#deriving-payload-attributes">Deriving Payload Attributes</a>
<ul>
<li><a href="protocol/derivation.html#deriving-the-transaction-list">Deriving the Transaction List</a>
<ul>
<li><a href="protocol/derivation.html#network-upgrade-automation-transactions">Network upgrade automation transactions</a>
<ul>
<li><a href="protocol/derivation.html#ecotone">Ecotone</a>
<ul>
<li><a href="protocol/derivation.html#l1block-deployment">L1Block Deployment</a></li>
<li><a href="protocol/derivation.html#gaspriceoracle-deployment">GasPriceOracle Deployment</a></li>
<li><a href="protocol/derivation.html#l1block-proxy-update">L1Block Proxy Update</a></li>
<li><a href="protocol/derivation.html#gaspriceoracle-proxy-update">GasPriceOracle Proxy Update</a></li>
<li><a href="protocol/derivation.html#gaspriceoracle-enable-ecotone">GasPriceOracle Enable Ecotone</a></li>
<li><a href="protocol/derivation.html#beacon-block-roots-contract-deployment-eip-4788">Beacon block roots contract deployment (EIP-4788)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/derivation.html#building-individual-payload-attributes">Building Individual Payload Attributes</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<h1 id="overview-9"><a class="header" href="#overview-9">Overview</a></h1>
<blockquote>
<p><strong>Note</strong> the following assumes a single sequencer and batcher. In the future, the design will be adapted to
accommodate multiple such entities.</p>
</blockquote>
<p><a href="protocol/../glossary.html#L2-chain-derivation">L2 chain derivation</a> â€” deriving L2 <a href="protocol/../glossary.html#block">blocks</a> from L1 data â€” is one of the main responsibilities
of the <a href="protocol/../glossary.html#rollup-node">rollup node</a>, both in validator mode, and in sequencer mode (where derivation acts as a sanity
check on sequencing, and enables detecting L1 chain <a href="protocol/../glossary.html#chain-re-organization">re-organizations</a>).</p>
<p>The L2 chain is derived from the L1 chain. In particular, each L1 block following <a href="protocol/../glossary.html#L2-chain-inception">L2 chain
inception</a> is mapped to a <a href="protocol/../glossary.html#sequencing-epoch">sequencing epoch</a> comprising
at least one L2 block. Each L2 block belongs to exactly one epoch, and we call the corresponding L1
block its <a href="protocol/../glossary.html#l1-origin">L1 origin</a>. The epoch's number equals that of its L1 origin block.</p>
<p>To derive the L2 blocks of epoch number <code>E</code>, we need the following inputs:</p>
<ul>
<li>L1 blocks in the range <code>[E, E + SWS)</code>, called the <a href="protocol/../glossary.html#sequencing-window">sequencing window</a> of the epoch, and <code>SWS</code>
the sequencing window size. (Note that sequencing windows overlap.)</li>
<li><a href="protocol/../glossary.html#batcher-transaction">Batcher transactions</a> from blocks in the sequencing window.
<ul>
<li>These transactions allow us to reconstruct the epoch's <a href="protocol/../glossary.html#sequencer-batch">sequencer batches</a>, each of
which will produce one L2 block. Note that:
<ul>
<li>The L1 origin will never contain any data needed to construct sequencer batches since
each batch <a href="protocol/derivation.html#batch-format">must contain</a> the L1 origin hash.</li>
<li>An epoch may have no sequencer batches.</li>
</ul>
</li>
</ul>
</li>
<li><a href="protocol/../glossary.html#deposits">Deposits</a> made in the L1 origin (in the form of events emitted by the <a href="protocol/../glossary.html#deposit-contract">deposit
contract</a>).</li>
<li>L1 block attributes from the L1 origin (to derive the <a href="protocol/../glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a>).</li>
<li>The state of the L2 chain after the last L2 block of the previous epoch, or the <a href="protocol/../glossary.html#l2-genesis-block">L2 genesis state</a>
if <code>E</code> is the first epoch.</li>
</ul>
<p>To derive the whole L2 chain from scratch, we start with the <a href="protocol/../glossary.html#l2-genesis-block">L2 genesis state</a> and
the <a href="protocol/../glossary.html#l2-genesis-block">L2 genesis block</a> as the first L2 block. We then derive L2 blocks from each epoch in order,
starting at the first L1 block following <a href="protocol/../glossary.html#L2-chain-inception">L2 chain inception</a>. Refer to the
<a href="protocol/derivation.html#architecture">Architecture section</a> for more information on how we implement this in practice.
The L2 chain may contain pre-Bedrock history, but the L2 genesis here refers to the Bedrock L2
genesis block.</p>
<p>Each L2 <code>block</code> with origin <code>l1_origin</code> is subject to the following constraints (whose values are
denominated in seconds):</p>
<ul>
<li>
<p><code>block.timestamp = prev_l2_timestamp + l2_block_time</code></p>
<ul>
<li><code>prev_l2_timestamp</code> is the timestamp of the L2 block immediately preceding this one. If there
is no preceding block, then this is the genesis block, and its timestamp is explicitly
specified.</li>
<li><code>l2_block_time</code> is a configurable parameter of the time between L2 blocks (2s on Optimism).</li>
</ul>
</li>
<li>
<p><code>l1_origin.timestamp &lt;= block.timestamp &lt;= max_l2_timestamp</code>, where</p>
<ul>
<li><code>max_l2_timestamp = max(l1_origin.timestamp + max_sequencer_drift, prev_l2_timestamp + l2_block_time)</code>
<ul>
<li><code>max_sequencer_drift</code> is a configurable parameter that bounds how far the sequencer can get ahead of
the L1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Finally, each epoch must have at least one L2 block.</p>
<p>The first constraint means there must be an L2 block every <code>l2_block_time</code> seconds following L2
chain inception.</p>
<p>The second constraint ensures that an L2 block timestamp never precedes its L1 origin timestamp,
and is never more than <code>max_sequencer_drift</code> ahead of it, except only in the unusual case where it
might prohibit an L2 block from being produced every l2_block_time seconds. (Such cases might arise
for example under a proof-of-work L1 that sees a period of rapid L1 block production.) In either
case, the sequencer enforces <code>len(batch.transactions) == 0</code> while <code>max_sequencer_drift</code> is
exceeded. See <a href="protocol/derivation.html#batch-queue">Batch Queue</a> for more details.</p>
<p>The final requirement that each epoch must have at least one L2 block ensures that all relevant
information from the L1 (e.g. deposits) is represented in the L2, even if it has no sequencer
batches.</p>
<p>Post-merge, Ethereum has a fixed 12s <a href="protocol/../glossary.html#block-time">block time</a>, though some slots can be
skipped. Under a 2s L2 block time, we thus expect each epoch to typically contain <code>12/2 = 6</code> L2
blocks. The sequencer will however produce bigger epochs in order to maintain liveness in case of
either a skipped slot on the L1 or a temporary loss of connection to it. For the lost connection
case, smaller epochs might be produced after the connection was restored to keep L2 timestamps from
drifting further and further ahead.</p>
<h2 id="eager-block-derivation"><a class="header" href="#eager-block-derivation">Eager Block Derivation</a></h2>
<p>Deriving an L2 block requires that we have constructed its sequencer batch and derived all L2
blocks and state updates prior to it. This means we can typically derive the L2 blocks of an epoch
<em>eagerly</em> without waiting on the full sequencing window. The full sequencing window is required
before derivation only in the very worst case where some portion of the sequencer batch for the
first block of the epoch appears in the very last L1 block of the window. Note that this only
applies to <em>block</em> derivation. Sequencer batches can still be derived and tentatively queued
without deriving blocks from them.</p>
<hr />
<h1 id="batch-submission"><a class="header" href="#batch-submission">Batch Submission</a></h1>
<h2 id="sequencing--batch-submission-overview"><a class="header" href="#sequencing--batch-submission-overview">Sequencing &amp; Batch Submission Overview</a></h2>
<p>The <a href="protocol/../glossary.html#sequencer">sequencer</a> accepts L2 transactions from users. It is responsible for building blocks out of these. For
each such block, it also creates a corresponding <a href="protocol/../glossary.html#sequencer-batch">sequencer batch</a>. It is also responsible for
submitting each batch to a <a href="protocol/../glossary.html#data-availability-provider">data availability provider</a> (e.g. Ethereum calldata), which it does via
its <a href="protocol/../glossary.html#batcher">batcher</a> component.</p>
<p>The difference between an L2 block and a batch is subtle but important: the block includes an L2 state root, whereas the
batch only commits to transactions at a given L2 timestamp (equivalently: L2 block number). A block also includes a
reference to the previous block (*).</p>
<p>(*) This matters in some edge case where a L1 reorg would occur and a batch would be reposted to the L1 chain but not
the preceding batch, whereas the predecessor of an L2 block cannot possibly change.</p>
<p>This means that even if the sequencer applies a state transition incorrectly, the transactions in the batch will still
be considered part of the canonical L2 chain. Batches are still subject to validity checks (i.e. they have to be encoded
correctly), and so are individual transactions within the batch (e.g. signatures have to be valid). Invalid batches and
invalid individual transactions within an otherwise valid batch are discarded by correct nodes.</p>
<p>If the sequencer applies a state transition incorrectly and posts an <a href="protocol/../glossary.html#l2-output-root">output root</a>, then this output root
will be incorrect. The incorrect output root which will be challenged by a <a href="protocol/../glossary.html#fault-proof">fault proof</a>, then replaced
by a correct output root <strong>for the existing sequencer batches.</strong></p>
<p>Refer to the <a href="protocol/batcher.html">Batch Submission specification</a> for more information.</p>
<h2 id="batch-submission-wire-format"><a class="header" href="#batch-submission-wire-format">Batch Submission Wire Format</a></h2>
<p>Batch submission is closely tied to L2 chain derivation because the derivation process must decode the batches that have
been encoded for the purpose of batch submission.</p>
<p>The <a href="protocol/../glossary.html#batcher">batcher</a> submits <a href="protocol/../glossary.html#batcher-transaction">batcher transactions</a> to a <a href="protocol/../glossary.html#data-availability-provider">data availability
provider</a>. These transactions contain one or multiple <a href="protocol/../glossary.html#channel-frame">channel frames</a>, which are
chunks of data belonging to a <a href="protocol/../glossary.html#channel">channel</a>.</p>
<p>A <a href="protocol/../glossary.html#channel">channel</a> is a sequence of <a href="protocol/../glossary.html#sequencer-batch">sequencer batches</a> (for any L2 blocks) compressed
together. The reason to group multiple batches together is simply to obtain a better compression rate, hence reducing
data availability costs.</p>
<p>Channels might be too large to fit in a single <a href="protocol/../glossary.html#batcher-transaction">batcher transaction</a>, hence we need to split it
into chunks known as <a href="protocol/../glossary.html#channel-frame">channel frames</a>. A single batcher transaction can also carry multiple frames
(belonging to the same or to different channels).</p>
<p>This design gives use the maximum flexibility in how we aggregate batches into channels, and split channels over batcher
transactions. It notably allows us to maximize data utilisation in a batcher transaction: for instance it allows us to
pack the final (small) frame of a window with large frames from the next window.</p>
<p>In the future this channel identification feature also allows the <a href="protocol/../glossary.html#batcher">batcher</a> to employ multiple signers
(private keys) to submit one or multiple channels in parallel (1).</p>
<p>(1) This helps alleviate issues where, because of transaction nonce values affecting the L2 tx-pool and thus inclusion:
multiple transactions made by the same signer are stuck waiting on the inclusion of a previous transaction.</p>
<p>Also note that we use a streaming compression scheme, and we do not need to know how many blocks a channel will end up
containing when we start a channel, or even as we send the first frames in the channel.</p>
<p>And by splitting channels across multiple data transactions, the L2 can have larger block data than the
data-availability layer may support.</p>
<p>All of this is illustrated in the following diagram. Explanations below.</p>
<p><img src="protocol/../static/assets/batch-deriv-chain.svg" alt="batch derivation chain diagram" /></p>
<p>The first line represents L1 blocks with their numbers. The boxes under the L1 blocks represent <a href="protocol/../glossary.html#batcher-transaction">batcher
transactions</a> included within the block. The squiggles under the L1 blocks represent
<a href="protocol/../glossary.html#deposits">deposits</a> (more specifically, events emitted by the <a href="protocol/../glossary.html#deposit-contract">deposit contract</a>).</p>
<p>Each colored chunk within the boxes represents a <a href="protocol/../glossary.html#channel-frame">channel frame</a>. So <code>A</code> and <code>B</code> are
<a href="protocol/../glossary.html#channel">channels</a> whereas <code>A0</code>, <code>A1</code>, <code>B0</code>, <code>B1</code>, <code>B2</code> are frames. Notice that:</p>
<ul>
<li>multiple channels are interleaved</li>
<li>frames do not need to be transmitted in order</li>
<li>a single batcher transaction can carry frames from multiple channels</li>
</ul>
<p>In the next line, the rounded boxes represent individual <a href="protocol/../glossary.html#sequencer-batch">sequencer batches</a> that were extracted from
the channels. The four blue/purple/pink were derived from channel <code>A</code> while the other were derived from channel <code>B</code>.
These batches are here represented in the order they were decoded from batches (in this case <code>B</code> is decoded first).</p>
<blockquote>
<p><strong>Note</strong> The caption here says &quot;Channel B was seen first and will be decoded into batches first&quot;, but this is not a
requirement. For instance, it would be equally acceptable for an implementation to peek into the channels and decode
the one that contains the oldest batches first.</p>
</blockquote>
<p>The rest of the diagram is conceptually distinct from the first part and illustrates L2 chain derivation after the
channels have been reordered.</p>
<p>The first line shows batcher transactions. Note that in this case, there exists an ordering of the batches that makes
all frames within the channels appear contiguously. This is not true in general. For instance, in the second
transaction, the position of <code>A1</code> and <code>B0</code> could have been inverted for exactly the same result â€” no changes needed in
the rest of the diagram.</p>
<p>The second line shows the reconstructed channels in proper order. The third line shows the batches extracted from the
channel. Because the channels are ordered and the batches within a channel are sequential, this means the batches are
ordered too. The fourth line shows the <a href="protocol/../glossary.html#block">L2 block</a> derived from each batch. Note that we have a 1-1 batch to
block mapping here but, as we'll see later, empty blocks that do not map to batches can be inserted in cases where there
are &quot;gaps&quot; in the batches posted on L1.</p>
<p>The fifth line shows the <a href="protocol/../glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a> which, within each L2 block, records
information about the L1 block that matches the L2 block's epoch. The first number denotes the epoch/L1x number, while
the second number (the &quot;sequence number&quot;) denotes the position within the epoch.</p>
<p>Finally, the sixth line shows <a href="protocol/../glossary.html#user-deposited-transaction">user-deposited transactions</a> derived from the <a href="protocol/../glossary.html#deposit-contract">deposit
contract</a> event mentioned earlier.</p>
<p>Note the <code>101-0</code> L1 attributes transaction on the bottom right of the diagram. Its presence there is only possible if
frame <code>B2</code> indicates that it is the last frame within the channel and (2) no empty blocks must be inserted.</p>
<p>The diagram does not specify the sequencing window size in use, but from this we can infer that it must be at least 4
blocks, because the last frame of channel <code>A</code> appears in block 102, but belong to epoch 99.</p>
<p>As for the comment on &quot;security types&quot;, it explains the classification of blocks as used on L1 and L2.</p>
<ul>
<li><a href="protocol/../glossary.html#unsafe-l2-block">Unsafe L2 blocks</a>:</li>
<li><a href="protocol/../glossary.html#safe-l2-block">Safe L2 blocks</a>:</li>
<li>Finalized L2 blocks: refer to block that have been derived from <a href="protocol/../glossary.html#finalized-l2-head">finalized</a> L1 data.</li>
</ul>
<p>These security levels map to the <code>headBlockHash</code>, <code>safeBlockHash</code> and <code>finalizedBlockHash</code> values transmitted when
interacting with the <a href="protocol/exec-engine.html">execution-engine API</a>.</p>
<h3 id="batcher-transaction-format"><a class="header" href="#batcher-transaction-format">Batcher Transaction Format</a></h3>
<p>Batcher transactions are encoded as <code>version_byte ++ rollup_payload</code> (where <code>++</code> denotes concatenation).</p>
<div class="table-wrapper"><table><thead><tr><th><code>version_byte</code></th><th><code>rollup_payload</code></th></tr></thead><tbody>
<tr><td>0</td><td><code>frame ...</code> (one or more frames, concatenated)</td></tr>
</tbody></table>
</div>
<p>Unknown versions make the batcher transaction invalid (it must be ignored by the rollup node).
All frames in a batcher transaction must be parseable. If any one frame fails to parse, the all frames in the
transaction are rejected.</p>
<p>Batch transactions are authenticated by verifying that the <code>to</code> address of the transaction matches the batch inbox
address, and the <code>from</code> address matches the batch-sender address in the <a href="protocol/../glossary.html#system-configuration">system configuration</a> at the
time of the L1 block that the transaction data is read from.</p>
<h3 id="frame-format"><a class="header" href="#frame-format">Frame Format</a></h3>
<p>A <a href="protocol/../glossary.html#channel-frame">channel frame</a> is encoded as:</p>
<pre><code class="language-text">frame = channel_id ++ frame_number ++ frame_data_length ++ frame_data ++ is_last

channel_id        = bytes16
frame_number      = uint16
frame_data_length = uint32
frame_data        = bytes
is_last           = bool
</code></pre>
<p>Where <code>uint32</code> and <code>uint16</code> are all big-endian unsigned integers. Type names should be interpreted to and
encoded according to <a href="https://docs.soliditylang.org/en/v0.8.16/abi-spec.html">the Solidity ABI</a>.</p>
<p>All data in a frame is fixed-size, except the <code>frame_data</code>. The fixed overhead is <code>16 + 2 + 4 + 1 = 23 bytes</code>.
Fixed-size frame metadata avoids a circular dependency with the target total data length,
to simplify packing of frames with varying content length.</p>
<p>where:</p>
<ul>
<li><code>channel_id</code> is an opaque identifier for the channel. It should not be reused and is suggested to be random; however,
outside of timeout rules, it is not checked for validity</li>
<li><code>frame_number</code> identifies the index of the frame within the channel</li>
<li><code>frame_data_length</code> is the length of <code>frame_data</code> in bytes. It is capped to 1,000,000 bytes.</li>
<li><code>frame_data</code> is a sequence of bytes belonging to the channel, logically after the bytes from the previous frames</li>
<li><code>is_last</code> is a single byte with a value of 1 if the frame is the last in the channel, 0 if there are frames in the
channel. Any other value makes the frame invalid (it must be ignored by the rollup node).</li>
</ul>
<h3 id="channel-format"><a class="header" href="#channel-format">Channel Format</a></h3>
<p>A channel is encoded as <code>channel_encoding</code>, defined as:</p>
<pre><code class="language-text">rlp_batches = []
for batch in batches:
    rlp_batches.append(batch)
channel_encoding = compress(rlp_batches)
</code></pre>
<p>where:</p>
<ul>
<li><code>batches</code> is the input, a sequence of batches byte-encoded as per the next section (&quot;Batch Encoding&quot;)</li>
<li><code>rlp_batches</code> is the concatenation of the RLP-encoded batches</li>
<li><code>compress</code> is a function performing compression, using the ZLIB algorithm (as specified in <a href="https://www.rfc-editor.org/rfc/rfc1950.html">RFC-1950</a>) with
no dictionary</li>
<li><code>channel_encoding</code> is the compressed version of <code>rlp_batches</code></li>
</ul>
<p>When decompressing a channel, we limit the amount of decompressed data to <code>MAX_RLP_BYTES_PER_CHANNEL</code> (currently
10,000,000 bytes), in order to avoid &quot;zip-bomb&quot; types of attack (where a small compressed input decompresses to a
humongous amount of data). If the decompressed data exceeds the limit, things proceeds as though the channel contained
only the first <code>MAX_RLP_BYTES_PER_CHANNEL</code> decompressed bytes. The limit is set on RLP decoding, so all batches that
can be decoded in <code>MAX_RLP_BYTES_PER_CHANNEL</code> will be accepted even if the size of the channel is greater than
<code>MAX_RLP_BYTES_PER_CHANNEL</code>. The exact requirement is that <code>length(input) &lt;= MAX_RLP_BYTES_PER_CHANNEL</code>.</p>
<p>While the above pseudocode implies that all batches are known in advance, it is possible to perform streaming
compression and decompression of RLP-encoded batches. This means it is possible to start including channel frames in a
<a href="protocol/../glossary.html#batcher-transaction">batcher transaction</a> before we know how many batches (and how many frames) the channel will
contain.</p>
<h3 id="batch-format"><a class="header" href="#batch-format">Batch Format</a></h3>
<p>Recall that a batch contains a list of transactions to be included in a specific L2 block.</p>
<p>A batch is encoded as <code>batch_version ++ content</code>, where <code>content</code> depends on the <code>batch_version</code>:</p>
<div class="table-wrapper"><table><thead><tr><th><code>batch_version</code></th><th><code>content</code></th></tr></thead><tbody>
<tr><td>0</td><td><code>rlp_encode([parent_hash, epoch_number, epoch_hash, timestamp, transaction_list])</code></td></tr>
</tbody></table>
</div>
<p>where:</p>
<ul>
<li><code>batch_version</code> is a single byte, prefixed before the RLP contents, alike to transaction typing.</li>
<li><code>rlp_encode</code> is a function that encodes a batch according to the <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/">RLP format</a>, and <code>[x, y, z]</code> denotes a list
containing items <code>x</code>, <code>y</code> and <code>z</code></li>
<li><code>parent_hash</code> is the block hash of the previous L2 block</li>
<li><code>epoch_number</code> and <code>epoch_hash</code> are the number and hash of the L1 block corresponding to the <a href="protocol/../glossary.html#sequencing-epoch">sequencing
epoch</a> of the L2 block</li>
<li><code>timestamp</code> is the timestamp of the L2 block</li>
<li><code>transaction_list</code> is an RLP-encoded list of <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a> encoded transactions.</li>
</ul>
<p>Unknown versions make the batch invalid (it must be ignored by the rollup node), as do malformed contents.</p>
<p>The <code>epoch_number</code> and the <code>timestamp</code> must also respect the constraints listed in the <a href="protocol/derivation.html#batch-queue">Batch Queue</a>
section, otherwise the batch is considered invalid and will be ignored.</p>
<hr />
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The above primarily describes the general encodings used in L2 chain derivation,
primarily how batches are encoded within <a href="protocol/../glossary.html#batcher-transaction">batcher transactions</a>.</p>
<p>This section describes how the L2 chain is produced from the L1 batches using a pipeline architecture.</p>
<p>A verifier may implement this differently, but must be semantically equivalent to not diverge from the L2 chain.</p>
<h2 id="l2-chain-derivation-pipeline"><a class="header" href="#l2-chain-derivation-pipeline">L2 Chain Derivation Pipeline</a></h2>
<p>Our architecture decomposes the derivation process into a pipeline made up of the following stages:</p>
<ol>
<li>L1 Traversal</li>
<li>L1 Retrieval</li>
<li>Frame Queue</li>
<li>Channel Bank</li>
<li>Channel Reader (Batch Decoding)</li>
<li>Batch Queue</li>
<li>Payload Attributes Derivation</li>
<li>Engine Queue</li>
</ol>
<p>The data flows from the start (outer) of the pipeline towards the end (inner).
From the innermost stage the data is pulled from the outermost stage.</p>
<p>However, data is <em>processed</em> in reverse order. Meaning that if there is any data to be processed in the last stage, it
will be processed first. Processing proceeds in &quot;steps&quot; that can be taken at each stage. We try to take as many steps as
possible in the last (most inner) stage before taking any steps in its outer stage, etc.</p>
<p>This ensures that we use the data we already have before pulling more data and minimizes the latency of data traversing
the derivation pipeline.</p>
<p>Each stage can maintain its own inner state as necessary. In particular, each stage maintains a L1 block reference
(number + hash) to the latest L1 block such that all data originating from previous blocks has been fully processed, and
the data from that block is being or has been processed. This allows the innermost stage to account for finalization of
the L1 data-availability used to produce the L2 chain, to reflect in the L2 chain forkchoice when the L2 chain inputs
become irreversible.</p>
<p>Let's briefly describe each stage of the pipeline.</p>
<h3 id="l1-traversal"><a class="header" href="#l1-traversal">L1 Traversal</a></h3>
<p>In the <em>L1 Traversal</em> stage, we simply read the header of the next L1 block. In normal operations, these will be new
L1 blocks as they get created, though we can also read old blocks while syncing, or in case of an L1 <a href="protocol/../glossary.html#chain-re-organization">re-org</a>.</p>
<p>Upon traversal of the L1 block, the <a href="protocol/../glossary.html#system-configuration">system configuration</a> copy used by the L1 retrieval stage is
updated, such that the batch-sender authentication is always accurate to the exact L1 block that is read by the stage.</p>
<h3 id="l1-retrieval"><a class="header" href="#l1-retrieval">L1 Retrieval</a></h3>
<p>In the <em>L1 Retrieval</em> stage, we read the block we get from the outer stage (L1 traversal), and
extract data from its <a href="protocol/../glossary.html#batcher-transaction">batcher transactions</a>. A batcher
transaction is one with the following properties:</p>
<ul>
<li>
<p>The <a href="https://github.com/ethereum/execution-specs/blob/3fe6514f2d9d234e760d11af883a47c1263eff51/src/ethereum/frontier/fork_types.py#L52C31-L52C31"><code>to</code></a> field is equal to the configured batcher inbox address.</p>
</li>
<li>
<p>The sender, as recovered from the transaction signature (<code>v</code>, <code>r</code>, and <code>s</code>), is the batcher
address loaded from the system config matching the L1 block of the data.</p>
</li>
</ul>
<p>Each batcher transaction is versioned and contains a series of <a href="protocol/../glossary.html#channel-frame">channel frames</a> to
be read by the Frame Queue, see <a href="protocol/derivation.html#batch-submission-wire-format">Batch Submission Wire Format</a>. Each batcher
transaction in the block is processed in the order they appear in the block by passing its calldata
on to the next phase.</p>
<h4 id="ecotone-blob-retrieval"><a class="header" href="#ecotone-blob-retrieval">Ecotone: Blob Retrieval</a></h4>
<p>With the Ecotone upgrade the retrieval stage is extended to support an additional DA source:
<a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a> blobs. After the Ecotone upgrade we modify the iteration over batcher transactions to
treat transactions of transaction-type == <code>0x03</code> (<code>BLOB_TX_TYPE</code>) differently. If the batcher
transaction is a blob transaction, then its calldata MUST be ignored should it be present. Instead:</p>
<ul>
<li>For each blob hash in <code>blob_versioned_hashes</code>, retrieve the blob that matches it. A blob may be
retrieved from any of a number different sources. Retrieval from a local beacon-node, through
the <code>/eth/v1/beacon/blob_sidecars/</code> endpoint, with <code>indices</code> filter to skip unrelated blobs, is
recommended. For each retrieved blob:
<ul>
<li>The blob SHOULD (MUST, if the source is untrusted) be cryptographically verified against its
versioned hash.</li>
<li>If the blob has a <a href="protocol/derivation.html#blob-encoding">valid encoding</a>, decode it into its continuous byte-string
and pass that on to the next phase. Otherwise the blob is ignored.</li>
</ul>
</li>
</ul>
<p>Note that batcher transactions of type blob must be processed in the same loop as other batcher
transactions to preserve the invariant that batches are always processed in the order they appear
in the block. We ignore calldata in blob transactions so that it may be used in the future for
batch metadata or other purposes.</p>
<h5 id="blob-encoding"><a class="header" href="#blob-encoding">Blob Encoding</a></h5>
<p>Each blob in a <a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a> transaction really consists of <code>FIELD_ELEMENTS_PER_BLOB = 4096</code> field elements.</p>
<p>Each field element is a number in a prime field of
<code>BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513</code>.
This number does not represent a full <code>uint256</code>: <code>math.log2(BLS_MODULUS) = 254.8570894...</code></p>
<p>The <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md">L1 consensus-specs</a>
describe the encoding of this polynomial.
The field elements are encoded as big-endian integers (<code>KZG_ENDIANNESS = big</code>).</p>
<p>To save computational overhead, only <code>254</code> bits per field element are used for rollup data.</p>
<p><code>127</code> bytes of application-layer rollup data is encoded at a time, into 4 adjacent field elements of the blob:</p>
<pre><code class="language-python"># read(N): read the next N bytes from the application-layer rollup-data. The next read starts where the last stopped.
# write(V): append V (one or more bytes) to the raw blob.
bytes tailA = read(31)
byte x = read(1)
byte A = x &amp; 0b0011_1111
write(A)
write(tailA)

bytes tailB = read(31)
byte y = read(1)
byte B = (y &amp; 0b0000_1111) | (x &amp; 0b1100_0000) &gt;&gt; 2)
write(B)
write(tailB)

bytes tailC = read(31)
byte z = read(1)
byte C = z &amp; 0b0011_1111
write(C)
write(tailC)

bytes tailD = read(31)
byte D = ((z &amp; 0b1100_0000) &gt;&gt; 2) | ((y &amp; 0b1111_0000) &gt;&gt; 4)
write(D)
write(tailD)
</code></pre>
<p>Each written field element looks like this:</p>
<ul>
<li>Starts with one of the prepared 6-bit left-padded byte values, to keep the field element within valid range.</li>
<li>Followed by 31 bytes of application-layer data, to fill the low 31 bytes of the field element.</li>
</ul>
<p>The written output should look like this:</p>
<pre><code class="language-text">&lt;----- element 0 -----&gt;&lt;----- element 1 -----&gt;&lt;----- element 2 -----&gt;&lt;----- element 3 -----&gt;
| byte A |  tailA...  || byte B |  tailB...  || byte C |  tailC...  || byte D |  tailD...  |
</code></pre>
<p>The above is repeated 1024 times, to fill all <code>4096</code> elements,
with a total of <code>(4 * 31 + 3) * 1024 = 130048</code> bytes of data.</p>
<p>When decoding a blob, the top-most two bits of each field-element must be 0,
to make the encoding/decoding bijective.</p>
<p>The first byte of rollup-data (second byte in first field element) is used as a version-byte.</p>
<p>In version <code>0</code>, the next 3 bytes of data are used to encode the length of the rollup-data, as big-endian <code>uint24</code>.
Any trailing data, past the length delimiter, must be 0, to keep the encoding/decoding bijective.
If the length is larger than <code>130048 - 4</code>, the blob is invalid.</p>
<p>If any of the encoding is invalid, the blob as whole must be ignored.</p>
<h3 id="frame-queue"><a class="header" href="#frame-queue">Frame Queue</a></h3>
<p>The Frame Queue buffers one data-transaction at a time,
decoded into <a href="protocol/../glossary.html#channel-frame">channel frames</a>, to be consumed by the next stage.
See <a href="protocol/derivation.html#batcher-transaction-format">Batcher transaction format</a> and <a href="protocol/derivation.html#frame-format">Frame format</a> specifications.</p>
<h3 id="channel-bank"><a class="header" href="#channel-bank">Channel Bank</a></h3>
<p>The <em>Channel Bank</em> stage is responsible for managing buffering from the channel bank that was written to by the L1
retrieval stage. A step in the channel bank stage tries to read data from channels that are &quot;ready&quot;.</p>
<p>Channels are currently fully buffered until read or dropped,
streaming channels may be supported in a future version of the ChannelBank.</p>
<p>To bound resource usage, the Channel Bank prunes based on channel size, and times out old channels.</p>
<p>Channels are recorded in FIFO order in a structure called the <em>channel queue</em>. A channel is added to the channel
queue the first time a frame belonging to the channel is seen.</p>
<h4 id="pruning"><a class="header" href="#pruning">Pruning</a></h4>
<p>After successfully inserting a new frame, the ChannelBank is pruned:
channels are dropped in FIFO order, until <code>total_size &lt;= MAX_CHANNEL_BANK_SIZE</code>, where:</p>
<ul>
<li><code>total_size</code> is the sum of the sizes of each channel, which is the sum of all buffered frame data of the channel,
with an additional frame-overhead of <code>200</code> bytes per frame.</li>
<li><code>MAX_CHANNEL_BANK_SIZE</code> is a protocol constant of 100,000,000 bytes.</li>
</ul>
<h4 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h4>
<p>The L1 origin that the channel was opened in is tracked with the channel as <code>channel.open_l1_block</code>,
and determines the maximum span of L1 blocks that the channel data is retained for, before being pruned.</p>
<p>A channel is timed out if: <code>current_l1_block.number &gt; channel.open_l1_block.number + CHANNEL_TIMEOUT</code>, where:</p>
<ul>
<li><code>current_l1_block</code> is the L1 origin that the stage is currently traversing.</li>
<li><code>CHANNEL_TIMEOUT</code> is a rollup-configurable, expressed in number of L1 blocks.</li>
</ul>
<p>New frames for timed-out channels are dropped instead of buffered.</p>
<h4 id="reading"><a class="header" href="#reading">Reading</a></h4>
<p>Upon reading, while the first opened channel is timed-out, remove it from the channel-bank.</p>
<p>Prior to the Canyon network upgrade, once the first opened channel, if any, is not timed-out and is ready,
then it is read and removed from the channel-bank. After the Canyon network upgrade, the entire channel bank
is scanned in FIFO order (by open time) &amp; the first ready (i.e. not timed-out) channel will be returned.</p>
<p>The canyon behavior will activate when frames from a L1 block whose timestamp is greater than or equal to the
canyon time first enter the channel queue.</p>
<p>A channel is ready if:</p>
<ul>
<li>The channel is closed</li>
<li>The channel has a contiguous sequence of frames until the closing frame</li>
</ul>
<p>If no channel is ready, the next frame is read and ingested into the channel bank.</p>
<h4 id="loading-frames"><a class="header" href="#loading-frames">Loading frames</a></h4>
<p>When a channel ID referenced by a frame is not already present in the Channel Bank,
a new channel is opened, tagged with the current L1 block, and appended to the channel-queue.</p>
<p>Frame insertion conditions:</p>
<ul>
<li>New frames matching timed-out channels that have not yet been pruned from the channel-bank are dropped.</li>
<li>Duplicate frames (by frame number) for frames that have not been pruned from the channel-bank are dropped.</li>
<li>Duplicate closes (new frame <code>is_last == 1</code>, but the channel has already seen a closing frame and has not yet been
pruned from the channel-bank) are dropped.</li>
</ul>
<p>If a frame is closing (<code>is_last == 1</code>) any existing higher-numbered frames are removed from the channel.</p>
<p>Note that while this allows channel IDs to be reused once they have been pruned from the channel-bank, it is recommended
that batcher implementations use unique channel IDs.</p>
<h3 id="channel-reader-batch-decoding"><a class="header" href="#channel-reader-batch-decoding">Channel Reader (Batch Decoding)</a></h3>
<p>In this stage, we decompress the channel we pull from the last stage, and then parse
<a href="protocol/../glossary.html#sequencer-batch">batches</a> from the decompressed byte stream.</p>
<p>See <a href="protocol/derivation.html#batch-format">Batch Format</a> for decompression and decoding specification.</p>
<h3 id="batch-queue"><a class="header" href="#batch-queue">Batch Queue</a></h3>
<p>During the <em>Batch Buffering</em> stage, we reorder batches by their timestamps. If batches are missing for some <a href="protocol/../glossary.html#time-slot">time
slots</a> and a valid batch with a higher timestamp exists, this stage also generates empty batches to fill
the gaps.</p>
<p>Batches are pushed to the next stage whenever there is one sequential batch directly following the timestamp
of the current <a href="protocol/../glossary.html#safe-l2-head">safe L2 head</a> (the last block that can be derived from the canonical L1 chain).
The parent hash of the batch must also match the hash of the current safe L2 head.</p>
<p>Note that the presence of any gaps in the batches derived from L1 means that this stage will need to buffer for a whole
<a href="protocol/../glossary.html#sequencing-window">sequencing window</a> before it can generate empty batches (because the missing batch(es) could have
data in the last L1 block of the window in the worst case).</p>
<p>A batch can have 4 different forms of validity:</p>
<ul>
<li><code>drop</code>: the batch is invalid, and will always be in the future, unless we reorg. It can be removed from the buffer.</li>
<li><code>accept</code>: the batch is valid and should be processed.</li>
<li><code>undecided</code>: we are lacking L1 information until we can proceed batch filtering.</li>
<li><code>future</code>: the batch may be valid, but cannot be processed yet and should be checked again later.</li>
</ul>
<p>The batches are processed in order of the inclusion on L1: if multiple batches can be <code>accept</code>-ed the first is applied.
An implementation can defer <code>future</code> batches a later derivation step to reduce validation work.</p>
<p>The batches validity is derived as follows:</p>
<p>Definitions:</p>
<ul>
<li><code>batch</code> as defined in the <a href="protocol/derivation.html#batch-format">Batch format section</a>.</li>
<li><code>epoch = safe_l2_head.l1_origin</code> a <a href="protocol/../glossary.html#l1-origin">L1 origin</a> coupled to the batch, with properties:
<code>number</code> (L1 block number), <code>hash</code> (L1 block hash), and <code>timestamp</code> (L1 block timestamp).</li>
<li><code>inclusion_block_number</code> is the L1 block number when <code>batch</code> was first <em>fully</em> derived,
i.e. decoded and output by the previous stage.</li>
<li><code>next_timestamp = safe_l2_head.timestamp + block_time</code> is the expected L2 timestamp the next batch should have,
see <a href="protocol/../glossary.html#block-time">block time information</a>.</li>
<li><code>next_epoch</code> may not be known yet, but would be the L1 block after <code>epoch</code> if available.</li>
<li><code>batch_origin</code> is either <code>epoch</code> or <code>next_epoch</code>, depending on validation.</li>
</ul>
<p>Note that processing of a batch can be deferred until <code>batch.timestamp &lt;= next_timestamp</code>,
since <code>future</code> batches will have to be retained anyway.</p>
<p>Rules, in validation order:</p>
<ul>
<li><code>batch.timestamp &gt; next_timestamp</code> -&gt; <code>future</code>: i.e. the batch must be ready to process.</li>
<li><code>batch.timestamp &lt; next_timestamp</code> -&gt; <code>drop</code>: i.e. the batch must not be too old.</li>
<li><code>batch.parent_hash != safe_l2_head.hash</code> -&gt; <code>drop</code>: i.e. the parent hash must be equal to the L2 safe head block hash.</li>
<li><code>batch.epoch_num + sequence_window_size &lt; inclusion_block_number</code> -&gt; <code>drop</code>: i.e. the batch must be included timely.</li>
<li><code>batch.epoch_num &lt; epoch.number</code> -&gt; <code>drop</code>: i.e. the batch origin is not older than that of the L2 safe head.</li>
<li><code>batch.epoch_num == epoch.number</code>: define <code>batch_origin</code> as <code>epoch</code>.</li>
<li><code>batch.epoch_num == epoch.number+1</code>:
<ul>
<li>If <code>next_epoch</code> is not known -&gt; <code>undecided</code>:
i.e. a batch that changes the L1 origin cannot be processed until we have the L1 origin data.</li>
<li>If known, then define <code>batch_origin</code> as <code>next_epoch</code></li>
</ul>
</li>
<li><code>batch.epoch_num &gt; epoch.number+1</code> -&gt; <code>drop</code>: i.e. the L1 origin cannot change by more than one L1 block per L2 block.</li>
<li><code>batch.epoch_hash != batch_origin.hash</code> -&gt; <code>drop</code>: i.e. a batch must reference a canonical L1 origin,
to prevent batches from being replayed onto unexpected L1 chains.</li>
<li><code>batch.timestamp &lt; batch_origin.time</code> -&gt; <code>drop</code>: enforce the min L2 timestamp rule.</li>
<li><code>batch.timestamp &gt; batch_origin.time + max_sequencer_drift</code>: enforce the L2 timestamp drift rule,
but with exceptions to preserve above min L2 timestamp invariant:
<ul>
<li><code>len(batch.transactions) == 0</code>:
<ul>
<li><code>epoch.number == batch.epoch_num</code>:
this implies the batch does not already advance the L1 origin, and must thus be checked against <code>next_epoch</code>.
<ul>
<li>If <code>next_epoch</code> is not known -&gt; <code>undecided</code>:
without the next L1 origin we cannot yet determine if time invariant could have been kept.</li>
<li>If <code>batch.timestamp &gt;= next_epoch.time</code> -&gt; <code>drop</code>:
the batch could have adopted the next L1 origin without breaking the <code>L2 time &gt;= L1 time</code> invariant.</li>
</ul>
</li>
</ul>
</li>
<li><code>len(batch.transactions) &gt; 0</code>: -&gt; <code>drop</code>:
when exceeding the sequencer time drift, never allow the sequencer to include transactions.</li>
</ul>
</li>
<li><code>batch.transactions</code>: <code>drop</code> if the <code>batch.transactions</code> list contains a transaction
that is invalid or derived by other means exclusively:
<ul>
<li>any transaction that is empty (zero length byte string)</li>
<li>any <a href="protocol/../glossary.html#deposited-transaction-type">deposited transactions</a> (identified by the transaction type prefix byte)</li>
</ul>
</li>
</ul>
<p>If no batch can be <code>accept</code>-ed, and the stage has completed buffering of all batches that can fully be read from the L1
block at height <code>epoch.number + sequence_window_size</code>, and the <code>next_epoch</code> is available,
then an empty batch can be derived with the following properties:</p>
<ul>
<li><code>parent_hash = safe_l2_head.hash</code></li>
<li><code>timestamp = next_timestamp</code></li>
<li><code>transactions</code> is empty, i.e. no sequencer transactions. Deposited transactions may be added in the next stage.</li>
<li>If <code>next_timestamp &lt; next_epoch.time</code>: the current L1 origin is repeated, to preserve the L2 time invariant.
<ul>
<li><code>epoch_num = epoch.number</code></li>
<li><code>epoch_hash = epoch.hash</code></li>
</ul>
</li>
<li>If the batch is the first batch of the epoch, that epoch is used instead of advancing the epoch to ensure that
there is at least one L2 block per epoch.
<ul>
<li><code>epoch_num = epoch.number</code></li>
<li><code>epoch_hash = epoch.hash</code></li>
</ul>
</li>
<li>Otherwise,
<ul>
<li><code>epoch_num = next_epoch.number</code></li>
<li><code>epoch_hash = next_epoch.hash</code></li>
</ul>
</li>
</ul>
<h3 id="payload-attributes-derivation"><a class="header" href="#payload-attributes-derivation">Payload Attributes Derivation</a></h3>
<p>In the <em>Payload Attributes Derivation</em> stage, we convert the batches we get from the previous stage into instances of
the <a href="protocol/../glossary.html#payload-attributes"><code>PayloadAttributes</code></a> structure. Such a structure encodes the transactions that need to figure into
a block, as well as other block inputs (timestamp, fee recipient, etc). Payload attributes derivation is detailed in the
section <a href="protocol/derivation.html#deriving-payload-attributes">Deriving Payload Attributes section</a> below.</p>
<p>This stage maintains its own copy of the <a href="protocol/../glossary.html#system-configuration">system configuration</a>, independent of the L1 retrieval stage.
The system configuration is updated with L1 log events whenever the L1 epoch referenced by the batch input changes.</p>
<h3 id="engine-queue"><a class="header" href="#engine-queue">Engine Queue</a></h3>
<p>In the <em>Engine Queue</em> stage, the previously derived <code>PayloadAttributes</code> structures are buffered and sent to the
<a href="protocol/../glossary.html#execution-engine">execution engine</a> to be executed and converted into a proper L2 block.</p>
<p>The stage maintains references to three L2 blocks:</p>
<ul>
<li>The <a href="protocol/../glossary.html#finalized-l2-head">finalized L2 head</a>: everything up to and including this block can be fully derived from the
<a href="https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#finality">finalized</a> (i.e. canonical and forever irreversible) part of the L1 chain.</li>
<li>The <a href="protocol/../glossary.html#safe-l2-head">safe L2 head</a>: everything up to and including this block can be fully derived from the
currently canonical L1 chain.</li>
<li>The <a href="protocol/../glossary.html#unsafe-l2-head">unsafe L2 head</a>: blocks between the safe and unsafe heads are <a href="protocol/../glossary.html#unsafe-l2-block">unsafe
blocks</a> that have not been derived from L1. These blocks either come from sequencing (in sequencer
mode) or from <a href="protocol/../glossary.html#unsafe-sync">unsafe sync</a> to the sequencer (in validator mode).
This is also known as the &quot;latest&quot; head.</li>
</ul>
<p>Additionally, it buffers a short history of references to recently processed safe L2 blocks, along with references
from which L1 blocks each was derived.
This history does not have to be complete, but enables later L1 finality signals to be translated into L2 finality.</p>
<h4 id="engine-api-usage"><a class="header" href="#engine-api-usage">Engine API usage</a></h4>
<p>To interact with the engine, the <a href="protocol/exec-engine.html">execution engine API</a> is used, with the following JSON-RPC methods:</p>
<h5 id="bedrock-canyon-delta-api-usage"><a class="header" href="#bedrock-canyon-delta-api-usage">Bedrock, Canyon, Delta: API Usage</a></h5>
<ul>
<li><a href="protocol/exec-engine.html#engine_forkchoiceupdatedv2"><code>engine_forkchoiceUpdatedV2</code></a> â€” updates the forkchoice (i.e. the chain head) to <code>headBlockHash</code> if different, and
instructs the engine to start building an execution payload if the payload attributes parameter is not <code>null</code>.</li>
<li><a href="protocol/exec-engine.html#engine_getpayloadv2"><code>engine_getPayloadV2</code></a> â€” retrieves a previously requested execution payload build.</li>
<li><a href="protocol/exec-engine.html#engine_newpayloadv2"><code>engine_newPayloadV2</code></a> â€” executes an execution payload to create a block.</li>
</ul>
<h5 id="ecotone-api-usage"><a class="header" href="#ecotone-api-usage">Ecotone: API Usage</a></h5>
<ul>
<li><a href="protocol/exec-engine.html#engine_forkchoiceupdatedv3"><code>engine_forkchoiceUpdatedV3</code></a> â€” updates the forkchoice (i.e. the chain head) to <code>headBlockHash</code> if different, and
instructs the engine to start building an execution payload if the payload attributes parameter is not <code>null</code>.</li>
<li><a href="protocol/exec-engine.html#engine_getpayloadv3"><code>engine_getPayloadV3</code></a> â€” retrieves a previously requested execution payload build.</li>
<li><code>engine_newPayload</code>
<ul>
<li><a href="protocol/exec-engine.html#engine_newpayloadv2"><code>engine_newPayloadV2</code></a> â€” executes a Bedrock/Canyon/Delta execution payload to create a block.</li>
<li><a href="protocol/exec-engine.html#engine_newpayloadv3"><code>engine_newPayloadV3</code></a> â€” executes an Ecotone execution payload to create a block.</li>
</ul>
</li>
</ul>
<p>The current version of <code>op-node</code> uses the <code>v3</code> Engine API RPC methods as well as <code>engine_newPayloadV2</code>, due to
<code>engine_newPayloadV3</code> only supporting Ecotone execution payloads. Both <code>engine_forkchoiceUpdatedV3</code> and
<code>engine_getPayloadV3</code> are backwards compatible with Bedrock, Canyon &amp; Delta payloads.</p>
<p>Prior versions of <code>op-node</code> used <code>v2</code> and <code>v1</code> methods.</p>
<p>The execution payload is an object of type <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/cancun.md"><code>ExecutionPayloadV3</code></a>.</p>
<p>The <code>ExecutionPayload</code> has the following requirements:</p>
<ul>
<li>Bedrock
<ul>
<li>The withdrawals field MUST be nil</li>
<li>The blob gas used field MUST be nil</li>
<li>The blob gas limit field MUST be nil</li>
</ul>
</li>
<li>Canyon, Delta
<ul>
<li>The withdrawals field MUST be non-nil</li>
<li>The withdrawals field MUST be an empty list</li>
<li>The blob gas used field MUST be nil</li>
<li>The blob gas limit field MUST be nil</li>
</ul>
</li>
<li>Ecotone
<ul>
<li>The withdrawals field MUST be non-nil</li>
<li>The withdrawals field MUST be an empty list</li>
<li>The blob gas used field MUST be 0</li>
<li>The blob gas limit field MUST be 0</li>
</ul>
</li>
</ul>
<h4 id="forkchoice-synchronization"><a class="header" href="#forkchoice-synchronization">Forkchoice synchronization</a></h4>
<p>If there are any forkchoice updates to be applied, before additional inputs are derived or processed, then these are
applied to the engine first.</p>
<p>This synchronization may happen when:</p>
<ul>
<li>A L1 finality signal finalizes one or more L2 blocks: updating the &quot;finalized&quot; L2 block.</li>
<li>A successful consolidation of unsafe L2 blocks: updating the &quot;safe&quot; L2 block.</li>
<li>The first thing after a derivation pipeline reset, to ensure a consistent execution engine forkchoice state.</li>
</ul>
<p>The new forkchoice state is applied by calling <a href="protocol/derivation.html#engine-api-usage">fork choice updated</a> on the engine API.
On forkchoice-state validity errors the derivation pipeline must be reset to recover to consistent state.</p>
<h4 id="l1-consolidation-payload-attributes-matching"><a class="header" href="#l1-consolidation-payload-attributes-matching">L1-consolidation: payload attributes matching</a></h4>
<p>If the unsafe head is ahead of the safe head, then <a href="protocol/../glossary.html#unsafe-block-consolidation">consolidation</a> is attempted, verifying that
existing unsafe L2 chain matches the derived L2 inputs as derived from the canonical L1 data.</p>
<p>During consolidation, we consider the oldest unsafe L2 block, i.e. the unsafe L2 block directly after the safe head. If
the payload attributes match this oldest unsafe L2 block, then that block can be considered &quot;safe&quot; and becomes the new
safe head.</p>
<p>The following fields of the derived L2 payload attributes are checked for equality with the L2 block:</p>
<ul>
<li>Bedrock, Canyon, Delta, Ecotone Blocks
<ul>
<li><code>parent_hash</code></li>
<li><code>timestamp</code></li>
<li><code>randao</code></li>
<li><code>fee_recipient</code></li>
<li><code>transactions_list</code> (first length, then equality of each of the encoded transactions, including deposits)</li>
<li><code>gas_limit</code></li>
</ul>
</li>
<li>Canyon, Delta, Ecotone Blocks
<ul>
<li><code>withdrawals</code> (first presence, then length, then equality of each of the encoded withdrawals)</li>
</ul>
</li>
<li>Ecotone Blocks
<ul>
<li><code>parent_beacon_block_root</code></li>
</ul>
</li>
</ul>
<p>If consolidation succeeds, the forkchoice change will synchronize as described in the section above.</p>
<p>If consolidation fails, the L2 payload attributes will be processed immediately as described in the section below.
The payload attributes are chosen in favor of the previous unsafe L2 block, creating an L2 chain reorg on top of the
current safe block. Immediately processing the new alternative attributes enables execution engines like go-ethereum to
enact the change, as linear rewinds of the tip of the chain may not be supported.</p>
<h4 id="l1-sync-payload-attributes-processing"><a class="header" href="#l1-sync-payload-attributes-processing">L1-sync: payload attributes processing</a></h4>
<p>If the safe and unsafe L2 heads are identical (whether because of failed consolidation or not), we send the L2 payload
attributes to the execution engine to be constructed into a proper L2 block.
This L2 block will then become both the new L2 safe and unsafe head.</p>
<p>If a payload attributes created from a batch cannot be inserted into the chain because of a validation error (i.e. there
was an invalid transaction or state transition in the block) the batch should be dropped &amp; the safe head should not be
advanced. The engine queue will attempt to use the next batch for that timestamp from the batch queue. If no valid batch
is found, the rollup node will create a deposit only batch which should always pass validation because deposits are
always valid.</p>
<p>Interaction with the execution engine via the execution engine API is detailed in the <a href="protocol/exec-engine.html#engine-api">Communication with the Execution
Engine</a> section.</p>
<p>The payload attributes are then processed with a sequence of:</p>
<ul>
<li><a href="protocol/derivation.html#engine-api-usage">Engine: Fork choice updated</a> with current forkchoice state of the stage, and the attributes to
start block building.
<ul>
<li>Non-deterministic sources, like the tx-pool, must be disabled to reconstruct the expected block.</li>
</ul>
</li>
<li><a href="protocol/derivation.html#engine-api-usage">Engine: Get Payload</a> to retrieve the payload, by the payload-ID in the result of the previous
step.</li>
<li><a href="protocol/derivation.html#engine-api-usage">Engine: New Payload</a> to import the new payload into the execution engine.</li>
<li><a href="protocol/derivation.html#engine-api-usage">Engine: Fork Choice Updated</a> to make the new payload canonical,
now with a change of both <code>safe</code> and <code>unsafe</code> fields to refer to the payload, and no payload attributes.</li>
</ul>
<p>Engine API Error handling:</p>
<ul>
<li>On RPC-type errors the payload attributes processing should be re-attempted in a future step.</li>
<li>On payload processing errors the attributes must be dropped, and the forkchoice state must be left unchanged.
<ul>
<li>Eventually the derivation pipeline will produce alternative payload attributes, with or without batches.</li>
<li>If the payload attributes only contained deposits, then it is a critical derivation error if these are invalid.</li>
</ul>
</li>
<li>On forkchoice-state validity errors the derivation pipeline must be reset to recover to consistent state.</li>
</ul>
<h4 id="processing-unsafe-payload-attributes"><a class="header" href="#processing-unsafe-payload-attributes">Processing unsafe payload attributes</a></h4>
<p>If no forkchoice updates or L1 data remain to be processed, and if the next possible L2 block is already available
through an unsafe source such as the sequencer publishing it via the p2p network, then it is optimistically processed as
an &quot;unsafe&quot; block. This reduces later derivation work to just consolidation with L1 in the happy case, and enables the
user to see the head of the L2 chain faster than the L1 may confirm the L2 batches.</p>
<p>To process unsafe payloads, the payload must:</p>
<ul>
<li>Have a block number higher than the current safe L2 head.
<ul>
<li>The safe L2 head may only be reorged out due to L1 reorgs.</li>
</ul>
</li>
<li>Have a parent blockhash that matches the current unsafe L2 head.
<ul>
<li>This prevents the execution engine individually syncing a larger gap in the unsafe L2 chain.</li>
<li>This prevents unsafe L2 blocks from reorging other previously validated L2 blocks.</li>
<li>This check may change in the future versions to adopt e.g. the L1 snap-sync protocol.</li>
</ul>
</li>
</ul>
<p>The payload is then processed with a sequence of:</p>
<ul>
<li>Bedrock/Canyon/Delta Payloads
<ul>
<li><code>engine_newPayloadV2</code>: process the payload. It does not become canonical yet.</li>
<li><code>engine_forkchoiceUpdatedV2</code>: make the payload the canonical unsafe L2 head, and keep the safe/finalized L2 heads.</li>
</ul>
</li>
<li>Ecotone Payloads
<ul>
<li><code>engine_newPayloadV3</code>: process the payload. It does not become canonical yet.</li>
<li><code>engine_forkchoiceUpdatedV3</code>: make the payload the canonical unsafe L2 head, and keep the safe/finalized L2 heads.</li>
</ul>
</li>
</ul>
<p>Engine API Error handling:</p>
<ul>
<li>On RPC-type errors the payload processing should be re-attempted in a future step.</li>
<li>On payload processing errors the payload must be dropped, and not be marked as canonical.</li>
<li>On forkchoice-state validity errors the derivation pipeline must be reset to recover to consistent state.</li>
</ul>
<h3 id="resetting-the-pipeline"><a class="header" href="#resetting-the-pipeline">Resetting the Pipeline</a></h3>
<p>It is possible to reset the pipeline, for instance if we detect an L1 <a href="protocol/../glossary.html#chain-re-organization">reorg (reorganization)</a>.
<strong>This enables the rollup node to handle L1 chain reorg events.</strong></p>
<p>Resetting will recover the pipeline into a state that produces the same outputs as a full L2 derivation process,
but starting from an existing L2 chain that is traversed back just enough to reconcile with the current L1 chain.</p>
<p>Note that this algorithm covers several important use-cases:</p>
<ul>
<li>Initialize the pipeline without starting from 0, e.g. when the rollup node restarts with an existing engine instance.</li>
<li>Recover the pipeline if it becomes inconsistent with the execution engine chain, e.g. when the engine syncs/changes.</li>
<li>Recover the pipeline when the L1 chain reorganizes, e.g. a late L1 block is orphaned, or a larger attestation failure.</li>
<li>Initialize the pipeline to derive a disputed L2 block with prior L1 and L2 history inside a fault-proof program.</li>
</ul>
<p>Handling these cases also means a node can be configured to eagerly sync L1 data with 0 confirmations,
as it can undo the changes if the L1 later does recognize the data as canonical, enabling safe low-latency usage.</p>
<p>The Engine Queue is first reset, to determine the L1 and L2 starting points to continue derivation from.
After this, the other stages are reset independent of each other.</p>
<h4 id="finding-the-sync-starting-point"><a class="header" href="#finding-the-sync-starting-point">Finding the sync starting point</a></h4>
<p>To find the starting point, there are several steps, relative to the head of the chain traversing back:</p>
<ol>
<li>Find the current L2 forkchoice state
<ul>
<li>If no <code>finalized</code> block can be found, start at the Bedrock genesis block.</li>
<li>If no <code>safe</code> block can be found, fallback to the <code>finalized</code> block.</li>
<li>The <code>unsafe</code> block should always be available and consistent with the above
(it may not be in rare engine-corruption recovery cases, this is being reviewed).</li>
</ul>
</li>
<li>Find the first L2 block with plausible L1 reference to be the new <code>unsafe</code> starting point,
starting from previous <code>unsafe</code>, back to <code>finalized</code> and no further.
<ul>
<li>Plausible iff: the L1 origin of the L2 block is known and canonical, or unknown and has a block-number ahead of L1.</li>
</ul>
</li>
<li>Find the first L2 block with an L1 reference older than the sequencing window, to be the new <code>safe</code> starting point,
starting at the above plausible <code>unsafe</code> head, back to <code>finalized</code> and no further.
<ul>
<li>If at any point the L1 origin is known but not canonical, the <code>unsafe</code> head is revised to parent of the current.</li>
<li>The highest L2 block with known canonical L1 origin is remembered as <code>highest</code>.</li>
<li>If at any point the L1 origin in the block is corrupt w.r.t. derivation rules, then error. Corruption includes:
<ul>
<li>Inconsistent L1 origin block number or parent-hash with parent L1 origin</li>
<li>Inconsistent L1 sequence number (always changes to <code>0</code> for a L1 origin change, or increments by <code>1</code> if not)</li>
</ul>
</li>
<li>If the L1 origin of the L2 block <code>n</code> is older than the L1 origin of <code>highest</code> by more than a sequence window,
and <code>n.sequence_number == 0</code>, then the parent L2 block of <code>n</code> will be the <code>safe</code> starting point.</li>
</ul>
</li>
<li>The <code>finalized</code> L2 block persists as the <code>finalized</code> starting point.</li>
<li>Find the first L2 block with an L1 reference older than the channel-timeout
<ul>
<li>The L1 origin referenced by this block which we call <code>l2base</code> will be the <code>base</code> for the L2 pipeline derivation:
By starting here, the stages can buffer any necessary data, while dropping incomplete derivation outputs until
L1 traversal has caught up with the actual L2 safe head.</li>
</ul>
</li>
</ol>
<p>While traversing back the L2 chain, an implementation may sanity-check that the starting point is never set too far
back compared to the existing forkchoice state, to avoid an intensive reorg because of misconfiguration.</p>
<p>Implementers note: step 1-4 are known as <code>FindL2Heads</code>. Step 5 is currently part of the Engine Queue reset.
This may change to isolate the starting-point search from the bare reset logic.</p>
<h4 id="resetting-derivation-stages"><a class="header" href="#resetting-derivation-stages">Resetting derivation stages</a></h4>
<ol>
<li>L1 Traversal: start at L1 <code>base</code> as first block to be pulled by next stage.</li>
<li>L1 Retrieval: empty previous data, and fetch the <code>base</code> L1 data, or defer the fetching work to a later pipeline step.</li>
<li>Frame Queue: empty the queue.</li>
<li>Channel Bank: empty the channel bank.</li>
<li>Channel Reader: reset any batch decoding state.</li>
<li>Batch Queue: empty the batch queue, use <code>base</code> as initial L1 point of reference.</li>
<li>Payload Attributes Derivation: empty any batch/attributes state.</li>
<li>Engine Queue:
<ul>
<li>Initialize L2 forkchoice state with syncing start point state. (<code>finalized</code>/<code>safe</code>/<code>unsafe</code>)</li>
<li>Initialize the L1 point of reference of the stage to <code>base</code>.</li>
<li>Require a forkchoice update as first task</li>
<li>Reset any finality data</li>
</ul>
</li>
</ol>
<p>Where necessary, stages starting at <code>base</code> can initialize their system-config from data encoded in the <code>l2base</code> block.</p>
<h4 id="about-reorgs-post-merge"><a class="header" href="#about-reorgs-post-merge">About reorgs Post-Merge</a></h4>
<p>Note that post-<a href="https://ethereum.org/en/upgrades/merge/">merge</a>, the depth of reorgs will be bounded by the <a href="https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#finality">L1 finality delay</a>
(2 L1 beacon epochs, or approximately 13 minutes, unless more than 1/3 of the network consistently disagrees).
New L1 blocks may be finalized every L1 beacon epoch (approximately 6.4 minutes), and depending on these
finality-signals and batch-inclusion, the derived L2 chain will become irreversible as well.</p>
<p>Note that this form of finalization only affects inputs, and nodes can then subjectively say the chain is irreversible,
by reproducing the chain from these irreversible inputs and the set protocol rules and parameters.</p>
<p>This is however completely unrelated to the outputs posted on L1, which require a form of proof like a fault-proof or
zk-proof to finalize. Optimistic-rollup outputs like withdrawals on L1 are only labeled &quot;finalized&quot; after passing a week
without dispute (fault proof challenge window), a name-collision with the proof-of-stake finalization.</p>
<hr />
<h1 id="deriving-payload-attributes"><a class="header" href="#deriving-payload-attributes">Deriving Payload Attributes</a></h1>
<p>For every L2 block derived from L1 data, we need to build <a href="protocol/../glossary.html#payload-attributes">payload attributes</a>,
represented by an <a href="protocol/exec-engine.html#extended-payloadattributesv1">expanded version</a> of the <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/cancun.md"><code>PayloadAttributesV2</code></a> object,
which includes additional <code>transactions</code> and <code>noTxPool</code> fields.</p>
<p>This process happens during the payloads-attributes queue ran by a verifier node, as well as during block-production
ran by a sequencer node (the sequencer may enable the tx-pool usage if the transactions are batch-submitted).</p>
<h2 id="deriving-the-transaction-list"><a class="header" href="#deriving-the-transaction-list">Deriving the Transaction List</a></h2>
<p>For each L2 block to be created by the sequencer, we start from a <a href="protocol/../glossary.html#sequencer-batch">sequencer batch</a> matching the
target L2 block number. This could potentially be an empty auto-generated batch, if the L1 chain did not include a batch
for the target L2 block number. <a href="protocol/derivation.html#batch-format">Remember</a> that the batch includes a <a href="protocol/../glossary.html#sequencing-epoch">sequencing
epoch</a> number, an L2 timestamp, and a transaction list.</p>
<p>This block is part of a <a href="protocol/../glossary.html#sequencing-epoch">sequencing epoch</a>,
whose number matches that of an L1 block (its <em><a href="protocol/../glossary.html#l1-origin">L1 origin</a></em>).
This L1 block is used to derive L1 attributes and (for the first L2 block in the epoch) user deposits.</p>
<p>Therefore, a <a href="protocol/exec-engine.html#extended-payloadattributesv1"><code>PayloadAttributesV2</code></a> object must include the following transactions:</p>
<ul>
<li>one or more <a href="protocol/../glossary.html#deposited-transaction">deposited transactions</a>, of two kinds:
<ul>
<li>a single <em><a href="protocol/../glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a></em>, derived from the L1 origin.</li>
<li>for the first L2 block in the epoch, zero or more <em><a href="protocol/../glossary.html#user-deposited-transaction">user-deposited transactions</a></em>, derived from
the <a href="protocol/../glossary.html#receipt">receipts</a> of the L1 origin.</li>
</ul>
</li>
<li>zero or more <a href="protocol/derivation.html#network-upgrade-automation-transactions">network upgrade automation transactions</a>: special transactions to perform network upgrades.</li>
<li>zero or more <em><a href="protocol/../glossary.html#sequencing">sequenced transactions</a></em>: regular transactions signed by L2 users, included in the
sequencer batch.</li>
</ul>
<p>Transactions <strong>must</strong> appear in this order in the payload attributes.</p>
<p>The L1 attributes are read from the L1 block header, while deposits are read from the L1 block's <a href="protocol/../glossary.html#receipt">receipts</a>.
Refer to the <a href="protocol/deposits.html#deposit-contract"><strong>deposit contract specification</strong></a> for details on how deposits are encoded as log
entries.</p>
<h3 id="network-upgrade-automation-transactions"><a class="header" href="#network-upgrade-automation-transactions">Network upgrade automation transactions</a></h3>
<p>Some network upgrades require automated contract changes or deployments at specific blocks.
To automate these, without adding persistent changes to the execution-layer,
special transactions may be inserted as part of the derivation process.</p>
<h4 id="ecotone"><a class="header" href="#ecotone">Ecotone</a></h4>
<p>The Ecotone hardfork activation block, contains the following transactions in this order:</p>
<ul>
<li>L1 Attributes Transaction, using the pre-Ecotone <code>setL1BlockValues</code></li>
<li>User deposits from L1</li>
<li>Network Upgrade Transactions
<ul>
<li>L1Block deployment</li>
<li>GasPriceOracle deployment</li>
<li>Update L1Block Proxy ERC-1967 Implementation Slot</li>
<li>Update GasPriceOracle Proxy ERC-1967 Implementation Slot</li>
<li>GasPriceOracle Enable Ecotone</li>
<li>Beacon block roots contract deployment (EIP-4788)</li>
</ul>
</li>
</ul>
<p>To not modify or interrupt the system behavior around gas computation, this block will not include any sequenced
transactions by setting <code>noTxPool: true</code>.</p>
<h5 id="l1block-deployment"><a class="header" href="#l1block-deployment">L1Block Deployment</a></h5>
<p>The <code>L1Block</code> contract is upgraded to process the new Ecotone L1-data-fee parameters and L1 blob base-fee.</p>
<p>A deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0x4210000000000000000000000000000000000000</code></li>
<li><code>to</code>: <code>null</code></li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>375,000</code></li>
<li><code>data</code>: <code>0x60806040523480156100105...</code> (<a href="protocol/../static/bytecode/ecotone-l1-block-deployment.txt">full bytecode</a>)</li>
<li><code>sourceHash</code>: <code>0x877a6077205782ea15a6dc8699fa5ebcec5e0f4389f09cb8eda09488231346f8</code>,
computed with the &quot;Upgrade-deposited&quot; type, with `intent = &quot;Ecotone: L1 Block Deployment&quot;</li>
</ul>
<p>This results in the Ecotone L1Block contract being deployed to <code>0x07dbe8500fc591d1852B76feE44d5a05e13097Ff</code>, to verify:</p>
<pre><code class="language-bash">cast compute-address --nonce=0 0x4210000000000000000000000000000000000000
Computed Address: 0x07dbe8500fc591d1852B76feE44d5a05e13097Ff
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: L1 Block Deployment&quot;))
# 0x877a6077205782ea15a6dc8699fa5ebcec5e0f4389f09cb8eda09488231346f8
</code></pre>
<p>Verify <code>data</code>:</p>
<pre><code class="language-bash">git checkout 5996d0bc1a4721f2169ba4366a014532f31ea932
pnpm clean &amp;&amp; pnpm install &amp;&amp; pnpm build
jq -r &quot;.bytecode.object&quot; packages/contracts-bedrock/forge-artifacts/L1Block.sol/L1Block.json
</code></pre>
<p>This transaction MUST deploy a contract with the following code hash
<code>0xc88a313aa75dc4fbf0b6850d9f9ae41e04243b7008cf3eadb29256d4a71c1dfd</code>.</p>
<h5 id="gaspriceoracle-deployment"><a class="header" href="#gaspriceoracle-deployment">GasPriceOracle Deployment</a></h5>
<p>The <code>GasPriceOracle</code> contract is upgraded to support the new Ecotone L1-data-fee parameters. Post fork this contract
will use the blob base fee to compute the gas price for L1-data-fee transactions.</p>
<p>A deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0x4210000000000000000000000000000000000001</code></li>
<li><code>to</code>: <code>null</code>,</li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>1,000,000</code></li>
<li><code>data</code>: <code>0x60806040523480156100...</code> (<a href="protocol/../static/bytecode/ecotone-gas-price-oracle-deployment.txt">full bytecode</a>)</li>
<li><code>sourceHash</code>: <code>0xa312b4510adf943510f05fcc8f15f86995a5066bd83ce11384688ae20e6ecf42</code>
computed with the &quot;Upgrade-deposited&quot; type, with `intent = &quot;Ecotone: Gas Price Oracle Deployment&quot;</li>
</ul>
<p>This results in the Ecotone GasPriceOracle contract being deployed to <code>0xb528D11cC114E026F138fE568744c6D45ce6Da7A</code>,
to verify:</p>
<pre><code class="language-bash">cast compute-address --nonce=0 0x4210000000000000000000000000000000000001
Computed Address: 0xb528D11cC114E026F138fE568744c6D45ce6Da7A
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">â¯ cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: Gas Price Oracle Deployment&quot;))
# 0xa312b4510adf943510f05fcc8f15f86995a5066bd83ce11384688ae20e6ecf42
</code></pre>
<p>Verify <code>data</code>:</p>
<pre><code class="language-bash">git checkout 5996d0bc1a4721f2169ba4366a014532f31ea932
pnpm clean &amp;&amp; pnpm install &amp;&amp; pnpm build
jq -r &quot;.bytecode.object&quot; packages/contracts-bedrock/forge-artifacts/GasPriceOracle.sol/GasPriceOracle.json
</code></pre>
<p>This transaction MUST deploy a contract with the following code hash
<code>0x8b71360ea773b4cfaf1ae6d2bd15464a4e1e2e360f786e475f63aeaed8da0ae5</code>.</p>
<h5 id="l1block-proxy-update"><a class="header" href="#l1block-proxy-update">L1Block Proxy Update</a></h5>
<p>This transaction updates the L1Block Proxy ERC-1967 implementation slot to point to the new L1Block deployment.</p>
<p>A deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0x0000000000000000000000000000000000000000</code></li>
<li><code>to</code>: <code>0x4200000000000000000000000000000000000015</code> (L1Block Proxy)</li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>50,000</code></li>
<li><code>data</code>: <code>0x3659cfe600000000000000000000000007dbe8500fc591d1852b76fee44d5a05e13097ff</code></li>
<li><code>sourceHash</code>: <code>0x18acb38c5ff1c238a7460ebc1b421fa49ec4874bdf1e0a530d234104e5e67dbc</code>
computed with the &quot;Upgrade-deposited&quot; type, with `intent = &quot;Ecotone: L1 Block Proxy Update&quot;</li>
</ul>
<p>Verify data:</p>
<pre><code class="language-bash">cast concat-hex $(cast sig &quot;upgradeTo(address)&quot;) $(cast abi-encode &quot;upgradeTo(address)&quot; 0x07dbe8500fc591d1852B76feE44d5a05e13097Ff)
0x3659cfe600000000000000000000000007dbe8500fc591d1852b76fee44d5a05e13097ff
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: L1 Block Proxy Update&quot;))
# 0x18acb38c5ff1c238a7460ebc1b421fa49ec4874bdf1e0a530d234104e5e67dbc
</code></pre>
<h5 id="gaspriceoracle-proxy-update"><a class="header" href="#gaspriceoracle-proxy-update">GasPriceOracle Proxy Update</a></h5>
<p>This transaction updates the GasPriceOracle Proxy ERC-1967 implementation slot to point to the new GasPriceOracle
deployment.</p>
<p>A deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0x0000000000000000000000000000000000000000</code></li>
<li><code>to</code>: <code>0x420000000000000000000000000000000000000F</code> (Gas Price Oracle Proxy)</li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>50,000</code></li>
<li><code>data</code>: <code>0x3659cfe6000000000000000000000000b528d11cc114e026f138fe568744c6d45ce6da7a</code></li>
<li><code>sourceHash</code>: <code>0xee4f9385eceef498af0be7ec5862229f426dec41c8d42397c7257a5117d9230a</code>
computed with the &quot;Upgrade-deposited&quot; type, with <code>intent = &quot;Ecotone: Gas Price Oracle Proxy Update&quot;</code></li>
</ul>
<p>Verify data:</p>
<pre><code class="language-bash">cast concat-hex $(cast sig &quot;upgradeTo(address)&quot;) $(cast abi-encode &quot;upgradeTo(address)&quot; 0xb528D11cC114E026F138fE568744c6D45ce6Da7A)
0x3659cfe6000000000000000000000000b528d11cc114e026f138fe568744c6d45ce6da7a
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: Gas Price Oracle Proxy Update&quot;))
# 0xee4f9385eceef498af0be7ec5862229f426dec41c8d42397c7257a5117d9230a
</code></pre>
<h5 id="gaspriceoracle-enable-ecotone"><a class="header" href="#gaspriceoracle-enable-ecotone">GasPriceOracle Enable Ecotone</a></h5>
<p>This transaction informs the GasPriceOracle to start using the Ecotone gas calculation formula.</p>
<p>A deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001</code> (Depositer Account)</li>
<li><code>to</code>: <code>0x420000000000000000000000000000000000000F</code> (Gas Price Oracle Proxy)</li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>80,000</code></li>
<li><code>data</code>: <code>0x22b90ab3</code></li>
<li><code>sourceHash</code>: <code>0x0c1cb38e99dbc9cbfab3bb80863380b0905290b37eb3d6ab18dc01c1f3e75f93</code>,
computed with the &quot;Upgrade-deposited&quot; type, with `intent = &quot;Ecotone: Gas Price Oracle Set Ecotone&quot;</li>
</ul>
<p>Verify data:</p>
<pre><code class="language-bash">cast sig &quot;setEcotone()&quot;
0x22b90ab3
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: Gas Price Oracle Set Ecotone&quot;))
# 0x0c1cb38e99dbc9cbfab3bb80863380b0905290b37eb3d6ab18dc01c1f3e75f93
</code></pre>
<h5 id="beacon-block-roots-contract-deployment-eip-4788"><a class="header" href="#beacon-block-roots-contract-deployment-eip-4788">Beacon block roots contract deployment (EIP-4788)</a></h5>
<p><a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788</a> introduces a &quot;Beacon block roots&quot; contract, that processes and exposes the beacon-block-root values.
at address <code>BEACON_ROOTS_ADDRESS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02</code>.</p>
<p>For deployment, <a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788</a> defines a pre-<a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155</a> legacy transaction, sent from a key that is derived such that the
transaction signature validity is bound to message-hash, which is bound to the input-data, containing the init-code.</p>
<p>However, this type of transaction requires manual deployment and gas-payments.
And since the processing is an integral part of the chain processing, and has to be repeated for every OP-Stack chain,
the deployment is approached differently here.</p>
<p>Some chains may already have a user-submitted instance of the <a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788</a> transaction.
This is cryptographically guaranteed to be correct, but may result in the upgrade transaction
deploying a second contract, with the next nonce. The result of this deployment can be ignored.</p>
<p>A Deposit transaction is derived with the following attributes:</p>
<ul>
<li><code>from</code>: <code>0x0B799C86a49DEeb90402691F1041aa3AF2d3C875</code>, as specified in the EIP.</li>
<li><code>to</code>: null</li>
<li><code>mint</code>: <code>0</code></li>
<li><code>value</code>: <code>0</code></li>
<li><code>gasLimit</code>: <code>0x3d090</code>, as specified in the EIP.</li>
<li><code>isCreation</code>: <code>true</code></li>
<li><code>data</code>:
<code>0x60618060095f395ff33373fffffffffffffffffffffffffffffffffffffffe14604d57602036146024575f5ffd5b5f35801560495762001fff810690815414603c575f5ffd5b62001fff01545f5260205ff35b5f5ffd5b62001fff42064281555f359062001fff015500</code></li>
<li><code>isSystemTx</code>: <code>false</code>, as per the Regolith upgrade, even the system-generated transactions spend gas.</li>
<li><code>sourceHash</code>: <code>0x69b763c48478b9dc2f65ada09b3d92133ec592ea715ec65ad6e7f3dc519dc00c</code>,
computed with the &quot;Upgrade-deposited&quot; type, with <code>intent = &quot;Ecotone: beacon block roots contract deployment&quot;</code></li>
</ul>
<p>The contract address upon deployment is computed as <code>rlp([sender, nonce])</code>, which will equal:</p>
<ul>
<li><code>BEACON_ROOTS_ADDRESS</code> if deployed</li>
<li>a different address (<code>0xE3aE1Ae551eeEda337c0BfF6C4c7cbA98dce353B</code>) if <code>nonce = 1</code>:
when a user already submitted the EIP transaction before the upgrade.</li>
</ul>
<p>Verify <code>BEACON_ROOTS_ADDRESS</code>:</p>
<pre><code class="language-bash">cast compute-address --nonce=0 0x0B799C86a49DEeb90402691F1041aa3AF2d3C875
# Computed Address: 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02
</code></pre>
<p>Verify <code>sourceHash</code>:</p>
<pre><code class="language-bash">cast keccak $(cast concat-hex 0x0000000000000000000000000000000000000000000000000000000000000002 $(cast keccak &quot;Ecotone: beacon block roots contract deployment&quot;))
# 0x69b763c48478b9dc2f65ada09b3d92133ec592ea715ec65ad6e7f3dc519dc00c
</code></pre>
<h2 id="building-individual-payload-attributes"><a class="header" href="#building-individual-payload-attributes">Building Individual Payload Attributes</a></h2>
<p>After deriving the transactions list, the rollup node constructs a <a href="protocol/exec-engine.html#extended-payloadattributesv1"><code>PayloadAttributesV2</code></a> as
follows:</p>
<ul>
<li><code>timestamp</code> is set to the batch's timestamp.</li>
<li><code>random</code> is set to the <code>prev_randao</code> L1 block attribute.</li>
<li><code>suggestedFeeRecipient</code> is set to the Sequencer Fee Vault address. See <a href="protocol/exec-engine.html#fee-vaults">Fee Vaults</a> specification.</li>
<li><code>transactions</code> is the array of the derived transactions: deposited transactions and sequenced transactions, all
encoded with <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a>.</li>
<li><code>noTxPool</code> is set to <code>true</code>, to use the exact above <code>transactions</code> list when constructing the block.</li>
<li><code>gasLimit</code> is set to the current <code>gasLimit</code> value in the <a href="protocol/../glossary.html#system-configuration">system configuration</a> of this payload.</li>
<li><code>withdrawals</code> is set to nil prior to Canyon and an empty array after Canyon</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="span-batches"><a class="header" href="#span-batches">Span-batches</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/span-batches.html#introduction">Introduction</a></li>
<li><a href="protocol/span-batches.html#span-batch-format">Span batch format</a>
<ul>
<li><a href="protocol/span-batches.html#max-span-batch-size">Max span-batch size</a></li>
<li><a href="protocol/span-batches.html#future-batch-format-extension">Future batch-format extension</a></li>
</ul>
</li>
<li><a href="protocol/span-batches.html#span-batch-activation-rule">Span batch Activation Rule</a></li>
<li><a href="protocol/span-batches.html#optimization-strategies">Optimization Strategies</a>
<ul>
<li><a href="protocol/span-batches.html#truncating-information-and-storing-only-necessary-data">Truncating information and storing only necessary data</a></li>
<li><a href="protocol/span-batches.html#tx_data_headers-removal-from-initial-specs"><code>tx_data_headers</code> removal from initial specs</a></li>
<li><a href="protocol/span-batches.html#chain-id-removal-from-initial-specs"><code>Chain ID</code> removal from initial specs</a></li>
<li><a href="protocol/span-batches.html#reorganization-of-constant-length-transaction-fields">Reorganization of constant length transaction fields</a></li>
<li><a href="protocol/span-batches.html#rlp-encoding-for-only-variable-length-fields">RLP encoding for only variable length fields</a></li>
<li><a href="protocol/span-batches.html#store-y_parity-and-protected_bit-instead-of-v">Store <code>y_parity</code> and <code>protected_bit</code> instead of <code>v</code></a></li>
<li><a href="protocol/span-batches.html#adjust-txs-data-layout-for-better-compression">Adjust <code>txs</code> Data Layout for Better Compression</a></li>
<li><a href="protocol/span-batches.html#fee_recipients-encoding-scheme"><code>fee_recipients</code> Encoding Scheme</a></li>
</ul>
</li>
<li><a href="protocol/span-batches.html#how-derivation-works-with-span-batch">How derivation works with Span Batch?</a></li>
<li><a href="protocol/span-batches.html#integration">Integration</a>
<ul>
<li><a href="protocol/span-batches.html#channel-reader-batch-decoding">Channel Reader (Batch Decoding)</a></li>
<li><a href="protocol/span-batches.html#batch-queue">Batch Queue</a></li>
<li><a href="protocol/span-batches.html#batcher">Batcher</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- All glossary references in this file. -->
<blockquote>
<p>The span-batches spec is experimental :shipit:</p>
<p>*this feature is in active R&amp;D and not yet part of any hard fork</p>
</blockquote>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Span-batches reduce overhead of OP-stack chains.
This enables sparse and low-throughput OP-stack chains.</p>
<p>The overhead is reduced by representing a span of
consecutive L2 blocks in a more efficient manner,
while preserving the same consistency checks as regular batch data.</p>
<p>Note that the <a href="protocol/derivation.html#channel-format">channel</a> and
<a href="protocol/derivation.html#frame-format">frame</a> formats stay the same:
data slicing, packing and multi-transaction transport is already optimized.</p>
<p>The overhead in the <a href="protocol/derivation.html">V0 batch format</a> comes from:</p>
<ul>
<li>The meta-data attributes are repeated for every L2 block, while these are mostly implied already:
<ul>
<li>parent hash (32 bytes)</li>
<li>L1 epoch: blockhash (32 bytes) and block number (~4 bytes)</li>
<li>timestamp (~4 bytes)</li>
</ul>
</li>
<li>The organization of block data is inefficient:
<ul>
<li>Similar attributes are far apart, diminishing any chances of effective compression.</li>
<li>Random data like hashes are positioned in-between the more compressible application data.</li>
</ul>
</li>
<li>The RLP encoding of the data adds unnecessary overhead
<ul>
<li>The outer list does not have to be length encoded, the attributes are known</li>
<li>Fixed-length attributes do not need any encoding</li>
<li>The batch-format is static and can be optimized further</li>
</ul>
</li>
<li>Remaining meta-data for consistency checks can be optimized further:
<ul>
<li>The metadata only needs to be secure for consistency checks. E.g. 20 bytes of a hash may be enough.</li>
</ul>
</li>
</ul>
<p>Span-batches address these inefficiencies, with a new batch format version.</p>
<h2 id="span-batch-format"><a class="header" href="#span-batch-format">Span batch format</a></h2>
<p>Note that span-batches, unlike previous singular batches,
encode <em>a range of consecutive</em> L2 blocks at the same time.</p>
<p>Introduce version <code>1</code> to the <a href="protocol/derivation.html#batch-format">batch-format</a> table:</p>
<div class="table-wrapper"><table><thead><tr><th><code>batch_version</code></th><th><code>content</code></th></tr></thead><tbody>
<tr><td>1</td><td><code>prefix ++ payload</code></td></tr>
</tbody></table>
</div>
<p>Notation:</p>
<ul>
<li><code>++</code>: concatenation of byte-strings</li>
<li><code>span_start</code>: first L2 block in the span</li>
<li><code>span_end</code>: last L2 block in the span</li>
<li><code>uvarint</code>: unsigned Base128 varint, as defined in <a href="https://protobuf.dev/programming-guides/encoding/#varints">protobuf spec</a></li>
<li><code>rlp_encode</code>: a function that encodes a batch according to the RLP format,
and <code>[x, y, z]</code> denotes a list containing items <code>x</code>, <code>y</code> and <code>z</code></li>
</ul>
<p>Standard bitlists, in the context of span-batches, are encoded as big-endian integers,
left-padded with zeroes to the next multiple of 8 bits.</p>
<p>Where:</p>
<ul>
<li><code>prefix = rel_timestamp ++ l1_origin_num ++ parent_check ++ l1_origin_check</code>
<ul>
<li><code>rel_timestamp</code>: <code>uvarint</code> relative timestamp since L2 genesis,
i.e. <code>span_start.timestamp - config.genesis.timestamp</code>.</li>
<li><code>l1_origin_num</code>: <code>uvarint</code> number of last l1 origin number. i.e. <code>span_end.l1_origin.number</code></li>
<li><code>parent_check</code>: first 20 bytes of parent hash, the hash is truncated to 20 bytes for efficiency,
i.e. <code>span_start.parent_hash[:20]</code>.</li>
<li><code>l1_origin_check</code>: the block hash of the last L1 origin is referenced.
The hash is truncated to 20 bytes for efficiency, i.e. <code>span_end.l1_origin.hash[:20]</code>.</li>
</ul>
</li>
<li><code>payload = block_count ++ origin_bits ++ block_tx_counts ++ txs</code>:
<ul>
<li><code>block_count</code>: <code>uvarint</code> number of L2 blocks. This is at least 1, empty span batches are invalid.</li>
<li><code>origin_bits</code>: standard bitlist of <code>block_count</code> bits:
1 bit per L2 block, indicating if the L1 origin changed this L2 block.</li>
<li><code>block_tx_counts</code>: for each block, a <code>uvarint</code> of <code>len(block.transactions)</code>.</li>
<li><code>txs</code>: L2 transactions which is reorganized and encoded as below.</li>
</ul>
</li>
<li><code>txs = contract_creation_bits ++ y_parity_bits ++ tx_sigs ++ tx_tos ++ tx_datas ++ tx_nonces ++ tx_gases ++ protected_bits</code>
<ul>
<li><code>contract_creation_bits</code>: standard bitlist of <code>sum(block_tx_counts)</code> bits:
1 bit per L2 transactions, indicating if transaction is a contract creation transaction.</li>
<li><code>y_parity_bits</code>: standard bitlist of <code>sum(block_tx_counts)</code> bits:
1 bit per L2 transactions, indicating the y parity value when recovering transaction sender address.</li>
<li><code>tx_sigs</code>: concatenated list of transaction signatures
<ul>
<li><code>r</code> is encoded as big-endian <code>uint256</code></li>
<li><code>s</code> is encoded as big-endian <code>uint256</code></li>
</ul>
</li>
<li><code>tx_tos</code>: concatenated list of <code>to</code> field. <code>to</code> field in contract creation transaction will be <code>nil</code> and ignored.</li>
<li><code>tx_datas</code>: concatenated list of variable length rlp encoded data,
matching the encoding of the fields as in the <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a> format of the <code>TransactionType</code>.
<ul>
<li><code>legacy</code>: <code>rlp_encode(value, gasPrice, data)</code></li>
<li><code>1</code>: (<a href="https://eips.ethereum.org/EIPS/eip-2930">EIP-2930</a>): <code>0x01 ++ rlp_encode(value, gasPrice, data, accessList)</code></li>
<li><code>2</code>: (<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>): <code>0x02 ++ rlp_encode(value, max_priority_fee_per_gas, max_fee_per_gas, data, access_list)</code></li>
</ul>
</li>
<li><code>tx_nonces</code>: concatenated list of <code>uvarint</code> of <code>nonce</code> field.</li>
<li><code>tx_gases</code>: concatenated list of <code>uvarint</code> of gas limits.
<ul>
<li><code>legacy</code>: <code>gasLimit</code></li>
<li><code>1</code>: (<a href="https://eips.ethereum.org/EIPS/eip-2930">EIP-2930</a>): <code>gasLimit</code></li>
<li><code>2</code>: (<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>): <code>gas_limit</code></li>
</ul>
</li>
<li><code>protected_bits</code>: standard bitlist of length of number of legacy transactions:
1 bit per L2 legacy transactions, indicating if transaction is protected(<a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155</a>) or not.</li>
</ul>
</li>
</ul>
<h3 id="max-span-batch-size"><a class="header" href="#max-span-batch-size">Max span-batch size</a></h3>
<p>Total size of encoded span batch is limited to <code>MAX_SPAN_BATCH_SIZE</code> (currently 10,000,000 bytes,
equal to <code>MAX_RLP_BYTES_PER_CHANNEL</code>). Therefore every field size of span batch will be implicitly limited to
<code>MAX_SPAN_BATCH_SIZE</code> . There can be at least single span batch per channel, and channel size is limited
to <code>MAX_RLP_BYTES_PER_CHANNEL</code> and you may think that there is already an implicit limit. However, having an explicit
limit for span batch is helpful for several reasons. We may save computation costs by avoiding malicious input while
decoding. For example, let's say bad batcher wrote span batch which <code>block_count = max.Uint64</code>. We may early return
using the explicit limit, not trying to consume data until EOF is reached. We can also safely preallocate memory for
decoding because we know the upper limit of memory usage.</p>
<h3 id="future-batch-format-extension"><a class="header" href="#future-batch-format-extension">Future batch-format extension</a></h3>
<p>This is an experimental extension of the span-batch format, and not activated with the Delta upgrade yet.</p>
<p>Introduce version <code>2</code> to the <a href="protocol/derivation.html#batch-format">batch-format</a> table:</p>
<div class="table-wrapper"><table><thead><tr><th><code>batch_version</code></th><th><code>content</code></th></tr></thead><tbody>
<tr><td>2</td><td><code>prefix ++ payload</code></td></tr>
</tbody></table>
</div>
<p>Where:</p>
<ul>
<li><code>prefix = rel_timestamp ++ l1_origin_num ++ parent_check ++ l1_origin_check</code>:
<ul>
<li>Identical to <code>batch_version</code> 1</li>
</ul>
</li>
<li><code>payload = block_count ++ origin_bits ++ block_tx_counts ++ txs ++ fee_recipients</code>:
<ul>
<li>An empty span-batch, i.e. with <code>block_count == 0</code>, is invalid and must not be processed.</li>
<li>Every field definition identical to <code>batch_version</code> 1 except that <code>fee_recipients</code> is
added to support more decentralized sequencing.</li>
<li><code>fee_recipients = fee_recipients_idxs + fee_recipients_set</code>
<ul>
<li><code>fee_recipients_set</code>: concatenated list of unique L2 fee recipient address.</li>
<li><code>fee_recipients_idxs</code>: for each block,
<code>uvarint</code> number of index to decode fee recipients from <code>fee_recipients_set</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="span-batch-activation-rule"><a class="header" href="#span-batch-activation-rule">Span batch Activation Rule</a></h2>
<p>The span batch upgrade is activated based on timestamp.</p>
<p>Activation Rule: <code>upgradeTime != null &amp;&amp; span_start.l1_origin.timestamp &gt;= upgradeTime</code></p>
<p><code>span_start.l1_origin.timestamp</code> is the L1 origin block timestamp of the first block in the span batch.
This rule ensures that every chain activity regarding this span batch is done after the hard fork.
i.e. Every block in the span is created, submitted to the L1, and derived from the L1 after the hard fork.</p>
<h2 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h2>
<h3 id="truncating-information-and-storing-only-necessary-data"><a class="header" href="#truncating-information-and-storing-only-necessary-data">Truncating information and storing only necessary data</a></h3>
<p>The following fields stores truncated data:</p>
<ul>
<li><code>rel_timestamp</code>: We can save two bytes by storing <code>rel_timestamp</code> instead of the full <code>span_start.timestamp</code>.</li>
<li><code>parent_check</code> and <code>l1_origin_check</code>: We can save twelve bytes by truncating twelve bytes from the full hash,
while having enough safety.</li>
</ul>
<h3 id="tx_data_headers-removal-from-initial-specs"><a class="header" href="#tx_data_headers-removal-from-initial-specs"><code>tx_data_headers</code> removal from initial specs</a></h3>
<p>We do not need to store length per each <code>tx_datas</code> elements even if those are variable length,
because the elements itself is RLP encoded, containing their length in RLP prefix.</p>
<h3 id="chain-id-removal-from-initial-specs"><a class="header" href="#chain-id-removal-from-initial-specs"><code>Chain ID</code> removal from initial specs</a></h3>
<p>Every transaction has chain id. We do not need to include chain id in span batch because L2 already knows its chain id,
and use its own value for processing span batches while derivation.</p>
<h3 id="reorganization-of-constant-length-transaction-fields"><a class="header" href="#reorganization-of-constant-length-transaction-fields">Reorganization of constant length transaction fields</a></h3>
<p><code>signature</code>, <code>nonce</code>, <code>gaslimit</code>, <code>to</code> field are constant size, so these were split up completely and
are grouped into individual arrays.
This adds more complexity, but organizes data for improved compression by grouping data with similar data pattern.</p>
<h3 id="rlp-encoding-for-only-variable-length-fields"><a class="header" href="#rlp-encoding-for-only-variable-length-fields">RLP encoding for only variable length fields</a></h3>
<p>Further size optimization can be done by packing variable length fields, such as <code>access_list</code>.
However, doing this will introduce much more code complexity, compared to benefiting from size reduction.</p>
<p>Our goal is to find the sweet spot on code complexity - span batch size tradeoff.
I decided that using RLP for all variable length fields will be the best option,
not risking codebase with gnarly custom encoding/decoding implementations.</p>
<h3 id="store-y_parity-and-protected_bit-instead-of-v"><a class="header" href="#store-y_parity-and-protected_bit-instead-of-v">Store <code>y_parity</code> and <code>protected_bit</code> instead of <code>v</code></a></h3>
<p>Only legacy type transactions can be optionally protected. If protected(<a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155</a>), <code>v = 2 * ChainID + 35 + y_parity</code>.
Else, <code>v = 27 + y_parity</code>. For other types of transactions, <code>v = y_parity</code>.
We store <code>y_parity</code>, which is single bit per L2 transaction.
We store <code>protected_bit</code>, which is single bit per L2 legacy type transactions to indicate that tx is protected.</p>
<p>This optimization will benefit more when ratio between number of legacy type transactions over number of transactions
excluding deposit tx is higher.
Deposit transactions are excluded in batches and are never written at L1 so excluded while analyzing.</p>
<h3 id="adjust-txs-data-layout-for-better-compression"><a class="header" href="#adjust-txs-data-layout-for-better-compression">Adjust <code>txs</code> Data Layout for Better Compression</a></h3>
<p>There are (8 choose 2) * 6! = 20160 permutations of ordering fields of <code>txs</code>.
It is not 8! because <code>contract_creation_bits</code> must be first decoded in order to decode <code>tx_tos</code>.
We experimented to find out the best layout for compression.
It turned out placing random data together(<code>TxSigs</code>, <code>TxTos</code>, <code>TxDatas</code>),
then placing leftovers helped gzip to gain more size reduction.</p>
<h3 id="fee_recipients-encoding-scheme"><a class="header" href="#fee_recipients-encoding-scheme"><code>fee_recipients</code> Encoding Scheme</a></h3>
<p>Let <code>K</code> := number of unique fee recipients(cardinality) per span batch. Let <code>N</code> := number of L2 blocks.
If we naively encode each fee recipients by concatenating every fee recipients, it will need <code>20 * N</code> bytes.
If we manage <code>fee_recipients_idxs</code> and <code>fee_recipients_set</code>, It will need at most <code>max uvarint size * N = 8 * N</code>,
<code>20 * K</code> bytes each. If <code>20 * N &gt; 8 * N + 20 * K</code> then maintaining an index of fee recipients is reduces the size.</p>
<p>we thought sequencer rotation happens not much often, so assumed that <code>K</code> will be much lesser than <code>N</code>.
The assumption makes upper inequality to hold. Therefore, we decided to manage <code>fee_recipients_idxs</code> and
<code>fee_recipients_set</code> separately. This adds complexity but reduces data.</p>
<h2 id="how-derivation-works-with-span-batch"><a class="header" href="#how-derivation-works-with-span-batch">How derivation works with Span Batch?</a></h2>
<ul>
<li>Block Timestamp
<ul>
<li>The first L2 block's block timestamp is <code>rel_timestamp + L2Genesis.Timestamp</code>.</li>
<li>Then we can derive other blocks timestamp by adding L2 block time for each.</li>
</ul>
</li>
<li>L1 Origin Number
<ul>
<li>The parent of the first L2 block's L1 origin number is <code>l1_origin_num - sum(origin_bits)</code></li>
<li>Then we can derive other blocks' L1 origin number with <code>origin_bits</code></li>
<li><code>ith block's L1 origin number = (i-1)th block's L1 origin number + (origin_bits[i] ? 1 : 0)</code></li>
</ul>
</li>
<li>L1 Origin Hash
<ul>
<li>We only need the <code>l1_origin_check</code>, the truncated L1 origin hash of the last L2 block of Span Batch.</li>
<li>If the last block references canonical L1 chain as its origin,
we can ensure the all other blocks' origins are consistent with the canonical L1 chain.</li>
</ul>
</li>
<li>Parent hash
<ul>
<li>In V0 Batch spec, we need batch's parent hash to validate if batch's parent is consistent with current L2 safe head.</li>
<li>But in the case of Span Batch, because it contains consecutive L2 blocks in the span,
we do not need to validate all blocks' parent hash except the first block.</li>
</ul>
</li>
<li>Transactions
<ul>
<li>Deposit transactions can be derived from its L1 origin, identical with V0 batch.</li>
<li>User transactions can be derived by following way:
<ul>
<li>Recover <code>V</code> value of TX signature from <code>y_parity_bits</code> and L2 chainId, as described in optimization strategies.</li>
<li>When parsing <code>tx_tos</code>, <code>contract_creation_bits</code> is used to determine if the TX has <code>to</code> value or not.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<h3 id="channel-reader-batch-decoding-1"><a class="header" href="#channel-reader-batch-decoding-1">Channel Reader (Batch Decoding)</a></h3>
<p>The Channel Reader decodes the span-batch, as described in the <a href="protocol/span-batches.html#span-batch-format">span-batch format</a>.</p>
<p>A set of derived attributes is computed as described above. Then cached with the decoded result:</p>
<h3 id="batch-queue-1"><a class="header" href="#batch-queue-1">Batch Queue</a></h3>
<p>A span-batch is buffered as a singular large batch,
by its starting timestamp (transformed <code>rel_timestamp</code>).</p>
<p>Span-batches share the same queue with v0 batches: batches are processed in L1 inclusion order.</p>
<p>A set of modified validation rules apply to the span-batches.</p>
<p>Rules are enforced with the <a href="protocol/derivation.html#batch-queue">contextual definitions</a> as v0-batch validation:
<code>epoch</code>, <code>inclusion_block_number</code>, <code>next_timestamp</code></p>
<p>Definitions:</p>
<ul>
<li><code>batch</code> as defined in the <a href="protocol/span-batches.html#span-batch-format">Span batch format section</a>.</li>
<li><code>prev_l2_block</code> is the L2 block from the current safe chain,
whose timestamp is at <code>span_start.timestamp - l2_block_time</code></li>
</ul>
<p>Span-batch rules, in validation order:</p>
<ul>
<li><code>batch_origin</code> is determined like with singular batches:
<ul>
<li><code>batch.epoch_num == epoch.number+1</code>:
<ul>
<li>If <code>next_epoch</code> is not known -&gt; <code>undecided</code>:
i.e. a batch that changes the L1 origin cannot be processed until we have the L1 origin data.</li>
<li>If known, then define <code>batch_origin</code> as <code>next_epoch</code></li>
</ul>
</li>
</ul>
</li>
<li><code>batch_origin.timestamp &lt; span_batch_upgrade_timestamp</code> -&gt; <code>drop</code>:
i.e. enforce the <a href="protocol/span-batches.html#span-batch-activation-rule">span batch upgrade activation rule</a>.</li>
<li><code>span_start.timestamp &gt; next_timestamp</code> -&gt; <code>future</code>: i.e. the batch must be ready to process,
but does not have to start exactly at the <code>next_timestamp</code>, since it can overlap with previously processed blocks,</li>
<li><code>span_end.timestamp &lt; next_timestamp</code> -&gt; <code>drop</code>: i.e. the batch must have at least one new block to process.</li>
<li>If there's no <code>prev_l2_block</code> in the current safe chain -&gt; <code>drop</code>: i.e. the timestamp must be aligned.</li>
<li><code>batch.parent_check != prev_l2_block.hash[:20]</code> -&gt; <code>drop</code>:
i.e. the checked part of the parent hash must be equal to the same part of the corresponding L2 block hash.</li>
<li>Sequencing-window checks:
<ul>
<li>Note: The sequencing window is enforced for the <em>batch as a whole</em>:
if the batch was partially invalid instead, it would drop the oldest L2 blocks,
which makes the later L2 blocks invalid.</li>
<li>Variables:
<ul>
<li><code>origin_changed_bit = origin_bits[0]</code>: <code>true</code> if the first L2 block changed its L1 origin, <code>false</code> otherwise.</li>
<li><code>start_epoch_num = batch.l1_origin_num - sum(origin_bits) + (origin_changed_bit ? 1 : 0)</code></li>
<li><code>end_epoch_num = batch.l1_origin_num</code></li>
</ul>
</li>
<li>Rules:
<ul>
<li><code>start_epoch_num + sequence_window_size &lt; inclusion_block_number</code> -&gt; <code>drop</code>:
i.e. the batch must be included timely.</li>
<li><code>start_epoch_num &gt; prev_l2_block.l1_origin.number + 1</code> -&gt; <code>drop</code>:
i.e. the L1 origin cannot change by more than one L1 block per L2 block.</li>
<li>If <code>batch.l1_origin_check</code> does not match the canonical L1 chain at <code>end_epoch_num</code> -&gt; <code>drop</code>:
verify the batch is intended for this L1 chain.
<ul>
<li>After upper <code>l1_origin_check</code> check is passed, we don't need to check if the origin
is past <code>inclusion_block_number</code> because of the following invariant.</li>
<li>Invariant: the epoch-num in the batch is always less than the inclusion block number,
if and only if the L1 epoch hash is correct.</li>
</ul>
</li>
<li><code>start_epoch_num &lt; prev_l2_block.l1_origin.number</code> -&gt; <code>drop</code>:
epoch number cannot be older than the origin of parent block</li>
</ul>
</li>
</ul>
</li>
<li>Max Sequencer time-drift checks:
<ul>
<li>Note: The max time-drift is enforced for the <em>batch as a whole</em>, to keep the possible output variants small.</li>
<li>Variables:
<ul>
<li><code>block_input</code>: an L2 block from the span-batch,
with L1 origin as derived from the <code>origin_bits</code> and now established canonical L1 chain.</li>
<li><code>next_epoch</code>: <code>block_input.origin</code>'s next L1 block.
It may reach to the next origin outside the L1 origins of the span.</li>
</ul>
</li>
<li>Rules:
<ul>
<li>For each <code>block_input</code> whose timestamp is greater than <code>safe_head.timestamp</code>:
<ul>
<li><code>block_input.timestamp &lt; block_input.origin.time</code> -&gt; <code>drop</code>: enforce the min L2 timestamp rule.</li>
<li><code>block_input.timestamp &gt; block_input.origin.time + max_sequencer_drift</code>: enforce the L2 timestamp drift rule,
but with exceptions to preserve above min L2 timestamp invariant:
<ul>
<li><code>len(block_input.transactions) == 0</code>:
<ul>
<li><code>origin_bits[i] == 0</code>: <code>i</code> is the index of <code>block_input</code> in the span batch.
So this implies the block_input did not advance the L1 origin,
and must thus be checked against <code>next_epoch</code>.
<ul>
<li>If <code>next_epoch</code> is not known -&gt; <code>undecided</code>:
without the next L1 origin we cannot yet determine if time invariant could have been kept.</li>
<li>If <code>block_input.timestamp &gt;= next_epoch.time</code> -&gt; <code>drop</code>:
the batch could have adopted the next L1 origin without breaking the <code>L2 time &gt;= L1 time</code> invariant.</li>
</ul>
</li>
</ul>
</li>
<li><code>len(block_input.transactions) &gt; 0</code>: -&gt; <code>drop</code>:
when exceeding the sequencer time drift, never allow the sequencer to include transactions.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>And for all transactions:
<ul>
<li><code>drop</code> if the <code>batch.tx_datas</code> list contains a transaction
that is invalid or derived by other means exclusively:
<ul>
<li>any transaction that is empty (zero length <code>tx_data</code>)</li>
<li>any <a href="protocol/../glossary.html#deposited-transaction-type">deposited transactions</a> (identified by the transaction type prefix byte in <code>tx_data</code>)</li>
</ul>
</li>
</ul>
</li>
<li>Overlapped blocks checks:
<ul>
<li>Note: If the span batch overlaps the current L2 safe chain, we must validate all overlapped blocks.</li>
<li>Variables:
<ul>
<li><code>block_input</code>: an L2 block derived from the span-batch.</li>
<li><code>safe_block</code>: an L2 block from the current L2 safe chain, at same timestamp as <code>block_input</code></li>
</ul>
</li>
<li>Rules:
<ul>
<li>For each <code>block_input</code>, whose timestamp is less than <code>next_timestamp</code>:
<ul>
<li><code>block_input.l1_origin.number != safe_block.l1_origin.number</code> -&gt; <code>drop</code></li>
<li><code>block_input.transactions != safe_block.transactions</code> -&gt; <code>drop</code>
<ul>
<li>compare excluding deposit transactions</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Once validated, the batch-queue then emits a block-input for each of the blocks included in the span-batch.
The next derivation stage is thus only aware of individual block inputs, similar to the previous V0 batch,
although not strictly a &quot;v0 batch&quot; anymore.</p>
<h3 id="batcher"><a class="header" href="#batcher">Batcher</a></h3>
<p>Instead of transforming L2 blocks into batches,
the blocks should be buffered to form a span-batch.</p>
<p>Ideally the L2 blocks are buffered as block-inputs, to maximize the span of blocks covered by the span-batch:
span-batches of single L2 blocks do not increase efficiency as much as with larger spans.</p>
<p>This means that the <code>(c *channelBuilder) AddBlock</code> function is changed to
not directly call <code>(co *ChannelOut) AddBatch</code> but defer that until a minimum number of blocks have been buffered.</p>
<p>Output-size estimation of the queued up blocks is not possible until the span-batch is written to the channel.
Past a given number of blocks, the channel may be written for estimation, and then re-written if more blocks arrive.</p>
<p>The <a href="protocol/batcher.html">batcher functionality</a> stays the same otherwise: unsafe blocks are transformed into batches,
encoded in compressed channels, and then split into frames for submission to L1.
Batcher implementations can implement different heuristics and re-attempts to build the most gas-efficient data-txs.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="batch-submitter"><a class="header" href="#batch-submitter">Batch Submitter</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/batcher.html#overview">Overview</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>The batch submitter, also referred to as the batcher, is the entity submitting the L2 sequencer data to L1,
to make it available for verifiers.</p>
<p>The format of the data transactions is defined in the <a href="protocol/derivation.html">derivation spec</a>:
the data is constructed from L2 blocks in the reverse order as it is derived from data into L2 blocks.</p>
<p>The timing, operation and transaction signing is implementation-specific: any data can be submitted at any time,
but only the data that matches the <a href="protocol/derivation.html">derivation spec</a> rules will be valid from the verifier perspective.</p>
<p>The most minimal batcher implementation can be defined as a loop of the following operations:</p>
<ol>
<li>See if the <code>unsafe</code> L2 block number is past the <code>safe</code> block number: <code>unsafe</code> data needs to be submitted.</li>
<li>Iterate over all unsafe L2 blocks, skip any that were previously submitted.</li>
<li>Open a channel, buffer all the L2 block data to be submitted,
while applying the encoding and compression as defined in the <a href="protocol/derivation.html">derivation spec</a>.</li>
<li>Pull frames from the channel to fill data transactions with, until the channel is empty.</li>
<li>Submit the data transactions to L1</li>
</ol>
<p>The L2 view of safe/unsafe does not instantly update after data is submitted, nor when it gets confirmed on L1,
so special care may have to be taken to not duplicate data submissions.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="safe-liveness-checking"><a class="header" href="#safe-liveness-checking">Safe Liveness Checking</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/safe-liveness-checking.html#liveness-checking-mechanism">Liveness checking Mechanism</a></li>
<li><a href="protocol/safe-liveness-checking.html#liveness-checking-methodology">Liveness checking methodology</a>
<ul>
<li><a href="protocol/safe-liveness-checking.html#the-liveness-guard">The liveness guard</a></li>
<li><a href="protocol/safe-liveness-checking.html#the-liveness-module">The liveness module</a></li>
<li><a href="protocol/safe-liveness-checking.html#owner-removal-call-flow">Owner removal call flow</a></li>
<li><a href="protocol/safe-liveness-checking.html#shutdown">Shutdown</a></li>
<li><a href="protocol/safe-liveness-checking.html#security-properties">Security Properties</a>
<ul>
<li><a href="protocol/safe-liveness-checking.html#in-the-guard">In the guard</a></li>
<li><a href="protocol/safe-liveness-checking.html#in-the-module">In the module</a></li>
</ul>
</li>
<li><a href="protocol/safe-liveness-checking.html#interdependency-between-the-guard-and-module">Interdependency between the guard and module</a></li>
</ul>
</li>
<li><a href="protocol/safe-liveness-checking.html#operational-considerations">Operational considerations</a>
<ul>
<li><a href="protocol/safe-liveness-checking.html#manual-validation-of-new-owner-liveness">Manual validation of new owner liveness</a></li>
<li><a href="protocol/safe-liveness-checking.html#deploying-the-liveness-checking-system">Deploying the liveness checking system</a></li>
<li><a href="protocol/safe-liveness-checking.html#modify-the-liveness-checking-system">Modify the liveness checking system</a>
<ul>
<li><a href="protocol/safe-liveness-checking.html#replacing-the-module">Replacing the module</a></li>
<li><a href="protocol/safe-liveness-checking.html#replacing-the-guard">Replacing the guard</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="liveness-checking-mechanism"><a class="header" href="#liveness-checking-mechanism">Liveness checking Mechanism</a></h2>
<p>The Security Council uses a specially extended Safe multisig contract to ensure that
any loss of access to a signer's keys is identified and addressed within a predictable period of
time.</p>
<p>This mechanism is intended only to be used to remove signers who have lost access to their keys, or
are otherwise inactive. It is not intended to be used to remove signers who are acting in bad faith,
or any other subjective criteria, such cases should be addressed by governance, and the removal
handled via the standard Safe ownership management functionality.</p>
<h2 id="liveness-checking-methodology"><a class="header" href="#liveness-checking-methodology">Liveness checking methodology</a></h2>
<p>This is achieved using two types of contracts which the Safe contract has built-in support for:</p>
<ol>
<li><strong>Guard contracts:</strong> can execute pre- and post- transaction checks.</li>
<li><strong>Module contracts:</strong> a contract which is added to the Safe by the signers, and thenceforth is
authorized to execute transactions via the Safe. This means the module must properly implement
auth conditions internally.</li>
</ol>
<h3 id="the-liveness-guard"><a class="header" href="#the-liveness-guard">The liveness guard</a></h3>
<p>For implementing liveness checks a <code>LivenessGuard</code> is created which receives the signatures from
each executed transaction, and tracks the latest time at which a transaction was signed by each
signer. This time is made publicly available by calling a <code>lastLive(address)(Timestamp)</code> method.</p>
<p>Owners are recorded in this mapping in one of 4 ways:</p>
<ol>
<li>Upon deployment, the guard reads the current set of owners from the Safe contract.</li>
<li>When a new owner is added to the safe. Similarly, when an owner is removed from the Safe, its
entry is deleted from the mapping.</li>
<li>When a transaction is executed, the signatures on that transaction are passed to the guard and
used to identify the signers. If more than the required number of signatures is provided, they
are ignored.</li>
<li>An owner may call the contract's <code>showLiveness()()</code> method directly in order to prove liveness.</li>
</ol>
<p>Note that the first two methods do not require the owner to actually sign anything. However these mechanisms
are necessary to prevent new owners from being removed before they have had a chance to show liveness.</p>
<h3 id="the-liveness-module"><a class="header" href="#the-liveness-module">The liveness module</a></h3>
<p>A <code>LivenessModule</code> is also created which does the following:</p>
<ol>
<li>Has a function <code>removeOwners()</code> that anyone may call to specify one or more owners to be removed from the
Safe.</li>
<li>The Module would then check the <code>LivenessGuard.lastLive()</code> to determine if the signer is
eligible for removal.</li>
<li>If so, it will call the Safe's <code>removeSigner()</code> to remove the non-live signer, and if necessary
reduce the threshold.</li>
<li>When a member is removed, the signing parameters are modified such that <code>M/N</code> is the lowest ratio
which remains greater than or equal to 75%. Using integer math, this can be expressed as <code>M = (N * 75 + 99) / 100</code>.</li>
</ol>
<h3 id="owner-removal-call-flow"><a class="header" href="#owner-removal-call-flow">Owner removal call flow</a></h3>
<p>The following diagram illustrates the flow for removing a single owner. The <code>verifyFinalState</code>
box indicates calls to the Safe which ensure the final state is valid.</p>
<pre class="mermaid">sequenceDiagram
    participant User
    participant LivenessModule
    participant LivenessGuard
    participant Safe
    User-&gt;&gt;LivenessModule: removeOwners([previousOwner], [owner])
    LivenessModule-&gt;&gt;LivenessGuard: lastLive(owner)
    LivenessModule-&gt;&gt;Safe: getOwners()
    LivenessModule-&gt;&gt;Safe: removeOwner(previousOwner, owner)

    alt verifyFinalState
    LivenessModule-&gt;&gt;Safe: getOwners()
    LivenessModule-&gt;&gt;Safe: getThreshold()
    LivenessModule-&gt;&gt;Safe: getGuard()
    end
</pre>
<h3 id="shutdown"><a class="header" href="#shutdown">Shutdown</a></h3>
<p>In the unlikely event that the signer set (<code>N</code>) is reduced below the allowed minimum number of
owners, then (and only then) is a shutdown mechanism activated which removes the existing
signers, and hands control of the multisig over to a predetermined entity.</p>
<h3 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h3>
<p>The following security properties must be upheld:</p>
<h4 id="in-the-guard"><a class="header" href="#in-the-guard">In the guard</a></h4>
<ol>
<li>Signatures are assigned to the correct signer.</li>
<li>Non-signers are unable to create a record of having signed.</li>
<li>An owner cannot be censored or griefed such that their signing is not recorded.</li>
<li>Owners may demonstrate liveness either by signing a transaction or by calling directly to the
guard.</li>
<li>It must be impossible for the guard's <code>checkTransaction</code> or <code>checkAfterExecution</code> method to
permanently revert given any calldata and the current state.</li>
<li>The guard correctly handles updates to the owners list, such that new owners are recorded, and
removed owners are deleted.
<ol>
<li>An <code>ownersBefore</code> enumerable set variable is used to accomplish this, it must be emptied at
the end of the <code>checkAfterExecution</code> call.</li>
</ol>
</li>
</ol>
<h4 id="in-the-module"><a class="header" href="#in-the-module">In the module</a></h4>
<ol>
<li>During a shutdown the module correctly removes all signers, and converts the safe to a 1 of 1.</li>
<li>The module only removes an owner if they have not demonstrated liveness during the interval, or
if enough other owners have been removed to activate the shutdown mechanism.</li>
<li>The module correctly sets the Safe's threshold upon removing a signer.</li>
</ol>
<p>Note: neither the module nor guard attempt to prevent a quorum of owners from removing either the liveness
module or guard. There are legitimate reasons they might wish to do so. Moreover, if such a quorum
of owners exists, there is no benefit to removing them, as they are defacto 'sufficiently live'.</p>
<h3 id="interdependency-between-the-guard-and-module"><a class="header" href="#interdependency-between-the-guard-and-module">Interdependency between the guard and module</a></h3>
<p>The guard has no dependency on the module, and can be used independently to track liveness of
Safe owners.</p>
<p>This means that the module can be removed or replaced without any affect on the guard.</p>
<p>The module however does have a dependency on the guard; if the guard is removed from the Safe, then
the module will no longer be functional and calls to its <code>removeOwners</code> function will revert.</p>
<h2 id="operational-considerations"><a class="header" href="#operational-considerations">Operational considerations</a></h2>
<h3 id="manual-validation-of-new-owner-liveness"><a class="header" href="#manual-validation-of-new-owner-liveness">Manual validation of new owner liveness</a></h3>
<p>As <a href="protocol/safe-liveness-checking.html#the-liveness-guard">noted above</a> newly added owners are recorded in the guard without
necessarily having signed a transaction. Off-chain validation of the liveness of an address must
therefore be done prior to adding a new owner.</p>
<h3 id="deploying-the-liveness-checking-system"><a class="header" href="#deploying-the-liveness-checking-system">Deploying the liveness checking system</a></h3>
<p>The module and guard are intended to be deployed and installed on the safe in the following
sequence:</p>
<ol>
<li>Deploy the guard contract 2. The guard's constructor will read the Safe's owners and set a timestamp</li>
<li>Deploy the module.</li>
<li>Set the guard on the safe.</li>
<li>Enable the module on the safe.</li>
</ol>
<p>This order of operations is necessary to satisfy the constructor checks in the module, and is
intended to prevent owners from being immediately removable.</p>
<p>Note that changes to the owners set should not be made between the time the module is deployed, and
when it is enabled on the Safe, otherwise the checks made in the module's constructor may be
invalidated. If such changes are made, a new module should be deployed.</p>
<h3 id="modify-the-liveness-checking-system"><a class="header" href="#modify-the-liveness-checking-system">Modify the liveness checking system</a></h3>
<p>Changes to the liveness checking system should be done in the following manner:</p>
<h4 id="replacing-the-module"><a class="header" href="#replacing-the-module">Replacing the module</a></h4>
<p>The module can safely be removed without affecting the operation of the guard. A new module can then
be added.</p>
<p>Note: none of the module's parameters are modifiable. In order to update the security properties
enforced by the module, it must be replaced.</p>
<h4 id="replacing-the-guard"><a class="header" href="#replacing-the-guard">Replacing the guard</a></h4>
<p>The safe can only have one guard contract at a time, and if the guard is removed the module will
cease to function. This does not affect the ability of the Safe to operate normally, however the
module should be removed as a best practice.</p>
<p>If a new guard is added, eg. as a means of upgrading it, then a new module will also need to be
deployed and enabled. Once both the guard and module have been removed, they can be replaced
according to the steps in the <a href="protocol/safe-liveness-checking.html#deploying-the-liveness-checking-system">Deployment</a> section above.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="predeploys"><a class="header" href="#predeploys">Predeploys</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/predeploys.html#overview">Overview</a></li>
<li><a href="protocol/predeploys.html#legacymessagepasser">LegacyMessagePasser</a></li>
<li><a href="protocol/predeploys.html#l2tol1messagepasser">L2ToL1MessagePasser</a></li>
<li><a href="protocol/predeploys.html#deployerwhitelist">DeployerWhitelist</a></li>
<li><a href="protocol/predeploys.html#legacyerc20eth">LegacyERC20ETH</a></li>
<li><a href="protocol/predeploys.html#weth9">WETH9</a></li>
<li><a href="protocol/predeploys.html#l2crossdomainmessenger">L2CrossDomainMessenger</a></li>
<li><a href="protocol/predeploys.html#l2standardbridge">L2StandardBridge</a></li>
<li><a href="protocol/predeploys.html#l1blocknumber">L1BlockNumber</a></li>
<li><a href="protocol/predeploys.html#gaspriceoracle">GasPriceOracle</a></li>
<li><a href="protocol/predeploys.html#l1block">L1Block</a></li>
<li><a href="protocol/predeploys.html#proxyadmin">ProxyAdmin</a></li>
<li><a href="protocol/predeploys.html#sequencerfeevault">SequencerFeeVault</a></li>
<li><a href="protocol/predeploys.html#optimismmintableerc20factory">OptimismMintableERC20Factory</a></li>
<li><a href="protocol/predeploys.html#optimismmintableerc721factory">OptimismMintableERC721Factory</a></li>
<li><a href="protocol/predeploys.html#basefeevault">BaseFeeVault</a></li>
<li><a href="protocol/predeploys.html#l1feevault">L1FeeVault</a></li>
<li><a href="protocol/predeploys.html#schemaregistry">SchemaRegistry</a></li>
<li><a href="protocol/predeploys.html#eas">EAS</a></li>
<li><a href="protocol/predeploys.html#create2deployer">create2Deployer</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p><a href="protocol/../glossary.html#predeployed-contract-predeploy">Predeployed smart contracts</a> exist on Optimism
at predetermined addresses in the genesis state. They are similar to precompiles but instead run
directly in the EVM instead of running native code outside of the EVM.</p>
<p>Predeploys are used instead of precompiles to make it easier for multiclient
implementations as well as allowing for more integration with hardhat/foundry
network forking.</p>
<p>Predeploy addresses exist in 1 byte namespace <code>0x42000000000000000000000000000000000000xx</code>.
Proxies are set at each possible predeploy address except for the
<code>GovernanceToken</code> and the <code>ProxyAdmin</code>.</p>
<p>The <code>LegacyERC20ETH</code> predeploy lives at a special address <code>0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000</code>
and there is no proxy deployed at that account.</p>
<p>The following table includes each of the predeploys. The system version
indicates when the predeploy was introduced. The possible values are <code>Legacy</code>
or <code>Bedrock</code> or <code>Canyon</code>. Deprecated contracts should not be used.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Address</th><th>Introduced</th><th>Deprecated</th><th>Proxied</th></tr></thead><tbody>
<tr><td>LegacyMessagePasser</td><td>0x4200000000000000000000000000000000000000</td><td>Legacy</td><td>Yes</td><td>Yes</td></tr>
<tr><td>DeployerWhitelist</td><td>0x4200000000000000000000000000000000000002</td><td>Legacy</td><td>Yes</td><td>Yes</td></tr>
<tr><td>LegacyERC20ETH</td><td>0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000</td><td>Legacy</td><td>Yes</td><td>No</td></tr>
<tr><td>WETH9</td><td>0x4200000000000000000000000000000000000006</td><td>Legacy</td><td>No</td><td>No</td></tr>
<tr><td>L2CrossDomainMessenger</td><td>0x4200000000000000000000000000000000000007</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>L2StandardBridge</td><td>0x4200000000000000000000000000000000000010</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>SequencerFeeVault</td><td>0x4200000000000000000000000000000000000011</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>OptimismMintableERC20Factory</td><td>0x4200000000000000000000000000000000000012</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>L1BlockNumber</td><td>0x4200000000000000000000000000000000000013</td><td>Legacy</td><td>Yes</td><td>Yes</td></tr>
<tr><td>GasPriceOracle</td><td>0x420000000000000000000000000000000000000F</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>GovernanceToken</td><td>0x4200000000000000000000000000000000000042</td><td>Legacy</td><td>No</td><td>No</td></tr>
<tr><td>L1Block</td><td>0x4200000000000000000000000000000000000015</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>L2ToL1MessagePasser</td><td>0x4200000000000000000000000000000000000016</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>L2ERC721Bridge</td><td>0x4200000000000000000000000000000000000014</td><td>Legacy</td><td>No</td><td>Yes</td></tr>
<tr><td>OptimismMintableERC721Factory</td><td>0x4200000000000000000000000000000000000017</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>ProxyAdmin</td><td>0x4200000000000000000000000000000000000018</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>BaseFeeVault</td><td>0x4200000000000000000000000000000000000019</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>L1FeeVault</td><td>0x420000000000000000000000000000000000001a</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>SchemaRegistry</td><td>0x4200000000000000000000000000000000000020</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>EAS</td><td>0x4200000000000000000000000000000000000021</td><td>Bedrock</td><td>No</td><td>Yes</td></tr>
<tr><td>create2Deployer</td><td>0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2</td><td>Canyon</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="legacymessagepasser"><a class="header" href="#legacymessagepasser">LegacyMessagePasser</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/legacy/LegacyMessagePasser.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000000</code></p>
<p>The <code>LegacyMessagePasser</code> contract stores commitments to withdrawal
transactions before the Bedrock upgrade. A merkle proof to a particular
storage slot that commits to the withdrawal transaction is used as part
of the withdrawing transaction on L1. The expected account that includes
the storage slot is hardcoded into the L1 logic. After the bedrock upgrade,
the <code>L2ToL1MessagePasser</code> is used instead. Finalizing withdrawals from this
contract will no longer be supported after the Bedrock and is only left
to allow for alternative bridges that may depend on it. This contract does
not forward calls to the <code>L2ToL1MessagePasser</code> and calling it is considered
a no-op in context of doing withdrawals through the <code>CrossDomainMessenger</code>
system.</p>
<p>Any pending withdrawals that have not been finalized are migrated to the
<code>L2ToL1MessagePasser</code> as part of the upgrade so that they can still be
finalized.</p>
<h2 id="l2tol1messagepasser"><a class="header" href="#l2tol1messagepasser">L2ToL1MessagePasser</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000016</code></p>
<p>The <code>L2ToL1MessagePasser</code> stores commitments to withdrawal transactions.
When a user is submitting the withdrawing transaction on L1, they provide a
proof that the transaction that they withdrew on L2 is in the <code>sentMessages</code>
mapping of this contract.</p>
<p>Any withdrawn ETH accumulates into this contract on L2 and can be
permissionlessly removed from the L2 supply by calling the <code>burn()</code> function.</p>
<h2 id="deployerwhitelist"><a class="header" href="#deployerwhitelist">DeployerWhitelist</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/legacy/DeployerWhitelist.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000002</code></p>
<p>The <code>DeployerWhitelist</code> is a predeploy that was used to provide additional safety
during the initial phases of Optimism.
It previously defined the accounts that are allowed to deploy contracts to the network.</p>
<p>Arbitrary contract deployment was subsequently enabled and it is not possible to turn
off. In the legacy system, this contract was hooked into <code>CREATE</code> and
<code>CREATE2</code> to ensure that the deployer was allowlisted.</p>
<p>In the Bedrock system, this contract will no longer be used as part of the
<code>CREATE</code> codepath.</p>
<p>This contract is deprecated and its usage should be avoided.</p>
<h2 id="legacyerc20eth"><a class="header" href="#legacyerc20eth">LegacyERC20ETH</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/legacy/LegacyERC20ETH.sol">Implementation</a></p>
<p>Address: <code>0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000</code></p>
<p>The <code>LegacyERC20ETH</code> predeploy represents all ether in the system before the
Bedrock upgrade. All ETH was represented as an ERC20 token and users could opt
into the ERC20 interface or the native ETH interface.</p>
<p>The upgrade to Bedrock migrates all ether out of this contract and moves it to
its native representation. All of the stateful methods in this contract will
revert after the Bedrock upgrade.</p>
<p>This contract is deprecated and its usage should be avoided.</p>
<h2 id="weth9"><a class="header" href="#weth9">WETH9</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/vendor/WETH9.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000006</code></p>
<p><code>WETH9</code> is the standard implementation of Wrapped Ether on Optimism. It is a
commonly used contract and is placed as a predeploy so that it is at a
deterministic address across Optimism based networks.</p>
<h2 id="l2crossdomainmessenger"><a class="header" href="#l2crossdomainmessenger">L2CrossDomainMessenger</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2CrossDomainMessenger.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000007</code></p>
<p>The <code>L2CrossDomainMessenger</code> gives a higher level API for sending cross domain
messages compared to directly calling the <code>L2ToL1MessagePasser</code>.
It maintains a mapping of L1 messages that have been relayed to L2
to prevent replay attacks and also allows for replayability if the L1 to L2
transaction reverts on L2.</p>
<p>Any calls to the <code>L1CrossDomainMessenger</code> on L1 are serialized such that they
go through the <code>L2CrossDomainMessenger</code> on L2.</p>
<p>The <code>relayMessage</code> function executes a transaction from the remote domain while
the <code>sendMessage</code> function sends a transaction to be executed on the remote
domain through the remote domain's <code>relayMessage</code> function.</p>
<h2 id="l2standardbridge"><a class="header" href="#l2standardbridge">L2StandardBridge</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2StandardBridge.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000010</code></p>
<p>The <code>L2StandardBridge</code> is a higher level API built on top of the
<code>L2CrossDomainMessenger</code> that gives a standard interface for sending ETH or
ERC20 tokens across domains.</p>
<p>To deposit a token from L1 to L2, the <code>L1StandardBridge</code> locks the token and
sends a cross domain message to the <code>L2StandardBridge</code> which then mints the
token to the specified account.</p>
<p>To withdraw a token from L2 to L1, the user will burn the token on L2 and the
<code>L2StandardBridge</code> will send a message to the <code>L1StandardBridge</code> which will
unlock the underlying token and transfer it to the specified account.</p>
<p>The <code>OptimismMintableERC20Factory</code> can be used to create an ERC20 token contract
on a remote domain that maps to an ERC20 token contract on the local domain
where tokens can be deposited to the remote domain. It deploys an
<code>OptimismMintableERC20</code> which has the interface that works with the
<code>StandardBridge</code>.</p>
<p>This contract can also be deployed on L1 to allow for L2 native tokens to be
withdrawn to L1.</p>
<h2 id="l1blocknumber"><a class="header" href="#l1blocknumber">L1BlockNumber</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/legacy/L1BlockNumber.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000013</code></p>
<p>The <code>L1BlockNumber</code> returns the last known L1 block number. This contract was
introduced in the legacy system and should be backwards compatible by calling
out to the <code>L1Block</code> contract under the hood.</p>
<p>It is recommended to use the <code>L1Block</code> contract for getting information about
L1 on L2.</p>
<h2 id="gaspriceoracle"><a class="header" href="#gaspriceoracle">GasPriceOracle</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/GasPriceOracle.sol">Implementation</a></p>
<p>Address: <code>0x420000000000000000000000000000000000000F</code></p>
<p>In the legacy system, the <code>GasPriceOracle</code> was a permissioned contract
that was pushed the L1 base fee and the L2 gas price by an offchain actor.
The offchain actor observes the L1 blockheaders to get the
L1 base fee as well as the gas usage on L2 to compute what the L2 gas price
should be based on a congestion control algorithm.</p>
<p>After Bedrock, the <code>GasPriceOracle</code> is no longer a permissioned contract
and only exists to preserve the API for offchain gas estimation. The
function <code>getL1Fee(bytes)</code> accepts an unsigned RLP transaction and will return
the L1 portion of the fee. This fee pays for using L1 as a data availability
layer and should be added to the L2 portion of the fee, which pays for
execution, to compute the total transaction fee.</p>
<p>The values used to compute the L1 portion of the fee prior to the Ecotone upgrade are:</p>
<ul>
<li>scalar</li>
<li>overhead</li>
<li>decimals</li>
</ul>
<p>After the Bedrock upgrade, these values are instead managed by the
<code>SystemConfig</code> contract on L1. The <code>scalar</code> and <code>overhead</code> values
are sent to the <code>L1Block</code> contract each block and the <code>decimals</code> value
has been hardcoded to 6.</p>
<p>Following the Ecotone upgrade, the values used for L1 fee computation are:</p>
<ul>
<li>l1BaseFeeScalar</li>
<li>l1BlobBaseFeeScalar</li>
<li>decimals</li>
</ul>
<p>These values are managed by the <code>SystemConfig</code> contract on the L1. The<code>decimals</code> remains hardcoded
to 6, and the old <code>scalar</code> and <code>overhead</code> values are ignored.</p>
<h2 id="l1block"><a class="header" href="#l1block">L1Block</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L1Block.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000015</code></p>
<p>The <a href="protocol/../glossary.html#l1-attributes-predeployed-contract">L1Block</a> was introduced in Bedrock and is responsible for
maintaining L1 context in L2. This allows for L1 state to be accessed in L2.</p>
<h2 id="proxyadmin"><a class="header" href="#proxyadmin">ProxyAdmin</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/universal/ProxyAdmin.sol">ProxyAdmin</a>
Address: <code>0x4200000000000000000000000000000000000018</code></p>
<p>The <code>ProxyAdmin</code> is the owner of all of the proxy contracts set at the
predeploys. It is itself behind a proxy. The owner of the <code>ProxyAdmin</code> will
have the ability to upgrade any of the other predeploy contracts.</p>
<h2 id="sequencerfeevault"><a class="header" href="#sequencerfeevault">SequencerFeeVault</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SequencerFeeVault.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000011</code></p>
<p>The <code>SequencerFeeVault</code> accumulates any transaction priority fee and is the value of
<code>block.coinbase</code>.
When enough fees accumulate in this account, they can be withdrawn to an immutable L1 address.</p>
<p>To change the L1 address that fees are withdrawn to, the contract must be
upgraded by changing its proxy's implementation key.</p>
<h2 id="optimismmintableerc20factory"><a class="header" href="#optimismmintableerc20factory">OptimismMintableERC20Factory</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/universal/OptimismMintableERC20Factory.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000012</code></p>
<p>The <code>OptimismMintableERC20Factory</code> is responsible for creating ERC20 contracts on L2 that can be
used for depositing native L1 tokens into. These ERC20 contracts can be created permisionlessly
and implement the interface required by the <code>StandardBridge</code> to just work with deposits and withdrawals.</p>
<p>Each ERC20 contract that is created by the <code>OptimismMintableERC20Factory</code> allows for the <code>L2StandardBridge</code> to mint
and burn tokens, depending on if the user is depositing from L1 to L2 or withdrawing from L2 to L1.</p>
<h2 id="optimismmintableerc721factory"><a class="header" href="#optimismmintableerc721factory">OptimismMintableERC721Factory</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/universal/OptimismMintableERC721Factory.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000017</code></p>
<p>The <code>OptimismMintableERC721Factory</code> is responsible for creating ERC721 contracts on L2 that can be used for
depositing native L1 NFTs into.</p>
<h2 id="basefeevault"><a class="header" href="#basefeevault">BaseFeeVault</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/BaseFeeVault.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000019</code></p>
<p>The <code>BaseFeeVault</code> predeploy receives the base fees on L2. The base fee is not
burnt on L2 like it is on L1. Once the contract has received a certain amount
of fees, the ETH can be withdrawn to an immutable address on
L1.</p>
<h2 id="l1feevault"><a class="header" href="#l1feevault">L1FeeVault</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L1FeeVault.sol">Implementation</a></p>
<p>Address: <code>0x420000000000000000000000000000000000001a</code></p>
<p>The <code>L1FeeVault</code> predeploy receives the L1 portion of the transaction fees.
Once the contract has received a certain amount of fees, the ETH can be
withdrawn to an immutable address on L1.</p>
<h2 id="schemaregistry"><a class="header" href="#schemaregistry">SchemaRegistry</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/EAS/SchemaRegistry.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000020</code></p>
<p>The <code>SchemaRegistry</code> predeploy implements the global attestation schemas for the <code>Ethereum Attestation Service</code>
protocol.</p>
<h2 id="eas"><a class="header" href="#eas">EAS</a></h2>
<p><a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/EAS/EAS.sol">Implementation</a></p>
<p>Address: <code>0x4200000000000000000000000000000000000021</code></p>
<p>The <code>EAS</code> predeploy implements the <code>Ethereum Attestation Service</code> protocol.</p>
<h2 id="create2deployer"><a class="header" href="#create2deployer">create2Deployer</a></h2>
<p><a href="https://github.com/mdehoog/create2deployer/blob/69b9a8e112b15f9257ce8c62b70a09914e7be29c/contracts/Create2Deployer.sol">Implementation</a></p>
<p>The create2Deployer is a nice Solidity wrapper around the CREATE2 opcode. It provides the following ABI.</p>
<pre><code class="language-solidity">    /**
     * @dev Deploys a contract using `CREATE2`. The address where the
     * contract will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `value`.
     * - if `value` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function deploy(uint256 value, bytes32 salt, bytes memory code) public;
    /**
     * @dev Deployment of the {ERC1820Implementer}.
     * Further information: https://eips.ethereum.org/EIPS/eip-1820
     */
    function deployERC1820Implementer(uint256 value, bytes32 salt);
    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy}.
     * Any change in the `bytecodeHash` or `salt` will result in a new destination address.
     */
    function computeAddress(bytes32 salt, bytes32 codeHash) public view returns (address);
    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a
     * contract located at `deployer`. If `deployer` is this contract's address, returns the
     * same value as {computeAddress}.
     */
    function computeAddressWithDeployer(
        bytes32 salt,
        bytes32 codeHash,
        address deployer
    ) public pure returns (address);
</code></pre>
<p>Address: <code>0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2</code></p>
<p>When Canyon activates, the contract code at <code>0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2</code> is set to
<code>0x6080604052600436106100435760003560e01c8063076c37b21461004f578063481286e61461007157806356299481146100ba57806366cfa057146100da57600080fd5b3661004a57005b600080fd5b34801561005b57600080fd5b5061006f61006a366004610327565b6100fa565b005b34801561007d57600080fd5b5061009161008c366004610327565b61014a565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b3480156100c657600080fd5b506100916100d5366004610349565b61015d565b3480156100e657600080fd5b5061006f6100f53660046103ca565b610172565b61014582826040518060200161010f9061031a565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082820381018352601f90910116604052610183565b505050565b600061015683836102e7565b9392505050565b600061016a8484846102f0565b949350505050565b61017d838383610183565b50505050565b6000834710156101f4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f437265617465323a20696e73756666696369656e742062616c616e636500000060448201526064015b60405180910390fd5b815160000361025f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f437265617465323a2062797465636f6465206c656e677468206973207a65726f60448201526064016101eb565b8282516020840186f5905073ffffffffffffffffffffffffffffffffffffffff8116610156576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f437265617465323a204661696c6564206f6e206465706c6f790000000000000060448201526064016101eb565b60006101568383305b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b61014e806104ad83390190565b6000806040838503121561033a57600080fd5b50508035926020909101359150565b60008060006060848603121561035e57600080fd5b8335925060208401359150604084013573ffffffffffffffffffffffffffffffffffffffff8116811461039057600080fd5b809150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000806000606084860312156103df57600080fd5b8335925060208401359150604084013567ffffffffffffffff8082111561040557600080fd5b818601915086601f83011261041957600080fd5b81358181111561042b5761042b61039b565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156104715761047161039b565b8160405282815289602084870101111561048a57600080fd5b826020860160208301376000602084830101528095505050505050925092509256fe608060405234801561001057600080fd5b5061012e806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063249cb3fa14602d575b600080fd5b603c603836600460b1565b604e565b60405190815260200160405180910390f35b60008281526020818152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff16608857600060aa565b7fa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b45b9392505050565b6000806040838503121560c357600080fd5b82359150602083013573ffffffffffffffffffffffffffffffffffffffff8116811460ed57600080fd5b80915050925092905056fea26469706673582212205ffd4e6cede7d06a5daf93d48d0541fc68189eeb16608c1999a82063b666eb1164736f6c63430008130033a2646970667358221220fdc4a0fe96e3b21c108ca155438d37c9143fb01278a3c1d274948bad89c564ba64736f6c63430008130033</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="preinstalls"><a class="header" href="#preinstalls">Preinstalls</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/preinstalls.html#overview">Overview</a></li>
<li><a href="protocol/preinstalls.html#safe">Safe</a></li>
<li><a href="protocol/preinstalls.html#safel2">SafeL2</a></li>
<li><a href="protocol/preinstalls.html#multisend">MultiSend</a></li>
<li><a href="protocol/preinstalls.html#multisendcallonly">MultiSendCallOnly</a></li>
<li><a href="protocol/preinstalls.html#safesingletonfactory">SafeSingletonFactory</a></li>
<li><a href="protocol/preinstalls.html#multicall3">Multicall3</a></li>
<li><a href="protocol/preinstalls.html#arachnids-deterministic-deployment-proxy">Arachnid's Deterministic Deployment Proxy</a></li>
<li><a href="protocol/preinstalls.html#permit2">Permit2</a></li>
<li><a href="protocol/preinstalls.html#erc-4337-entrypoint">ERC-4337 EntryPoint</a></li>
<li><a href="protocol/preinstalls.html#erc-4337-sendercreator">ERC-4337 SenderCreator</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p><a href="protocol/../glossary.html#preinstalled-contract-preinstall">Preinstalled smart contracts</a> exist on Optimism
at predetermined addresses in the genesis state. They are similar to precompiles but instead run
directly in the EVM instead of running native code outside of the EVM and are developed by third
parties unaffiliated with the Optimism Collective.</p>
<p>These preinstalls are commonly deployed smart contracts that are being placed at genesis for convenience.
It's important to note that these contracts do not have the same security guarantees
as <a href="protocol/../glossary.html#predeployed-contract-predeploy">Predeployed smart contracts</a>.</p>
<p>The following table includes each of the preinstalls.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Safe</td><td>0x69f4D1788e39c87893C980c06EdF4b7f686e2938</td></tr>
<tr><td>SafeL2</td><td>0xfb1bffC9d739B8D520DaF37dF666da4C687191EA</td></tr>
<tr><td>MultiSend</td><td>0x998739BFdAAdde7C933B942a68053933098f9EDa</td></tr>
<tr><td>MultiSendCallOnly</td><td>0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B</td></tr>
<tr><td>SafeSingletonFactory</td><td>0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7</td></tr>
<tr><td>Multicall3</td><td>0xcA11bde05977b3631167028862bE2a173976CA11</td></tr>
<tr><td>Arachnid's Deterministic Deployment Proxy</td><td>0x4e59b44847b379578588920cA78FbF26c0B4956C</td></tr>
<tr><td>Permit2</td><td>0x000000000022D473030F116dDEE9F6B43aC78BA3</td></tr>
<tr><td>ERC-4337 EntryPoint</td><td>0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789</td></tr>
<tr><td>ERC-4337 SenderCreator</td><td>0x7fc98430eaedbb6070b35b39d798725049088348</td></tr>
</tbody></table>
</div>
<h2 id="safe"><a class="header" href="#safe">Safe</a></h2>
<p><a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafe.sol">Implementation</a></p>
<p>Address: <code>0x69f4D1788e39c87893C980c06EdF4b7f686e2938</code></p>
<p>A multisignature wallet with support for confirmations using signed messages based on ERC191.
Differs from <a href="protocol/preinstalls.html#safel2">SafeL2</a> by not emitting events to save gas.</p>
<h2 id="safel2"><a class="header" href="#safel2">SafeL2</a></h2>
<p><a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafeL2.sol">Implementation</a></p>
<p>Address: <code>0xfb1bffC9d739B8D520DaF37dF666da4C687191EA</code></p>
<p>A multisignature wallet with support for confirmations using signed messages based on ERC191.
Differs from <a href="protocol/preinstalls.html#safe">Safe</a> by emitting events.</p>
<h2 id="multisend"><a class="header" href="#multisend">MultiSend</a></h2>
<p><a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/libraries/MultiSend.sol">Implementation</a></p>
<p>Address: <code>0x998739BFdAAdde7C933B942a68053933098f9EDa</code></p>
<p>Allows to batch multiple transactions into one.</p>
<h2 id="multisendcallonly"><a class="header" href="#multisendcallonly">MultiSendCallOnly</a></h2>
<p><a href="https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/libraries/MultiSendCallOnly.sol">Implementation</a></p>
<p>Address: <code>0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B</code></p>
<p>Allows to batch multiple transactions into one, but only calls.</p>
<h2 id="safesingletonfactory"><a class="header" href="#safesingletonfactory">SafeSingletonFactory</a></h2>
<p><a href="https://github.com/safe-global/safe-singleton-factory/blob/v1.0.17/source/deterministic-deployment-proxy.yul">Implementation</a></p>
<p>Address: <code>0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7</code></p>
<p>Singleton factory used by Safe-related contracts based on
<a href="protocol/preinstalls.html#arachnids-deterministic-deployment-proxy">Arachnid's Deterministic Deployment Proxy</a>.</p>
<p>The original library used a pre-signed transaction without a chain ID to allow deployment on different chains.
Some chains do not allow such transactions to be submitted; therefore, this contract will provide the same factory
that can be deployed via a pre-signed transaction that includes the chain ID. The key that is used to sign is
controlled by the Safe team.</p>
<h2 id="multicall3"><a class="header" href="#multicall3">Multicall3</a></h2>
<p><a href="https://github.com/mds1/multicall/blob/v3.1.0/src/Multicall3.sol">Implementation</a></p>
<p>Address: <code>0xcA11bde05977b3631167028862bE2a173976CA11</code></p>
<p><code>Multicall3</code> has two main use cases:</p>
<ul>
<li>Aggregate results from multiple contract reads into a single JSON-RPC request.</li>
<li>Execute multiple state-changing calls in a single transaction.</li>
</ul>
<h2 id="arachnids-deterministic-deployment-proxy"><a class="header" href="#arachnids-deterministic-deployment-proxy">Arachnid's Deterministic Deployment Proxy</a></h2>
<p><a href="https://github.com/Arachnid/deterministic-deployment-proxy/blob/v1.0.0/source/deterministic-deployment-proxy.yul">Implementation</a></p>
<p>Address: <code>0x4e59b44847b379578588920cA78FbF26c0B4956C</code></p>
<p>This contract can deploy other contracts with a deterministic address on any chain using <code>CREATE2</code>. The <code>CREATE2</code>
call will deploy a contract (like <code>CREATE</code> opcode) but instead of the address being
<code>keccak256(rlp([deployer_address, nonce]))</code> it instead uses the hash of the contract's bytecode and a salt.
This means that a given deployer address will deploy the
same code to the same address no matter when or where they issue the deployment. The deployer is deployed
ith a one-time-use-account, so no matter what chain the deployer is on, its address will always be the same. This
means the only variables in determining the address of your contract are its bytecode hash and the provided salt.</p>
<p>Between the use of <code>CREATE2</code> opcode and the one-time-use-account for the deployer, this contracts ensures
that a given contract will exist at the exact same address on every chain, but without having to use the
same gas pricing or limits every time.</p>
<h2 id="permit2"><a class="header" href="#permit2">Permit2</a></h2>
<p><a href="https://github.com/Uniswap/permit2/blob/0x000000000022D473030F116dDEE9F6B43aC78BA3/src/Permit2.sol">Implementation</a></p>
<p>Address: <code>0x000000000022D473030F116dDEE9F6B43aC78BA3</code></p>
<p>Permit2 introduces a low-overhead, next-generation token approval/meta-tx system to make token approvals easier,
more secure, and more consistent across applications.</p>
<h2 id="erc-4337-entrypoint"><a class="header" href="#erc-4337-entrypoint">ERC-4337 EntryPoint</a></h2>
<p><a href="https://github.com/eth-infinitism/account-abstraction/blob/v0.6.0/contracts/core/EntryPoint.sol">Implementation</a></p>
<p>Address: <code>0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789</code></p>
<p>This contract verifies and executes the bundles of ERC-4337
<a href="https://www.erc4337.io/docs/understanding-ERC-4337/user-operation">UserOperations</a> sent to it.</p>
<h2 id="erc-4337-sendercreator"><a class="header" href="#erc-4337-sendercreator">ERC-4337 SenderCreator</a></h2>
<p><a href="https://github.com/eth-infinitism/account-abstraction/blob/v0.6.0/contracts/core/SenderCreator.sol">Implementation</a></p>
<p>Address: <code>0x7fc98430eaedbb6070b35b39d798725049088348</code></p>
<p>Helper contract for <a href="protocol/preinstalls.html#erc-4337-entrypoint">EntryPoint</a>, to call <code>userOp.initCode</code> from a &quot;neutral&quot; address,
which is explicitly not <code>EntryPoint</code> itself.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="superchain-configuration"><a class="header" href="#superchain-configuration">Superchain Configuration</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/superchain-configuration.html#overview">Overview</a></li>
<li><a href="protocol/superchain-configuration.html#configurable-values">Configurable values</a></li>
<li><a href="protocol/superchain-configuration.html#configuration-data-flow">Configuration data flow</a>
<ul>
<li><a href="protocol/superchain-configuration.html#pausability">Pausability</a>
<ul>
<li><a href="protocol/superchain-configuration.html#paused-identifiers">Paused identifiers</a></li>
<li><a href="protocol/superchain-configuration.html#scope-of-pausability">Scope of pausability</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>The SuperchainConfig contract is used to manage global configuration values for multiple OP Chains within
a single Superchain network.</p>
<h2 id="configurable-values"><a class="header" href="#configurable-values">Configurable values</a></h2>
<p>Configurability of the Superchain is currently limited to two values:</p>
<p>The <code>SuperchainConfig</code> contract manages the following configuration values:</p>
<ul>
<li><code>PAUSED_SLOT</code>: A boolean value indicating whether the Superchain is paused.</li>
<li><code>GUARDIAN_SLOT</code>: The address of the guardian, which can pause and unpause the system.</li>
</ul>
<h2 id="configuration-data-flow"><a class="header" href="#configuration-data-flow">Configuration data flow</a></h2>
<p>All contracts which read from the <code>SuperchainConfig</code> contract hold its address as storage values
in the proxy account, and call directly to it when reading configuration data.</p>
<pre class="mermaid">flowchart TD
StandardBridge --&gt; SuperchainConfig
L1ERC721Bridge --&gt; SuperchainConfig
L1CrossDomainMessenger --&gt; SuperchainConfig
OptimismPortal --&gt; SuperchainConfig
</pre>
<h3 id="pausability"><a class="header" href="#pausability">Pausability</a></h3>
<p>The Superchain pause feature is a safety mechanism designed to temporarily halt withdrawals from the system in
an emergency situation. The Guardian role is authorized to pause and unpause the system.</p>
<h4 id="paused-identifiers"><a class="header" href="#paused-identifiers">Paused identifiers</a></h4>
<p>When the system is paused the <code>Paused(string identifier)</code> event is emitted. This allows for the
caller to provide additional information to be used during incident response.</p>
<h4 id="scope-of-pausability"><a class="header" href="#scope-of-pausability">Scope of pausability</a></h4>
<p>The pause applies specifically to withdrawals of assets from the L1 bridge contracts. The L2 bridge contracts
are not pausable, on the basis that issues on L2 can be addressed more easily by a hard fork in the consensus
layer.</p>
<p>When the Pause is activated, the following methods are disabled:</p>
<ol>
<li><code>OptimismPortal.proveWithdrawalTransaction()</code></li>
<li><code>OptimismPortal.finalizeWithdrawalTransaction()</code></li>
<li><code>L1CrossDomainMessenger.relayMessage()</code></li>
<li><code>StandardBridge.finalizeBridgeERC20()</code></li>
<li><code>StandardBridge.finalizeBridgeETH()</code></li>
<li><code>L1ERC721Bridge.finalizeBridgeERC721()</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="superchain-upgrades"><a class="header" href="#superchain-upgrades">Superchain Upgrades</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/superchain-upgrades.html#overview">Overview</a></li>
<li><a href="protocol/superchain-upgrades.html#protocol-version">Protocol Version</a>
<ul>
<li><a href="protocol/superchain-upgrades.html#protocol-version-format">Protocol Version Format</a>
<ul>
<li><a href="protocol/superchain-upgrades.html#build-identifier">Build identifier</a></li>
<li><a href="protocol/superchain-upgrades.html#major-versions">Major versions</a></li>
<li><a href="protocol/superchain-upgrades.html#minor-versions">Minor versions</a></li>
<li><a href="protocol/superchain-upgrades.html#patch-versions">Patch versions</a></li>
<li><a href="protocol/superchain-upgrades.html#pre-releases">Pre-releases</a></li>
</ul>
</li>
<li><a href="protocol/superchain-upgrades.html#protocol-version-exposure">Protocol Version Exposure</a></li>
</ul>
</li>
<li><a href="protocol/superchain-upgrades.html#superchain-target">Superchain Target</a>
<ul>
<li><a href="protocol/superchain-upgrades.html#superchain-version-signaling">Superchain Version signaling</a></li>
<li><a href="protocol/superchain-upgrades.html#protocolversions-l1-contract"><code>ProtocolVersions</code> L1 contract</a></li>
</ul>
</li>
<li><a href="protocol/superchain-upgrades.html#activation-rules">Activation rules</a>
<ul>
<li><a href="protocol/superchain-upgrades.html#l2-block-number-based-activation-deprecated">L2 Block-number based activation (deprecated)</a></li>
<li><a href="protocol/superchain-upgrades.html#l2-block-timestamp-based-activation">L2 Block-timestamp based activation</a></li>
</ul>
</li>
<li><a href="protocol/superchain-upgrades.html#op-stack-protocol-versions">OP-Stack Protocol versions</a></li>
<li><a href="protocol/superchain-upgrades.html#post-bedrock-network-upgrades">Post-Bedrock Network upgrades</a>
<ul>
<li><a href="protocol/superchain-upgrades.html#regolith">Regolith</a></li>
</ul>
</li>
<li><a href="protocol/superchain-upgrades.html#canyon">Canyon</a></li>
<li><a href="protocol/superchain-upgrades.html#delta">Delta</a></li>
<li><a href="protocol/superchain-upgrades.html#ecotone">Ecotone</a></li>
<li><a href="protocol/superchain-upgrades.html#fjord">Fjord</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>Superchain upgrades, also known as forks or hardforks, implement consensus-breaking changes.</p>
<p>A Superchain upgrade requires the node software to support up to a given Protocol Version.
The version indicates support, the upgrade indicates the activation of new functionality.</p>
<p>This document lists the protocol versions of the OP-Stack, starting at the Bedrock upgrade,
as well as the default Superchain Targets.</p>
<p>Activation rule parameters of network upgrades are configured as part of the Superchain Target specification:
chains following the same Superchain Target upgrade synchronously.</p>
<h2 id="protocol-version"><a class="header" href="#protocol-version">Protocol Version</a></h2>
<p>The Protocol Version documents the progression of the total set of canonical OP-Stack specifications.
Components of the OP-Stack implement the subset of their respective protocol component domain,
up to a given Protocol Version of the OP-Stack.</p>
<p>OP-Stack mods, i.e. non-canonical extensions to the OP-Stack, are not included in the versioning of the Protocol.
Instead, mods must specify which upstream Protocol Version they are based on and where breaking changes are made.
This ensures tooling of the OP-Stack can be shared and collaborated on with OP-Stack mods.</p>
<p>The Protocol Version is NOT a hardfork identifier, but rather indicates software-support for a well-defined set
of features introduced in past and future hardforks, not the activation of said hardforks.</p>
<p>Changes that can be included in prospective Protocol Versions may be included in the specifications as proposals,
with explicit notice of the Protocol Version they are based on.
This enables an iterative integration process into the canonical set of specifications,
but does not guarantee the proposed specifications become canonical.</p>
<p>Note that the Protocol Version only applies to the Protocol specifications with the Superchain Targets specified within.
This versioning is independent of the <a href="https://semver.org/">Semver</a> versioning used in OP Stack smart-contracts,
and the <a href="https://semver.org/">Semver</a>-versioned reference software of the OP-Stack.</p>
<h3 id="protocol-version-format"><a class="header" href="#protocol-version-format">Protocol Version Format</a></h3>
<p>The Protocol Version is <a href="https://semver.org/">Semver</a>-compatible.
It is encoded as a single 32 bytes long <code>&lt;protocol version&gt;</code>.
The version must be encoded as 32 bytes of <code>DATA</code> in JSON RPC usage.</p>
<p>The encoding is typed, to ensure future-compatibility.</p>
<pre><code class="language-text">&lt;protocol version&gt; ::= &lt;version-type&gt;&lt;typed-payload&gt;
&lt;version-type&gt; ::= &lt;uint8&gt;
&lt;typed-payload&gt; ::= &lt;31 bytes&gt;
</code></pre>
<p>version-type <code>0</code>:</p>
<pre><code class="language-text">&lt;reserved&gt;&lt;build&gt;&lt;major&gt;&lt;minor&gt;&lt;patch&gt;&lt;pre-release&gt;
&lt;reserved&gt; ::= &lt;7 zeroed bytes&gt;
&lt;build&gt; ::= &lt;8 bytes&gt;
&lt;major&gt; ::= &lt;big-endian uint32&gt;
&lt;minor&gt; ::= &lt;big-endian uint32&gt;
&lt;patch&gt; ::= &lt;big-endian uint32&gt;
&lt;pre-release&gt; ::= &lt;big-endian uint32&gt;
</code></pre>
<p>The <code>&lt;reserved&gt;</code> bytes of the Protocol Version are reserved for future extensions.</p>
<p>Protocol versions with a different <code>&lt;version-type&gt;</code> should not be compared directly.</p>
<h4 id="build-identifier"><a class="header" href="#build-identifier">Build identifier</a></h4>
<p>The <code>&lt;build&gt;</code> identifier, as defined by <a href="https://semver.org/">Semver</a>, is ignored when determining version precedence.
The <code>&lt;build&gt;</code> must be non-zero to apply to the protocol version.</p>
<p>Modifications of the OP-Stack should define a <code>&lt;build&gt;</code> to distinguish from the canonical protocol feature-set.
Changes to the <code>&lt;build&gt;</code> may be encoded in the <code>&lt;build&gt;</code> itself to stay aligned with the upstream protocol.
The major/minor/patch versions should align with that of the upstream protocol that the modifications are based on.
Users of the protocol can choose to implement custom support for the alternative <code>&lt;build&gt;</code>,
but may work out of the box if the major features are consistent with that of the upstream protocol version.</p>
<p>The 8 byte <code>&lt;build&gt;</code> identifier may be presented as a string for human readability if the contents are alpha-numeric,
including <code>-</code> and <code>.</code>, as outlined in the <a href="https://semver.org/">Semver</a> format specs. Trailing <code>0</code> bytes can be used for padding.
It may be presented as <code>0x</code>-prefixed hex string otherwise.</p>
<h4 id="major-versions"><a class="header" href="#major-versions">Major versions</a></h4>
<p>Major version changes indicate support for new consensus-breaking functionality.
Major versions should retain support for functionality of previous major versions for
syncing/indexing of historical chain data.
Implementations may drop support for previous Major versions, when there are viable alternatives,
e.g. <code>l2geth</code> for pre-Bedrock data.</p>
<h4 id="minor-versions"><a class="header" href="#minor-versions">Minor versions</a></h4>
<p>Minor version changes indicate support for backward compatible extensions,
including backward-compatible additions to the set of chains in a Superchain Target.
Backward-compatibility is defined by the requirement for existing end-users to upgrade nodes and tools or not.
Minor version changes may also include optional offchain functionality, such as additional syncing protocols.</p>
<h4 id="patch-versions"><a class="header" href="#patch-versions">Patch versions</a></h4>
<p>Patch version changes indicate backward compatible bug fixes and improvements.</p>
<h4 id="pre-releases"><a class="header" href="#pre-releases">Pre-releases</a></h4>
<p>Pre-releases of the protocol are proposals: these are not stable targets for production usage.
A pre-release might not satisfy the intended compatibility requirements as denoted by its associated normal version.
The <code>&lt;pre-release&gt;</code> must be non-zero to apply to the protocol version.
The <code>&lt;pre-release&gt;</code> <code>0</code>-value is reserved for non-prereleases, i.e. <code>v3.1.0</code> is higher than <code>v3.1.0-1</code>.</p>
<p>Node-software may support a pre-release, but must not activate any protocol changes without the user explicitly
opting in through the means of a feature-flag or configuration change.</p>
<p>A pre-release is not an official version and is meant for protocol developers to communicate an experimental changeset
before the changeset is reviewed by governance. Pre-releases are subject to change.</p>
<h3 id="protocol-version-exposure"><a class="header" href="#protocol-version-exposure">Protocol Version Exposure</a></h3>
<p>The Protocol Version is not exposed to the application-layer environment:
hardforks already expose the change of functionality upon activation as required,
and the Protocol Version is meant for offchain usage only.
The protocol version indicates support rather than activation of functionality.
There is one exception however: signaling by onchain components to offchain components.
More about this in <a href="protocol/superchain-upgrades.html#superchain-version-signaling">Superchain Version signaling</a>.</p>
<h2 id="superchain-target"><a class="header" href="#superchain-target">Superchain Target</a></h2>
<p>Changes to the L2 state-transition function are transitioned into deterministically across all nodes
through an <strong>activation rule</strong>.</p>
<p>Changes to L1 smart-contracts must be compatible with the latest activated L2 functionality,
and are executed through <strong>L1 contract-upgrades</strong>.</p>
<p>A Superchain Target defines a set of activation rules and L1 contract upgrades shared between OP-Stack chains,
to upgrade the chains collectively.</p>
<h3 id="superchain-version-signaling"><a class="header" href="#superchain-version-signaling">Superchain Version signaling</a></h3>
<p>Each Superchain Target tracks the protocol changes, and signals the <code>recommended</code> and <code>required</code>
Protocol Version ahead of activation of new breaking functionality.</p>
<ul>
<li><code>recommended</code>: a signal in advance of a network upgrade, to alert users of the protocol change to be prepared for.
Node software is recommended to signal the recommendation to users through logging and metrics.</li>
<li><code>required</code>: a signal shortly in advance of a breaking network upgrade, to alert users of breaking changes.
Users may opt in to elevated alerts or preventive measures, to ensure consistency with the upgrade.</li>
</ul>
<p>Signaling is done through a L1 smart-contract that is monitored by the OP-Stack software.
Not all components of the OP-Stack are required to directly monitor L1 however:
cross-component APIs like the Engine API may be used to forward the Protocol Version signals,
to keep components encapsulated from L1.
See <a href="protocol/exec-engine.html#enginesignalopstackversionv1"><code>engine_signalOPStackVersionV1</code></a>.</p>
<h3 id="protocolversions-l1-contract"><a class="header" href="#protocolversions-l1-contract"><code>ProtocolVersions</code> L1 contract</a></h3>
<p>The <code>ProtocolVersions</code> contract on L1 enables L2 nodes to pick up on superchain protocol version signals.</p>
<p>The interface is:</p>
<ul>
<li>Required storage slot: <code>bytes32(uint256(keccak256(&quot;protocolversion.required&quot;)) - 1)</code></li>
<li>Recommended storage slot: <code>bytes32(uint256(keccak256(&quot;protocolversion.recommended&quot;)) - 1)</code></li>
<li>Required getter: <code>required()</code> returns <code>ProtocolVersion</code></li>
<li>Recommended getter <code>recommended()</code> returns <code>ProtocolVersion</code></li>
<li>Version updates also emit a typed event:
<code>event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data)</code></li>
</ul>
<h2 id="activation-rules"><a class="header" href="#activation-rules">Activation rules</a></h2>
<p>The below L2-block based activation rules may be applied in two contexts:</p>
<ul>
<li>The rollup node, specified through the rollup configuration (known as <code>rollup.json</code>),
referencing L2 blocks (or block input-attributes) that pass through the derivation pipeline.</li>
<li>The execution engine, specified through the chain configuration (known as the <code>config</code> part of <code>genesis.json</code>),
referencing blocks or input-attributes that are part of, or applied to, the L2 chain.</li>
</ul>
<p>For both types of configurations, some activation parameters may apply to all chains within the superchain,
and are then retrieved from the superchain target configuration.</p>
<h3 id="l2-block-number-based-activation-deprecated"><a class="header" href="#l2-block-number-based-activation-deprecated">L2 Block-number based activation (deprecated)</a></h3>
<p>Activation rule: <code>upgradeNumber != null &amp;&amp; block.number &gt;= upgradeNumber</code></p>
<p>Starting at, and including, the L2 <code>block</code> with <code>block.number &gt;= upgradeNumber</code>, the upgrade rules apply.
If the upgrade block-number <code>upgradeNumber</code> is not specified in the configuration, the upgrade is ignored.</p>
<p>This block number based method has commonly been used in L1 up until the Bellatrix/Paris upgrade, a.k.a. The Merge,
which was upgraded through special rules.</p>
<p>This method is not superchain-compatible, as the activation-parameter is chain-specific
(different chains may have different block-heights at the same moment in time).</p>
<p>This applies to the L2 block number, not to the L1-origin block number.
This means that an L2 upgrade may be inactive, and then active, without changing the L1-origin.</p>
<h3 id="l2-block-timestamp-based-activation"><a class="header" href="#l2-block-timestamp-based-activation">L2 Block-timestamp based activation</a></h3>
<p>Activation rule: <code>upgradeTime != null &amp;&amp; block.timestamp &gt;= upgradeTime</code></p>
<p>Starting at, and including, the L2 <code>block</code> with <code>block.timestamp &gt;= upgradeTime</code>, the upgrade rules apply.
If the upgrade block-timestamp <code>upgradeTime</code> is not specified in the configuration, the upgrade is ignored.</p>
<p>This is the preferred superchain upgrade activation-parameter type:
it is synchronous between all L2 chains and compatible with post-Merge timestamp-based chain upgrades in L1.</p>
<p>This applies to the L2 block timestamp, not to the L1-origin block timestamp.
This means that an L2 upgrade may be inactive, and then active, without changing the L1-origin.</p>
<p>This timestamp based method has become the default on L1 after the Bellatrix/Paris upgrade, a.k.a. The Merge,
because it can be planned in accordance with beacon-chain epochs and slots.</p>
<p>Note that the L2 version is not limited to timestamps that match L1 beacon-chain slots or epochs.
A timestamp may be chosen to be synchronous with a specific slot or epoch on L1,
but the matching L1-origin information may not be present at the time of activation on L2.</p>
<h2 id="op-stack-protocol-versions"><a class="header" href="#op-stack-protocol-versions">OP-Stack Protocol versions</a></h2>
<ul>
<li><code>v1.0.0</code>: 2021 Jan 16th - Mainnet Soft Launch, based on OVM.
(<a href="https://medium.com/ethereum-optimism/mainnet-soft-launch-7cacc0143cd5">announcement</a>)</li>
<li><code>v1.1.0</code>: 2021 Aug 19th - Community launch.
(<a href="https://medium.com/ethereum-optimism/community-launch-7c9a2a9d3e84">announcement</a>)</li>
<li><code>v2.0.0</code>: 2021 Nov 12th - the EVM-Equivalence update, also known as OVM 2.0 and chain regenesis.
(<a href="https://twitter.com/optimismfnd/status/1458953238867165192">announcement</a>)</li>
<li><code>v2.1.0</code>: 2022 May 31st - Optimism Collective.
(<a href="https://optimism.mirror.xyz/gQWKlrDqHzdKPsB1iUnI-cVN3v0NvsWnazK7ajlt1fI">announcement</a>).</li>
<li><code>v3.0.0-1</code>: 2023 Jan 13th - Bedrock pre-release, deployed on OP-Goerli, and later Base-Goerli.</li>
<li><code>v3.0.0</code>: 2023 Jun 6th - Bedrock, including the Regolith hardfork improvements, first deployed on OP-Mainnet.</li>
<li><code>v4.0.0</code>: 2024 Jan 11th - Canyon network upgrade.
<a href="https://gov.optimism.io/t/final-upgrade-proposal-2-canyon-network-upgrade/7088">Governance proposal</a>.</li>
<li><code>v5.0.0-1</code>: Delta - Proposed for Feb 22, 2024.
<a href="https://gov.optimism.io/t/final-upgrade-proposal-3-delta-network-upgrade/7310">Governance Proposal</a></li>
<li><code>v6.0.0-1</code>: Ecotone - Very experimental, in development.</li>
</ul>
<h2 id="post-bedrock-network-upgrades"><a class="header" href="#post-bedrock-network-upgrades">Post-Bedrock Network upgrades</a></h2>
<h3 id="regolith"><a class="header" href="#regolith">Regolith</a></h3>
<p>The Regolith upgrade, named after a material best described as &quot;deposited dust on top of a layer of bedrock&quot;,
implements minor changes to deposit processing, based on reports of the Sherlock Audit-contest and findings in
the Bedrock Optimism Goerli testnet.</p>
<p>Summary of changes:</p>
<ul>
<li>The <code>isSystemTx</code> boolean is disabled, system transactions now use the same gas accounting rules as regular deposits.</li>
<li>The actual deposit gas-usage is recorded in the receipt of the deposit transaction,
and subtracted from the L2 block gas-pool.
Unused gas of deposits is not refunded with ETH however, as it is burned on L1.</li>
<li>The <code>nonce</code> value of the deposit sender account, before the transaction state-transition, is recorded in a new
optional field (<code>depositNonce</code>), extending the transaction receipt (i.e. not present in pre-Regolith receipts).</li>
<li>The recorded deposit <code>nonce</code> is used to correct the transaction and receipt metadata in RPC responses,
including the <code>contractAddress</code> field of deposits that deploy contracts.</li>
<li>The <code>gas</code> and <code>depositNonce</code> data is committed to as part of the consensus-representation of the receipt,
enabling the data to be safely synced between independent L2 nodes.</li>
<li>The L1-cost function was corrected to more closely match pre-Bedrock behavior.</li>
</ul>
<p>The <a href="protocol/deposits.html">deposit specification</a> specifies the deposit changes of the Regolith upgrade in more detail.
The <a href="protocol/exec-engine.html">execution engine specification</a> specifies the L1 cost function difference.</p>
<p>The Regolith upgrade uses a <em>L2 block-timestamp</em> activation-rule, and is specified in both the
rollup-node (<code>regolith_time</code>) and execution engine (<code>config.regolithTime</code>).</p>
<h2 id="canyon"><a class="header" href="#canyon">Canyon</a></h2>
<p>The Canyon upgrade contains the Shapella upgrade from L1 and some minor protocol fixes.</p>
<ul>
<li>Shapella Upgrade
<ul>
<li><a href="https://eips.ethereum.org/EIPS/eip-3651">EIP-3651: Warm COINBASE</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-3855">EIP-3855: PUSH0 instruction</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-3860">EIP-3860: Limit and meter initcode</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-4895">EIP-4895: Beacon chain push withdrawals as operations</a>
<ul>
<li><a href="protocol/rollup-node-p2p.html#block-validation">Withdrawals are prohibited in P2P Blocks</a></li>
<li><a href="protocol/derivation.html#building-individual-payload-attributes">Withdrawals should be set to the empty array with Canyon</a></li>
</ul>
</li>
<li><a href="https://eips.ethereum.org/EIPS/eip-6049">EIP-6049: Deprecate SELFDESTRUCT</a></li>
</ul>
</li>
<li><a href="protocol/exec-engine.html#1559-parameters">Modifies the EIP-1559 Denominator</a></li>
<li><a href="protocol/derivation.html#reading">Channel Ordering Fix</a></li>
<li><a href="protocol/deposits.html#deposit-receipt">Adds the deposit nonce &amp; deposit nonce version to the deposit receipt hash</a></li>
<li><a href="protocol/predeploys.html#create2deployer">Deploys the create2Deployer to <code>0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2</code></a></li>
</ul>
<p>The Canyon upgrade uses a <em>L2 block-timestamp</em> activation-rule, and is specified in both the
rollup-node (<code>canyon_time</code>) and execution engine (<code>config.canyonTime</code>). Shanghai time in the
execution engine should be set to the same time as the Canyon time.</p>
<h2 id="delta"><a class="header" href="#delta">Delta</a></h2>
<p>The Delta upgrade consists of a single consensus-layer feature: <a href="protocol/span-batches.html">Span Batches</a>.</p>
<p>The Delta upgrade uses a <em>L2 block-timestamp</em> activation-rule, and is specified only in the rollup-node (<code>delta_time</code>).</p>
<h2 id="ecotone-1"><a class="header" href="#ecotone-1">Ecotone</a></h2>
<p>The Ecotone upgrade contains the Dencun upgrade from L1, and adopts EIP-4844 blobs for data-availability.</p>
<p>Dencun Upgrade:</p>
<ul>
<li>Cancun (Execution Layer):
<ul>
<li><a href="https://eips.ethereum.org/EIPS/eip-1153">EIP-1153: Transient storage opcodes</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844: Shard Blob Transactions</a>
<ul>
<li><a href="protocol/exec-engine.html#ecotone-disable-blob-transactions">Blob transactions are disabled</a></li>
</ul>
</li>
<li><a href="https://eips.ethereum.org/EIPS/eip-4788">EIP-4788: Beacon block root in the EVM</a>
<ul>
<li><a href="protocol/exec-engine.html#ecotone-beacon-block-root">The L1 beacon block root is embedded into L2</a></li>
<li><a href="protocol/derivation.html#ecotone-beacon-block-roots-contract-deployment-eip-4788">The Beacon roots contract deployment is automated</a></li>
</ul>
</li>
<li><a href="https://eips.ethereum.org/EIPS/eip-5656">EIP-5656: MCOPY - Memory copying instruction</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-6780">EIP-6780: SELFDESTRUCT only in same transaction</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-7516">EIP-7516: BLOBBASEFEE opcode</a>
<ul>
<li><a href="protocol/exec-engine.html#ecotone-disable-blob-transactions">BLOBBASEFEE always pushes 1 onto the stack</a></li>
</ul>
</li>
</ul>
</li>
<li>Deneb (Consensus Layer): <em>not applicable to L2</em>
<ul>
<li><a href="https://eips.ethereum.org/EIPS/eip-7044">EIP-7044: Perpetually Valid Signed Voluntary Exits</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-7045">EIP-7045: Increase Max Attestation Inclusion Slot</a></li>
<li><a href="https://eips.ethereum.org/EIPS/eip-7514">EIP-7514: Add Max Epoch Churn Limit</a></li>
</ul>
</li>
</ul>
<p>Data Availability (DA) upgrade:</p>
<ul>
<li>Blobs Data Availability: support blobs DA the <a href="protocol/derivation.html#ecotone-blob-retrieval">L1 Data-retrieval stage</a>.</li>
<li>Rollup fee update: support blobs DA in
<a href="protocol/exec-engine.html#ecotone-l1-cost-fee-changes-eip-4844-da">L1 Data Fee computation</a></li>
<li>Auto-upgrading and extension of the <a href="protocol/deposits.html#ecotone-l1block-upgrade">L1 Attributes Predeployed Contract</a>
(also known as <code>L1Block</code> predeploy)</li>
</ul>
<h2 id="fjord"><a class="header" href="#fjord">Fjord</a></h2>
<p>Name of the next upgrade after Ecotone. Placeholder for development coordination.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="system-config"><a class="header" href="#system-config">System Config</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="protocol/system_config.html#overview">Overview</a></li>
<li><a href="protocol/system_config.html#system-config-contents-version-0">System config contents (version 0)</a>
<ul>
<li><a href="protocol/system_config.html#batcherhash-bytes32"><code>batcherHash</code> (<code>bytes32</code>)</a></li>
<li><a href="protocol/system_config.html#scalars">Scalars</a>
<ul>
<li><a href="protocol/system_config.html#pre-ecotone-scalar-overhead-uint256uint256">Pre-Ecotone <code>scalar</code>, <code>overhead</code> (<code>uint256,uint256</code>)</a></li>
<li><a href="protocol/system_config.html#ecotone-scalar-overhead-uint256uint256-change">Ecotone <code>scalar</code>, <code>overhead</code> (<code>uint256,uint256</code>) change</a></li>
</ul>
</li>
<li><a href="protocol/system_config.html#gaslimit-uint64"><code>gasLimit</code> (<code>uint64</code>)</a></li>
<li><a href="protocol/system_config.html#unsafeblocksigner-address"><code>unsafeBlockSigner</code> (<code>address</code>)</a></li>
</ul>
</li>
<li><a href="protocol/system_config.html#writing-the-system-config">Writing the system config</a></li>
<li><a href="protocol/system_config.html#reading-the-system-config">Reading the system config</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p>The <code>SystemConfig</code> is a contract on L1 that can emit rollup configuration changes as log events.
The rollup <a href="protocol/derivation.html">block derivation process</a> picks up on these log events and applies the changes.</p>
<h2 id="system-config-contents-version-0"><a class="header" href="#system-config-contents-version-0">System config contents (version 0)</a></h2>
<p>Version 0 of the system configuration contract defines the following parameters:</p>
<h3 id="batcherhash-bytes32"><a class="header" href="#batcherhash-bytes32"><code>batcherHash</code> (<code>bytes32</code>)</a></h3>
<p>A versioned hash of the current authorized batcher sender(s), to rotate keys as batch-submitter.
The first byte identifies the version.</p>
<p>Version <code>0</code> embeds the current batch submitter ethereum address (<code>bytes20</code>) in the last 20 bytes of the versioned hash.</p>
<p>In the future this versioned hash may become a commitment to a more extensive configuration,
to enable more extensive redundancy and/or rotation configurations.</p>
<h3 id="scalars"><a class="header" href="#scalars">Scalars</a></h3>
<p>The L1 fee parameters, also known as Gas Price Oracle (GPO) parameters, are used to compute the L1
data fee applied to an L2 transaction. The specific parameters used depend on the upgrades that
are active.</p>
<p>Fee parameter updates are signaled to L2 through the <code>GAS_CONFIG</code> log-event of the <code>SystemConfig</code>.</p>
<h4 id="pre-ecotone-scalar-overhead-uint256uint256"><a class="header" href="#pre-ecotone-scalar-overhead-uint256uint256">Pre-Ecotone <code>scalar</code>, <code>overhead</code> (<code>uint256,uint256</code>)</a></h4>
<p>The <code>overhead</code> and <code>scalar</code> are consulted and passed to the L2 via L1 attribute info.</p>
<p>The values are interpreted as big-endian <code>uint256</code>.</p>
<h4 id="ecotone-scalar-overhead-uint256uint256-change"><a class="header" href="#ecotone-scalar-overhead-uint256uint256-change">Ecotone <code>scalar</code>, <code>overhead</code> (<code>uint256,uint256</code>) change</a></h4>
<p>After Ecotone activation:</p>
<ul>
<li>The <code>scalar</code> attribute encodes additional scalar information, in a versioned encoding scheme.</li>
<li>The <code>overhead</code> value is ignored: it does not affect the L2 state-transition output.</li>
</ul>
<p>The <code>scalar</code> is encoded as big-endian <code>uint256</code>, interpreted as <code>bytes32</code>, and composed as following:</p>
<p>*Byte ranges are indicated with <code>[</code> (inclusive) and <code>)</code> (exclusive).</p>
<ul>
<li><code>0</code>: scalar-version byte</li>
<li><code>[1, 32)</code>: depending scalar-version:
<ul>
<li>Scalar-version <code>0</code>:
<ul>
<li><code>[1, 28)</code>: padding, should be zero.</li>
<li><code>[28, 32)</code>: big-endian <code>uint32</code>, encoding the L1-fee <code>baseFeeScalar</code></li>
<li>This version implies the L1-fee <code>blobBaseFeeScalar</code> is set to 0.</li>
<li>In the event there are non-zero bytes in the padding area, <code>baseFeeScalar</code> must be set to MaxUint32.</li>
<li>This version is compatible with the pre-Ecotone <code>scalar</code> value (assuming a <code>uint32</code> range).</li>
</ul>
</li>
<li>Scalar-version <code>1</code>:
<ul>
<li><code>[1, 24)</code>: padding, must be zero.</li>
<li><code>[24, 28)</code>: big-endian <code>uint32</code>, encoding the <code>blobBaseFeeScalar</code></li>
<li><code>[28, 32)</code>: big-endian <code>uint32</code>, encoding the <code>baseFeeScalar</code></li>
<li>This version is meant to configure the EIP-4844 blob fee component, once blobs are used for data-availability.</li>
</ul>
</li>
<li>Other scalar-version values: unrecognized.
OP-Stack forks are recommended to utilize the <code>&gt;= 128</code> scalar-version range and document their <code>scalar</code> encoding.</li>
</ul>
</li>
</ul>
<p>Invalid and unrecognized scalar event-data should be ignored,
and the last valid configuration should continue to be utilized.</p>
<p>The <code>baseFeeScalar</code> and <code>blobBaseFeeScalar</code> are incorporated into the L2 through the
<a href="protocol/deposits.html#l1-attributes---ecotone">Ecotone L1 attributes deposit transaction calldata</a>.</p>
<p>Future upgrades of the <code>SystemConfig</code> contract may provide additional typed getters/setters
for the versioned scalar information.</p>
<p>In Ecotone the existing <code>setGasConfig</code> function, and <code>scalar</code> and <code>overhead</code> getters, continue to function.</p>
<p>When the batch-submitter utilizes EIP-4844 blob data for data-availability
it can adjust the scalars to accurately price the resources:</p>
<ul>
<li>
<p><code>baseFeeScalar</code> to correspond to the share of the user-transaction (per byte)
in the total regular L1 EVM gas usage consumed by the data-transaction of the batch-submitter.
For blob transactions this is the fixed intrinsic gas cost of the L1 transaction.</p>
</li>
<li>
<p><code>blobBaseFeeScalar</code> to correspond to share of a user-transaction (per byte)
in the total Blob data that is introduced by the data-transaction of the batch-submitter.</p>
</li>
</ul>
<h3 id="gaslimit-uint64"><a class="header" href="#gaslimit-uint64"><code>gasLimit</code> (<code>uint64</code>)</a></h3>
<p>The gas limit of the L2 blocks is configured through the system config.
Changes to the L2 gas limit are fully applied in the first L2 block with the L1 origin that introduced the change,
as opposed to the 1/1024 adjustments towards a target as seen in limit updates of L1 blocks.</p>
<h3 id="unsafeblocksigner-address"><a class="header" href="#unsafeblocksigner-address"><code>unsafeBlockSigner</code> (<code>address</code>)</a></h3>
<p>Blocks are gossiped around the p2p network before they are made available on L1.
To prevent denial of service on the p2p layer, these unsafe blocks must be
signed with a particular key to be accepted as &quot;canonical&quot; unsafe blocks.
The address corresponding to this key is the <code>unsafeBlockSigner</code>. To ensure
that its value can be fetched with a storage proof in a storage layout independent
manner, it is stored at a special storage slot corresponding to
<code>keccak256(&quot;systemconfig.unsafeblocksigner&quot;)</code>.</p>
<p>Unlike the other values, the <code>unsafeBlockSigner</code> only operates on blockchain
policy. It is not a consensus level parameter.</p>
<h2 id="writing-the-system-config"><a class="header" href="#writing-the-system-config">Writing the system config</a></h2>
<p>The <code>SystemConfig</code> contract applies authentication to all writing contract functions,
the configuration management can be configured to be any type of ethereum account or contract.</p>
<p>On a write, an event is emitted for the change to be picked up by the L2 system,
and a copy of the new written configuration variable is retained in L1 state to read with L1 contracts.</p>
<h2 id="reading-the-system-config"><a class="header" href="#reading-the-system-config">Reading the system config</a></h2>
<p>A rollup node initializes its derivation process by finding a starting point based on its past L2 chain:</p>
<ul>
<li>When started from L2 genesis, the initial system configuration is retrieved from the rollup chain configuration.</li>
<li>When started from an existing L2 chain, a previously included L1 block is determined as derivation starting point,
and the system config can thus be retrieved from the last L2 block that referenced the L1 block as L1 origin:
<ul>
<li>If the chain state precedes the Ecotone upgrade, <code>batcherHash</code>, <code>overhead</code> and <code>scalar</code> are
retrieved from the L1 block info transaction. Otherwise, <code>batcherHash</code>, <code>baseFeeScalar</code>, and
<code>blobBaseFeeScalar</code> are retrieved instead.</li>
<li><code>gasLimit</code> is retrieved from the L2 block header.</li>
<li>other future variables may also be retrieved from other contents of the L2 block, such as the header.</li>
</ul>
</li>
</ul>
<p>After preparing the initial system configuration for the given L1 starting input,
the system configuration is updated by processing all receipts from each new L1 block.</p>
<p>The contained log events are filtered and processed as follows:</p>
<ul>
<li>the log event contract address must match the rollup <code>SystemConfig</code> deployment</li>
<li>the first log event topic must match the ABI hash of <code>ConfigUpdate(uint256,uint8,bytes)</code></li>
<li>the second topic determines the version. Unknown versions are critical derivation errors.</li>
<li>the third topic determines the type of update. Unknown types are critical derivation errors.</li>
<li>the remaining event data is opaque, encoded as ABI bytes (i.e. includes offset and length data),
and encodes the configuration update. In version <code>0</code> the following types are supported:
<ul>
<li>type <code>0</code>: <code>batcherHash</code> overwrite, as <code>bytes32</code> payload.</li>
<li>type <code>1</code>: Pre-Ecotone, <code>overhead</code> and <code>scalar</code> overwrite, as two packed <code>uint256</code>
entries. After Ecotone upgrade, <code>overhead</code> is ignored and <code>scalar</code> interpreted as a <a href="protocol/system_config.html#ecotone-scalar-overhead-uint256uint256-change">versioned
encoding</a> that updates <code>baseFeeScalar</code> and
<code>blobBaseFeeScalar</code>.</li>
<li>type <code>2</code>: <code>gasLimit</code> overwrite, as <code>uint64</code> payload.</li>
<li>type <code>3</code>: <code>unsafeBlockSigner</code> overwrite, as <code>address</code> payload.</li>
</ul>
</li>
</ul>
<p>Note that individual derivation stages may be processing different L1 blocks,
and should thus maintain individual system configuration copies,
and apply the event-based changes as the stage traverses to the next L1 block.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="fault-proof"><a class="header" href="#fault-proof">Fault Proof</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="experimental/fault-proof/index.html#overview">Overview</a></li>
<li><a href="experimental/fault-proof/index.html#pre-image-oracle">Pre-image Oracle</a>
<ul>
<li><a href="experimental/fault-proof/index.html#pre-image-key-types">Pre-image key types</a>
<ul>
<li><a href="experimental/fault-proof/index.html#type-0-zero-key">Type <code>0</code>: Zero key</a></li>
<li><a href="experimental/fault-proof/index.html#type-1-local-key">Type <code>1</code>: Local key</a></li>
<li><a href="experimental/fault-proof/index.html#type-2-global-keccak256-key">Type <code>2</code>: Global keccak256 key</a></li>
<li><a href="experimental/fault-proof/index.html#type-3-global-generic-key">Type <code>3</code>: Global generic key</a></li>
<li><a href="experimental/fault-proof/index.html#type-4-128-reserved-range">Type <code>4-128</code>: reserved range</a></li>
<li><a href="experimental/fault-proof/index.html#type-129-255-application-usage">Type <code>129-255</code>: application usage</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/index.html#bootstrapping">Bootstrapping</a></li>
<li><a href="experimental/fault-proof/index.html#hinting">Hinting</a></li>
<li><a href="experimental/fault-proof/index.html#pre-image-communication">Pre-image communication</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/index.html#fault-proof-program">Fault Proof Program</a>
<ul>
<li><a href="experimental/fault-proof/index.html#prologue">Prologue</a></li>
<li><a href="experimental/fault-proof/index.html#main-content">Main content</a></li>
<li><a href="experimental/fault-proof/index.html#epilogue">Epilogue</a></li>
<li><a href="experimental/fault-proof/index.html#pre-image-hinting-routes">Pre-image hinting routes</a>
<ul>
<li><a href="experimental/fault-proof/index.html#l1-block-header-blockhash"><code>l1-block-header &lt;blockhash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l1-transactions-blockhash"><code>l1-transactions &lt;blockhash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l1-receipts-blockhash"><code>l1-receipts &lt;blockhash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l2-block-header-blockhash"><code>l2-block-header &lt;blockhash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l2-transactions-blockhash"><code>l2-transactions &lt;blockhash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l2-code-codehash"><code>l2-code &lt;codehash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l2-state-node-nodehash"><code>l2-state-node &lt;nodehash&gt;</code></a></li>
<li><a href="experimental/fault-proof/index.html#l2-output-outputroot"><code>l2-output &lt;outputroot&gt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="experimental/fault-proof/index.html#fault-proof-vm">Fault Proof VM</a></li>
<li><a href="experimental/fault-proof/index.html#fault-proof-interactive-dispute-game">Fault Proof Interactive Dispute Game</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-16"><a class="header" href="#overview-16">Overview</a></h2>
<p>A fault proof, also known as fraud proof or interactive game, consists of 3 components:</p>
<ul>
<li><a href="experimental/fault-proof/index.html#Fault-Proof-Program">Program</a>: given a commitment to all rollup inputs (L1 data) and the dispute, verify the dispute statelessly.</li>
<li><a href="experimental/fault-proof/index.html#Fault-Proof-VM">VM</a>: given a stateless program and its inputs, trace any instruction step, and prove it on L1.</li>
<li><a href="experimental/fault-proof/index.html#Fault-Proof-Interactive-Dispute-Game">Interactive Dispute Game</a>: bisect a dispute down to a single instruction, and resolve the base-case using the VM.</li>
</ul>
<p>Each of these 3 components may have different implementations, which can be combined into different proof stacks,
and contribute to proof diversity when resolving a dispute.</p>
<p>&quot;Stateless execution&quot; of the program, and its individual instructions, refers to reproducing
the exact same computation by authenticating the inputs with a <a href="experimental/fault-proof/index.html#Pre-image-Oracle">Pre-image Oracle</a>.</p>
<p><img src="experimental/fault-proof/../../static/assets/fault-proof.svg" alt="Diagram of Program and VM architecture" /></p>
<h2 id="pre-image-oracle"><a class="header" href="#pre-image-oracle">Pre-image Oracle</a></h2>
<p>The pre-image oracle is the only form of communication between
the <a href="experimental/fault-proof/index.html#Fault-Proof-Program">Program</a> (in the <a href="experimental/fault-proof/index.html#client">Client</a> role) and the <a href="experimental/fault-proof/index.html#Fault-Proof-VM">VM</a> (in the <a href="experimental/fault-proof/index.html#server">Server</a> role).</p>
<p>The program uses the pre-image oracle to query any input data that is understood to be available to the user:</p>
<ul>
<li>The initial inputs to bootstrap the program. See <a href="experimental/fault-proof/index.html#bootstrapping">Bootstrapping</a>.</li>
<li>External data not already part of the program code. See <a href="experimental/fault-proof/index.html#pre-image-hinting-routes">Pre-image hinting routes</a>.</li>
</ul>
<p>The communication happens over a simple request-response wire protocol,
see <a href="experimental/fault-proof/index.html#pre-image-communication">Pre-image communication</a>.</p>
<h3 id="pre-image-key-types"><a class="header" href="#pre-image-key-types">Pre-image key types</a></h3>
<p>Pre-images are identified by a <code>bytes32</code> type-prefixed key:</p>
<ul>
<li>The first byte identifies the type of request.</li>
<li>The remaining 31 bytes identify the pre-image key.</li>
</ul>
<h4 id="type-0-zero-key"><a class="header" href="#type-0-zero-key">Type <code>0</code>: Zero key</a></h4>
<p>The zero prefix is illegal. This ensures all pre-image keys are non-zero,
enabling storage lookup optimizations and avoiding easy mistakes with invalid zeroed keys in the EVM.</p>
<h4 id="type-1-local-key"><a class="header" href="#type-1-local-key">Type <code>1</code>: Local key</a></h4>
<p>Information specific to the dispute: the remainder of the key may be an index, a string, a hash, etc.
Only the contract(s) managing this dispute instance may serve the value for this key:
it is localized and context-dependent.</p>
<p>This type of key is used for program bootstrapping, to identify the initial input arguments by index or name.</p>
<h4 id="type-2-global-keccak256-key"><a class="header" href="#type-2-global-keccak256-key">Type <code>2</code>: Global keccak256 key</a></h4>
<p>This type of key uses a global pre-image store contract, and is fully context-independent and permissionless.
I.e. every key must have a single unique value, regardless of chain history or time.</p>
<p>Using a global store reduces duplicate pre-image registration work,
and avoids unnecessary contract redeployments per dispute.</p>
<p>This global store contract should be non-upgradeable.</p>
<p>Since <code>keccak256</code> is a safe 32-byte hash input, the first byte is overwritten with a <code>2</code> to derive the key,
while keeping the rest of the key &quot;readable&quot; (matching the original hash).</p>
<h4 id="type-3-global-generic-key"><a class="header" href="#type-3-global-generic-key">Type <code>3</code>: Global generic key</a></h4>
<p>Reserved. This scheme allows for unlimited application-layer pre-image types without fault-proof VM redeployments.</p>
<p>This is a generic version of a global key store: <code>key = 0x03 ++ keccak256(x, sender)[1:]</code>, where:</p>
<ul>
<li><code>x</code> is a <code>bytes32</code>, which can be a hash of an arbitrary-length type of cryptographically secure commitment.</li>
<li><code>sender</code> is a <code>bytes32</code> identifying the pre-image inserter address (left-padded to 32 bytes)</li>
</ul>
<p>This global store contract should be non-upgradeable.</p>
<p>The global contract is permissionless: users can standardize around external contracts that verify pre-images
(i.e. a specific <code>sender</code> will always be trusted for a specific kind of pre-image).
The external contract verifies the pre-image before inserting it into the global store for usage by all
fault proof VMs without requiring the VM or global store contract to be changed.</p>
<p>Users may standardize around upgradeable external pre-image contracts,
in case the implementation of the verification of the pre-image is expected to change.</p>
<p>The store update function is <code>update(x bytes32, offset uint64, span uint8, value bytes32)</code>:</p>
<ul>
<li><code>x</code> is the <code>bytes32</code> <code>x</code> that the pre-image <code>key</code> is computed with.</li>
<li>Only part of the pre-image, starting at <code>offset</code>, and up to (incl.) 32 bytes <code>span</code> can be inserted at a time.</li>
<li>Pre-images may have an undefined length (e.g. a stream), we only need to know how many bytes of <code>value</code> are usable.</li>
<li>The key and offset will be hashed together to uniquely store the <code>value</code> and <code>span</code>, for later pre-image serving.</li>
</ul>
<p>This enables fault proof programs to adopt any new pre-image schemes without VM update or contract redeployment.</p>
<p>It is up to the user to index the special pre-image values by this key scheme,
as there is no way to revert it to the original commitment without knowing said commitment or value.</p>
<h4 id="type-4-128-reserved-range"><a class="header" href="#type-4-128-reserved-range">Type <code>4-128</code>: reserved range</a></h4>
<p>Range start and end both inclusive.</p>
<p>This range of key types is reserved for future usage by the core protocol.
E.g. version changes, contract migrations, chain-data, additional core features, etc.</p>
<p><code>128</code> specifically (<code>1000 0000</code> in binary) is reserved for key-type length-extension
(reducing the content part to <code>30</code> or less key bytes), if the need arises.</p>
<h4 id="type-129-255-application-usage"><a class="header" href="#type-129-255-application-usage">Type <code>129-255</code>: application usage</a></h4>
<p>This range of key types may be used by forks or customized versions of the fault proof protocol.</p>
<h3 id="bootstrapping"><a class="header" href="#bootstrapping">Bootstrapping</a></h3>
<p>Initial inputs are deterministic, but not necessarily singular or global:
there may be multiple different disputes at the same time, each with its own disputed claims and L1 context.</p>
<p>To bootstrap, the program requests the initial inputs from the VM, using pre-image key type <code>1</code>.</p>
<p>The VM is aware of the external context, and maps requested pre-image keys based on their type, i.e.
a local lookup for type <code>1</code>, or global one for <code>2</code>, and optionally support other key-types.</p>
<h3 id="hinting"><a class="header" href="#hinting">Hinting</a></h3>
<p>There is one more form of optional communication between client and server: pre-image hinting.
Hinting is optional, and <em>is a no-op</em> in a L1 VM implementation.</p>
<p>The hint itself comes at very low cost onchain: the hint can be a single <code>write</code> sys-call,
which is instant as the memory to write as hint does not actually need to be loaded as part of the onchain proof.</p>
<p>Hinting allows the program, when generating a proof offchain,
to instruct the VM what data it is interested in.</p>
<p>The VM can choose to execute the requested hint at any time: either locally (for standard requests),
or in a modular form by redirecting the hint to tooling that may come with the VM program.</p>
<p>Hints do not have to be executed directly: they may first just be logged to show the intents of the program,
and the latest hint may be buffered for lazy execution, or dropped entirely when in read-only mode (like onchain).</p>
<p>When the pre-image oracle serves a request, and the request cannot be served from an existing collection of pre-images
(e.g. a local pre-image cache) then the VM can execute the hint to retrieve the missing pre-image(s).
It is the responsibility of the program to provide sufficient hinting for every pre-image request.
Some hints may have to be repeated: the VM only has to execute the last hint when handling a missing pre-image.</p>
<p>Note that hints may produce multiple pre-images:
e.g. a hint for an ethereum block with transaction list may prepare pre-images for the header,
each of the transactions, and the intermediate merkle-nodes that form the transactions-list Merkle Patricia Trie.</p>
<p>Hinting is implemented with a request-acknowledgement wire-protocol over a blocking two-way stream:</p>
<pre><code class="language-text">&lt;request&gt; := &lt;length prefix&gt; &lt;hint bytes&gt;

&lt;response&gt; := &lt;ack&gt;

&lt;length prefix&gt; := big-endian uint32  # length of &lt;hint bytes&gt;
&lt;hint bytes&gt; := byte sequence
&lt;ack&gt; := 1-byte zero value
</code></pre>
<p>The ack informs the client that the hint has been processed. Servers may respond to hints and pre-image (see below)
requests asynchronously as they are on separate streams. To avoid requesting pre-images that are not yet fetched,
clients should request the pre-image only after it has observed the hint acknowledgement.</p>
<h3 id="pre-image-communication"><a class="header" href="#pre-image-communication">Pre-image communication</a></h3>
<p>Pre-images are communicated with a minimal wire-protocol over a blocking two-way stream.
This protocol can be implemented with blocking read/write syscalls.</p>
<pre><code class="language-text">&lt;request&gt; := &lt;bytes32&gt;  # the type-prefixed pre-image key

&lt;response&gt; := &lt;length prefix&gt; &lt;pre-image bytes&gt;

&lt;length prefix&gt; := big-endian uint64  # length of &lt;pre-image bytes&gt;, note: uint64
</code></pre>
<p>The <code>&lt;length prefix&gt;</code> here may be arbitrarily high:
the client can stop reading at any time if the required part of the pre-image has been read.</p>
<p>After the client writes new <code>&lt;request&gt;</code> bytes, the server should be prepared to respond with
the pre-image starting from <code>offset == 0</code> upon <code>read</code> calls.</p>
<p>The server may limit <code>read</code> results artificially to only a small amount of bytes at a time,
even though the full pre-image is ready: this is expected regular IO protocol,
and the client will just have to continue to read the small results at a time,
until 0 bytes are read, indicating EOF.
This enables the server to serve e.g. at most 32 bytes at a time or align reads with VM memory structure,
to limit the amount of VM state that changes per syscall instruction,
and thus keep the proof size per instruction bounded.</p>
<h2 id="fault-proof-program"><a class="header" href="#fault-proof-program">Fault Proof Program</a></h2>
<p>The Fault Proof Program defines the verification of claims of the state-transition outputs
of the L2 rollup as a pure function of L1 data.</p>
<p>The <code>op-program</code> is the reference implementation of the program, based on <code>op-node</code> and <code>op-geth</code> implementations.</p>
<p>The program consists of:</p>
<ul>
<li>Prologue: load the inputs, given minimal bootstrapping, with possible test-overrides.</li>
<li>Main content: process the L2 state-transition, i.e. derive the state changes from the L1 inputs.</li>
<li>Epilogue: inspect the state changes to verify the claim.</li>
</ul>
<h3 id="prologue"><a class="header" href="#prologue">Prologue</a></h3>
<p>The program is bootstrapped with two primary inputs:</p>
<ul>
<li><code>l1_head</code>: the L1 block hash that will be perceived as the tip of the L1 chain,
authenticating all prior L1 history.</li>
<li><code>dispute</code>: identity of the claim to verify.</li>
</ul>
<p>Bootstrapping happens through special input requests to the host of the program.</p>
<p>Additionally, there are <em>implied</em> inputs, which are <em>derived from the above primary inputs</em>,
but can be overridden for testing purposes:</p>
<ul>
<li><code>l2_head</code>: the L2 block hash that will be perceived as the previously agreed upon tip of the L2 chain,
authenticating all prior L2 history.</li>
<li>Chain configurations: chain configuration may be baked into the program,
or determined from attributes of the identified <code>dispute</code> on L1.
<ul>
<li><code>l1_chain_config</code>: The chain-configuration of the L1 chain (also known as <code>l1_genesis.json</code>)</li>
<li><code>l2_chain_config</code>: The chain-configuration of the L2 chain (also known as <code>l2_genesis.json</code>)</li>
<li><code>rollup_config</code>: The rollup configuration used by the rollup-node (also known as <code>rollup.json</code>)</li>
</ul>
</li>
</ul>
<p>The implied inputs rely on L1-introspection to load attributes of the <code>dispute</code> through the
<a href="experimental/fault-proof/dispute-game-interface.html">dispute game interface</a>, in the L1 history up and till the specified <code>l1_head</code>.
The <code>dispute</code> may be the claim itself, or a pointer to specific prior claimed data in L1,
depending on the dispute game interface.</p>
<p>Implied inputs are loaded in a &quot;prologue&quot; before the actual core state-transition function executes.
During testing a simplified prologue that loads the overrides may be used.</p>
<blockquote>
<p>Note: only the test-prologues are currently supported, since the dispute game interface is actively changing.</p>
</blockquote>
<h3 id="main-content"><a class="header" href="#main-content">Main content</a></h3>
<p>To verify a claim about L2 state, the program first reproduces
the L2 state by applying L1 data to prior agreed L2 history.</p>
<p>This process is also known as the <a href="experimental/fault-proof/../../protocol/derivation.html">L2 derivation process</a>,
and matches the processing in the <a href="experimental/fault-proof/../../protocol/rollup-node.html">rollup node</a> and
<a href="experimental/fault-proof/../../protocol/exec-engine.html">execution-engine</a>.</p>
<p>The difference is that rather than retrieving inputs from an RPC and applying state changes to disk,
the inputs are loaded through the <a href="experimental/fault-proof/index.html#Pre-image-Oracle">pre-image oracle</a> and the changes accumulate in memory.</p>
<p>The derivation executes with two data-sources:</p>
<ul>
<li>Interface to read-only L1 chain, backed by the pre-image oracle:
<ul>
<li>The <code>l1_head</code> determines the view over the available L1 data: no later L1 data is available.</li>
<li>The implementation of the chain traverses the header-chain from the <code>l1_head</code> down to serve by-number queries.</li>
<li>The <code>l1_head</code> is the L1 unsafe head, safe head, and finalized head.</li>
</ul>
</li>
<li>Interface to L2 engine API
<ul>
<li>Prior L2 chain history is backed by the pre-image oracle, similar to the L1 chain:
<ul>
<li>The initial <code>l2_head</code> determines the view over the initial available L2 history: no later L2 data is available.</li>
<li>The implementation of the chain traverses the header-chain from the <code>l2_head</code> down to serve by-number queries.</li>
<li>The <code>l2_head</code> is the initial L2 unsafe head, safe head, and finalized head.</li>
</ul>
</li>
<li>New L2 chain history accumulates in memory.
<ul>
<li>Although the pre-image oracle can be used to retrieve data by hash if memory is limited,
the program should prefer to keep the newly created chain data in memory, to minimize pre-image oracle access.</li>
<li>The L2 unsafe head, safe head, and finalized L2 head will potentially change as derivation progresses.</li>
<li>L2 state consists of the diff of changes in memory,
and any unchanged state nodes accessible through the read-only L2 history view.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>See <a href="experimental/fault-proof/index.html#pre-image-routes">Pre-image routes</a> for specifications of the pre-image oracle backing of these data sources.</p>
<p>Using these data-sources, the derivation pipeline is processed till we hit one of two conditions:</p>
<ul>
<li><code>EOF</code>: when we run out of L1 data, the L2 chain will not change further, and the epilogue can start.</li>
<li>Eager epilogue condition: depending on the type of claim to verify,
if the L2 result is irreversible (i.e. no later L1 inputs can override it),
the processing may end early when the result is ready.
E.g. when asserting state at a specific L2 block, rather than the very tip of the L2 chain.</li>
</ul>
<h3 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h3>
<p>While the main-content produces the disputed L2 state already,
the epilogue concludes what this means for the disputed claim.</p>
<p>The program produces a binary output to verify the claim, using a standard single-byte Unix exit-code:</p>
<ul>
<li>a <code>0</code> for success, i.e. the claim is correct.</li>
<li>a non-zero code for failure, i.e. the claim is incorrect.
<ul>
<li><code>1</code> should be preferred for identifying an incorrect claim.</li>
<li>Other non-zero exit codes may indicate runtime failure,
e.g. a bug in the program code may resolve in a kind of <code>panic</code> or unexpected error.
Safety should be preferred over liveness in this case, and the <code>claim</code> will fail.</li>
</ul>
</li>
</ul>
<p>To assert the disputed claim, the epilogue, like the main content,
can introspect L1 and L2 chain data and post-process it further,
to then make a statement about the claim with the final exit code.</p>
<p>A disputed output-root may be disproven by first producing the output-root, and then comparing it:</p>
<ol>
<li>Retrieve the output attributes from the L2 chain view: the state-root, block-hash, withdrawals storage-root.</li>
<li>Compute the output-root, as the
<a href="experimental/fault-proof/../../protocol/proposals.html#l2-output-commitment-construction">proposer should compute it</a>.</li>
<li>If the output-root matches the <code>claim</code>, exit with code 0. Otherwise, exit with code 1.</li>
</ol>
<blockquote>
<p>Note: the dispute game interface is actively changing, and may require additional claim assertions.
the output-root epilogue may be replaced or extended for general L2 message proving.</p>
</blockquote>
<h3 id="pre-image-hinting-routes"><a class="header" href="#pre-image-hinting-routes">Pre-image hinting routes</a></h3>
<p>The fault proof program implements hint handling for the VM to use,
as well as any program testing outside of VM environment.
This can be exposed via a CLI, or alternative inter-process API.</p>
<p>Every instance of <code>&lt;blockhash&gt;</code> in the below routes is <code>0x</code>-prefixed, lowercase, hex-encoded.</p>
<h4 id="l1-block-header-blockhash"><a class="header" href="#l1-block-header-blockhash"><code>l1-block-header &lt;blockhash&gt;</code></a></h4>
<p>Requests the host to prepare the L1 block header RLP pre-image of the block <code>&lt;blockhash&gt;</code>.</p>
<h4 id="l1-transactions-blockhash"><a class="header" href="#l1-transactions-blockhash"><code>l1-transactions &lt;blockhash&gt;</code></a></h4>
<p>Requests the host to prepare the list of transactions of the L1 block with <code>&lt;blockhash&gt;</code>:
prepare the RLP pre-images of each of them, including transactions-list MPT nodes.</p>
<h4 id="l1-receipts-blockhash"><a class="header" href="#l1-receipts-blockhash"><code>l1-receipts &lt;blockhash&gt;</code></a></h4>
<p>Requests the host to prepare the list of receipts of the L1 block with <code>&lt;blockhash&gt;</code>:
prepare the RLP pre-images of each of them, including receipts-list MPT nodes.</p>
<h4 id="l2-block-header-blockhash"><a class="header" href="#l2-block-header-blockhash"><code>l2-block-header &lt;blockhash&gt;</code></a></h4>
<p>Requests the host to prepare the L2 block header RLP pre-image of the block <code>&lt;blockhash&gt;</code>.</p>
<h4 id="l2-transactions-blockhash"><a class="header" href="#l2-transactions-blockhash"><code>l2-transactions &lt;blockhash&gt;</code></a></h4>
<p>Requests the host to prepare the list of transactions of the L2 block with <code>&lt;blockhash&gt;</code>:
prepare the RLP pre-images of each of them, including transactions-list MPT nodes.</p>
<h4 id="l2-code-codehash"><a class="header" href="#l2-code-codehash"><code>l2-code &lt;codehash&gt;</code></a></h4>
<p>Requests the host to prepare the L2 smart-contract code with the given <code>&lt;codehash&gt;</code>.</p>
<h4 id="l2-state-node-nodehash"><a class="header" href="#l2-state-node-nodehash"><code>l2-state-node &lt;nodehash&gt;</code></a></h4>
<p>Requests the host to prepare the L2 MPT node preimage with the given <code>&lt;nodehash&gt;</code>.</p>
<h4 id="l2-output-outputroot"><a class="header" href="#l2-output-outputroot"><code>l2-output &lt;outputroot&gt;</code></a></h4>
<p>Requests the host to prepare the L2 Output at the l2 output root <code>&lt;outputroot&gt;</code>.
The L2 Output is the preimage of a
<a href="experimental/fault-proof/../../protocol/proposals.html#l2-output-commitment-construction">computed output root</a>.</p>
<h2 id="fault-proof-vm"><a class="header" href="#fault-proof-vm">Fault Proof VM</a></h2>
<p>A fault proof VM implements:</p>
<ul>
<li>a smart-contract to verify a single execution-trace step, e.g. a single MIPS instruction.</li>
<li>a CLI command to generate a proof of a single execution-trace step.</li>
<li>a CLI command to compute a VM state-root at step N</li>
</ul>
<p>A fault proof VM relies on a fault proof program to provide an interface
for fetching any missing pre-images based on hints.</p>
<p>The VM emulates the program, as prepared for the VM target architecture,
and generates the state-root or instruction proof data as requested through the VM CLI.</p>
<p>Refer to the documentation of the fault proof VM for further usage information.</p>
<p>Fault Proof VMs:</p>
<ul>
<li><a href="https://github.com/ethereum-optimism/cannon">Cannon</a>: big-endian 32-bit MIPS proof, by OP Labs, in active development.</li>
<li><a href="https://github.com/anton-rs/cannon-rs">cannon-rs</a>: Rust implementation of <code>Cannon</code>, by <code>@clabby</code>, in active development.</li>
<li><a href="https://github.com/protolambda/asterisc">Asterisc</a>: little-endian 64-bit RISC-V proof, by <code>@protolambda</code>, in active development.</li>
</ul>
<h2 id="fault-proof-interactive-dispute-game"><a class="header" href="#fault-proof-interactive-dispute-game">Fault Proof Interactive Dispute Game</a></h2>
<p>The interactive dispute game allows actors to resolve a dispute with an onchain challenge-response game
that bisects to a disagreed block <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> state transition, and then over the execution trace of the VM
which models this state transition, bounded with a base-case that proves a single VM trace step.</p>
<p>The game is multi-player: different non-aligned actors may participate when bonded.</p>
<p>Response time is allocated based on the remaining time in the branch of the tree and alignment with the claim.
The allocated response time is limited by the dispute-game window,
and any additional time necessary based on L1 fee changes when bonds are insufficient.</p>
<blockquote>
<p>Note: the timed, bonded, bisection dispute game is in development.
Also see <a href="experimental/fault-proof/fault-dispute-game.html">fault dispute-game specs</a> for fault dispute game system specifications,
And <a href="experimental/fault-proof/dispute-game-interface.html">dispute-game-interface specs</a> for dispute game interface specifications.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cannon-fault-proof-virtual-machine"><a class="header" href="#cannon-fault-proof-virtual-machine">Cannon Fault Proof Virtual Machine</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#overview">Overview</a></li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#state">State</a>
<ul>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#state-hash">State Hash</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#memory">Memory</a>
<ul>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#heap">Heap</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#delay-slots">Delay Slots</a></li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#syscalls">Syscalls</a></li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#io">I/O</a>
<ul>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#standard-streams">Standard Streams</a></li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#hint-communication">Hint Communication</a></li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#pre-image-communication">Pre-image Communication</a>
<ul>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#pre-image-io-alignment">Pre-image I/O Alignment</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="experimental/fault-proof/cannon-fault-proof-vm.html#exceptions">Exceptions</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-17"><a class="header" href="#overview-17">Overview</a></h2>
<p>This is a description of the Cannon Fault Proof Virtual Machine (FPVM). The Cannon FPVM emulates
a minimal Linux-based system running on big-endian 32-bit MIPS32 architecture.
A lot of its behaviors are copied from Linux/MIPS with a few tweaks made for fault proofs.
For the rest of this doc, we refer to the Cannon FPVM as simply the FPVM.</p>
<p>Operationally, the FPVM is a state transition function. This state transition is referred to as a <em>Step</em>,
that executes a single instruction. We say the VM is a function <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, given an input state <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>, steps on a
single instruction encoded in the state to produce a new state <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>.
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>Thus, the trace of a program executed by the FPVM is an ordered set of VM states.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>The virtual machine state highlights the effects of running a Fault Proof Program on the VM.
It consists of the following fields:</p>
<ol>
<li><code>memRoot</code> - A <code>bytes32</code> value representing the merkle root of VM memory.</li>
<li><code>preimageKey</code> - <code>bytes32</code> value of the last requested pre-image key.</li>
<li><code>preimageOffset</code> - The 32-bit value of the last requested pre-image offset.</li>
<li><code>pc</code> - 32-bit program counter.</li>
<li><code>nextPC</code> - 32-bit next program counter. Note that this value may not always be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>
when executing a branch/jump delay slot.</li>
<li><code>lo</code> - 32-bit MIPS LO special register.</li>
<li><code>hi</code> - 32-bit MIPS HI special register.</li>
<li><code>heap</code> - 32-bit base address of the most recent memory allocation via mmap.</li>
<li><code>exitCode</code> - 8-bit exit code.</li>
<li><code>exited</code> - 1-bit indicator that the VM has exited.</li>
<li><code>registers</code> - General-purpose MIPS32 registers. Each register is a 32-bit value.</li>
</ol>
<p>The state is represented by packing the above fields, in order, into a 226-byte buffer.</p>
<h3 id="state-hash"><a class="header" href="#state-hash">State Hash</a></h3>
<p>The state hash is computed by hashing the 226-byte state buffer with the Keccak256 hash function
and then setting the high-order byte to the respective VM status.</p>
<p>The VM status can be derived from the state's <code>exited</code> and <code>exitCode</code> fields.</p>
<pre><code class="language-rs">enum VmStatus {
    Valid = 0,
    Invalid = 1,
    Panic = 2,
    Unfinished = 3,
}

fn vm_status(exit_code: u8, exited: bool) -&gt; u8 {
    if exited {
        match exit_code {
            0 =&gt; VmStatus::Valid,
            1 =&gt; VmStatus::Invalid,
            _ =&gt; VmStatus::Panic,
        }
    } else {
        VmStatus::Unfinished
    }
}
</code></pre>
<h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<p>Memory is represented as a binary merkle tree.
The tree has a fixed-depth of 27 levels, with leaf values of 32 bytes each.
This spans the full 32-bit address space, where each leaf contains the memory at that part of the tree.
The state <code>memRoot</code> represents the merkle root of the tree, reflecting the effects of memory writes.
As a result of this memory representation, all memory operations are 4-byte aligned.
Memory access doesn't require any privileges. An instruction step can access any memory
location as the entire address space is unprotected.</p>
<h3 id="heap"><a class="header" href="#heap">Heap</a></h3>
<p>FPVM state contains a <code>heap</code> that tracks the base address of the most recent memory allocation.
Heap pages are bump allocated at the page boundary, per <code>mmap</code> syscall.
mmap-ing is purely to satisfy program runtimes that need the memory-pointer
result of the syscall to locate free memory. The page size is 4096.</p>
<p>The FPVM has a fixed program break at <code>0x40000000</code>. However, the FPVM is permitted to extend the
heap beyond this limit via mmap syscalls.
For simplicity, there are no memory protections against &quot;heap overruns&quot; against other memory segments.
Such VM steps are still considered valid state transitions.</p>
<p>Specification of memory mappings is outside the scope of this document as it is irrelevant to
the VM state. FPVM implementers may refer to the Linux/MIPS kernel for inspiration.</p>
<h2 id="delay-slots"><a class="header" href="#delay-slots">Delay Slots</a></h2>
<p>The post-state of a step updates the <code>nextPC</code>, indicating the instruction following the <code>pc</code>.
However, in the case of where a branch instruction is being stepped, the <code>nextPC</code> post-state is
set to the branch target. And the <code>pc</code> post-state set to the branch delay slot as usual.</p>
<p>A VM state transition is invalid whenever the current instruction is a delay slot that is filled
with jump or branch type instruction.
That is, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">tPC</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel">î€ </span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> while stepping on a jump/branch instruction.
Otherwise, there would be two consecutive delay slots. While this is considered &quot;undefined&quot;
behavior in typical MIPS implementations, FPVM must raise an exception when stepping on such states.</p>
<h2 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h2>
<p>Syscalls work similar to <a href="https://www.linux-mips.org/wiki/Syscall">Linux/MIPS</a>, including the
syscall calling conventions and general syscall handling behavior.
However, the FPVM supports a subset of Linux/MIPS syscalls with slightly different behaviors.
The following table list summarizes the supported syscalls and their behaviors.</p>
<div class="table-wrapper"><table><thead><tr><th>$v0</th><th>system call</th><th>$a0</th><th>$a1</th><th>$a2</th><th>Effect</th></tr></thead><tbody>
<tr><td>4090</td><td>mmap</td><td>uint32 addr</td><td>uint32 len</td><td>ðŸš«</td><td>Allocates a page from the heap. See <a href="experimental/fault-proof/cannon-fault-proof-vm.html#heap">heap</a> for details.</td></tr>
<tr><td>4045</td><td>brk</td><td>ðŸš«</td><td>ðŸš«</td><td>ðŸš«</td><td>Returns a fixed address for the program break at <code>0x40000000</code></td></tr>
<tr><td>4120</td><td>clone</td><td>ðŸš«</td><td>ðŸš«</td><td>ðŸš«</td><td>Returns 1</td></tr>
<tr><td>4246</td><td>exit_group</td><td>uint8 exit_code</td><td>ðŸš«</td><td>ðŸš«</td><td>Sets the Exited and ExitCode states to <code>true</code> and <code>$a0</code> respectively.</td></tr>
<tr><td>4003</td><td>read</td><td>uint32 fd</td><td>char *buf</td><td>uint32 count</td><td>Similar behavior as Linux/MIPS with support for unaligned reads. See <a href="experimental/fault-proof/cannon-fault-proof-vm.html#io">I/O</a> for more details.</td></tr>
<tr><td>4004</td><td>write</td><td>uint32 fd</td><td>char *buf</td><td>uint32 count</td><td>Similar behavior as Linux/MIPS with support for unaligned writes. See <a href="experimental/fault-proof/cannon-fault-proof-vm.html#io">I/O</a> for more details.</td></tr>
<tr><td>4055</td><td>fcntl</td><td>uint32 fd</td><td>int32 cmd</td><td>ðŸš«</td><td>Similar behavior as Linux/MIPS. Only the <code>F_GETFL</code> (3) cmd is supported. Sets errno to <code>0x16</code> for all other commands</td></tr>
</tbody></table>
</div>
<p>For all of the above syscalls, an error is indicated by setting the return
register (<code>$v0</code>) to <code>0xFFFFFFFF</code> (-1) and <code>errno</code> (<code>$a3</code>) is set accordingly.
The VM must not modify any register other than <code>$v0</code> and <code>$a3</code> during syscall handling.
For unsupported syscalls, the VM must do nothing except to zero out the syscall return (<code>$v0</code>)
and errno (<code>$a3</code>) registers.</p>
<p>Note that the above syscalls have identical syscall numbers and ABIs as Linux/MIPS.</p>
<h2 id="io"><a class="header" href="#io">I/O</a></h2>
<p>The VM does not support Linux open(2). However, the VM can read from and write to a predefined set of file descriptors.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>File descriptor</th><th>Description</th></tr></thead><tbody>
<tr><td>stdin</td><td>0</td><td>read-only standard input stream.</td></tr>
<tr><td>stdout</td><td>1</td><td>write-only standard output stream.</td></tr>
<tr><td>stderr</td><td>2</td><td>write-only standard error stream.</td></tr>
<tr><td>hint response</td><td>3</td><td>read-only. Used to read the status of <a href="experimental/fault-proof/index.html#hinting">pre-image hinting</a>.</td></tr>
<tr><td>hint request</td><td>4</td><td>write-only. Used to provide <a href="experimental/fault-proof/index.html#hinting">pre-image hints</a></td></tr>
<tr><td>pre-image response</td><td>5</td><td>read-only. Used to <a href="experimental/fault-proof/index.html#pre-image-communication">read pre-images</a>.</td></tr>
<tr><td>pre-image request</td><td>6</td><td>write-only. Used to <a href="experimental/fault-proof/index.html#pre-image-communication">request pre-images</a>.</td></tr>
</tbody></table>
</div>
<p>Syscalls referencing unknown file descriptors fail with an <code>EBADF</code> errno as done on Linux.</p>
<p>Writing to and reading from standard output, input and error streams have no effect on the FPVM state.
FPVM implementations may use them for debugging purposes as long as I/O is stateless.</p>
<p>All I/O operations are restricted to a maximum of 4 bytes per operation.
Any read or write syscall request exceeding this limit will be truncated to 4 bytes.
Consequently, the return value of read/write syscalls is at most 4, indicating the actual number of bytes read/written.</p>
<h3 id="standard-streams"><a class="header" href="#standard-streams">Standard Streams</a></h3>
<p>Writing to stderr/stdout standard stream always succeeds with the write count input returned,
effectively continuing execution without writing work.
Reading from stdin has no effect other than to return zero and errno set to 0, signalling that there is no input.</p>
<h3 id="hint-communication"><a class="header" href="#hint-communication">Hint Communication</a></h3>
<p>Hint requests and responses have no effect on the VM state other than setting the <code>$v0</code> return
register to the requested read/write count.
VM implementations may utilize hints to setup subsequent pre-image requests.</p>
<h3 id="pre-image-communication-1"><a class="header" href="#pre-image-communication-1">Pre-image Communication</a></h3>
<p>The <code>preimageKey</code> and <code>preimageOffset</code> state are updated via read/write syscalls to the pre-image
read and write file descriptors (see <a href="experimental/fault-proof/cannon-fault-proof-vm.html#io">I/O</a>).
The <code>preimageKey</code> buffers the stream of bytes written to the pre-image write fd.
The <code>preimageKey</code> buffer is shifted to accommodate new bytes written to the end of it.
A write also resets the <code>preimageOffset</code> to 0, indicating the intent to read a new pre-image.</p>
<p>When handling pre-image reads, the <code>preimageKey</code> is used to lookup the pre-image data from an Oracle.
A max 4-byte chunk of the pre-image at the <code>preimageOffset</code> is read to the specified address.
Each read operation increases the <code>preimageOffset</code> by the number of bytes requested
(truncated to 4 bytes and subject to alignment constraints).</p>
<h4 id="pre-image-io-alignment"><a class="header" href="#pre-image-io-alignment">Pre-image I/O Alignment</a></h4>
<p>As mentioned earlier in <a href="experimental/fault-proof/cannon-fault-proof-vm.html#memory">memory</a>, all memory operations are 4-byte aligned.
Since pre-image I/O occurs on memory, all pre-image I/O operations must strictly adhere to alignment boundaries.
This means the start and end of a read/write operation must fall within the same alignment boundary.
If an operation were to violate this, the input <code>count</code> of the read/write syscall must be
truncated such that the effective address of the last byte read/written matches the input effective address.</p>
<p>The VM must read/write the maximum amount of bytes possible without crossing the input address alignment boundary.
For example, the effect of a write request for a 3-byte aligned buffer must be exactly 3 bytes.
If the buffer is misaligned, then the VM may write less than 3 bytes depending on the size of the misalignment.</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>The FPVM may raise an exception rather than output a post-state to signal an invalid state
transition. Nominally, the FPVM must raise an exception in at least the following cases:</p>
<ul>
<li>Invalid instruction (either via an invalid opcode or an instruction referencing registers
outside the general purpose registers).</li>
<li>Pre-image read at an offset larger than the size of the pre-image.</li>
<li>Delay slot contains branch/jump instruction types.</li>
</ul>
<p>VM implementations may raise an exception in other cases that is specific to the implementation.
For example, an on-chain FPVM that relies on pre-supplied merkle proofs for memory access may
raise an exception if the supplied merkle proof does not match the pre-state <code>memRoot</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="dispute-game-interface"><a class="header" href="#dispute-game-interface">Dispute Game Interface</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="experimental/fault-proof/dispute-game-interface.html#overview">Overview</a></li>
<li><a href="experimental/fault-proof/dispute-game-interface.html#types">Types</a></li>
<li><a href="experimental/fault-proof/dispute-game-interface.html#disputegamefactory-interface"><code>DisputeGameFactory</code> Interface</a></li>
<li><a href="experimental/fault-proof/dispute-game-interface.html#disputegame-interface"><code>DisputeGame</code> Interface</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-18"><a class="header" href="#overview-18">Overview</a></h2>
<p>A dispute game is played between multiple parties when contesting the truthiness
of a claim. In the context of an optimistic rollup, claims are made about the
state of the layer two network to enable withdrawals to the layer one. A proposer
makes a claim about the layer two state such that they can withdraw and a
challenger can dispute the validity of the claim. The security of the layer two
comes from the ability of fraudulent withdrawals being able to be disputed.</p>
<p>A dispute game interface is defined to allow for multiple implementations of
dispute games to exist. If multiple dispute games run in production, it gives
a similar security model as having multiple protocol clients, as a bug in a
single dispute game will not result in the bug becoming consensus.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>For added context, we define a few types that are used in the following snippets.</p>
<pre><code class="language-solidity">/// @notice A `Claim` type represents a 32 byte hash or other unique identifier for a claim about
///         a certain piece of information.
type Claim is bytes32;

/// @notice A custom type for a generic hash.
type Hash is bytes32;

/// @notice A dedicated timestamp type.
type Timestamp is uint64;

/// @notice A `GameType` represents the type of game being played.
type GameType is uint8;

/// @title GameTypes
/// @notice A library that defines the IDs of games that can be played.
library GameTypes {
    /// @dev A dispute game type the uses the cannon vm.
    GameType internal constant CANNON = GameType.wrap(0);

    /// @dev A dispute game type that performs output bisection and then uses the cannon vm.
    GameType internal constant OUTPUT_CANNON = GameType.wrap(1);

    /// @notice A dispute game type that performs output bisection and then uses an alphabet vm.
    ///         Not intended for production use.
    GameType internal constant OUTPUT_ALPHABET = GameType.wrap(254);

    /// @notice A dispute game type that uses an alphabet vm.
    ///         Not intended for production use.
    GameType internal constant ALPHABET = GameType.wrap(255);
}

/// @notice The current status of the dispute game.
enum GameStatus {
    /// @dev The game is currently in progress, and has not been resolved.
    IN_PROGRESS,
    /// @dev The game has concluded, and the `rootClaim` was challenged successfully.
    CHALLENGER_WINS,
    /// @dev The game has concluded, and the `rootClaim` could not be contested.
    DEFENDER_WINS
}
</code></pre>
<h2 id="disputegamefactory-interface"><a class="header" href="#disputegamefactory-interface"><code>DisputeGameFactory</code> Interface</a></h2>
<p>The dispute game factory is responsible for creating new <code>DisputeGame</code> contracts
given a <code>GameType</code> and a root <code>Claim</code>. Challenger agents listen to the <code>DisputeGameCreated</code> events in order to
keep up with on-going disputes in the protocol and participate accordingly.</p>
<p>A <a href="https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args"><code>clones-with-immutable-args</code></a> factory
(originally by @wighawag, but forked by @Saw-mon-and-Natalie) is used to create Clones. Each <code>GameType</code> has
a corresponding implementation within the factory, and when a new game is created, the factory creates a
clone of the <code>GameType</code>'s pre-deployed implementation contract.</p>
<p>The <code>rootClaim</code> of created dispute games can either be a claim that the creator agrees or disagrees with.
This is an implementation detail that is left up to the <code>IDisputeGame</code> to handle within its <code>resolve</code> function.</p>
<p>When the <code>DisputeGameFactory</code> creates a new <code>DisputeGame</code> contract, it calls <code>initialize()</code> on the clone to
set up the game.</p>
<pre><code class="language-solidity">/// @title IDisputeGameFactory
/// @notice The interface for a DisputeGameFactory contract.
interface IDisputeGameFactory {
    /// @notice Emitted when a new dispute game is created
    /// @param disputeProxy The address of the dispute game proxy
    /// @param gameType The type of the dispute game proxy's implementation
    /// @param rootClaim The root claim of the dispute game
    event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);

    /// @notice Emitted when a new game implementation added to the factory
    /// @param impl The implementation contract for the given `GameType`.
    /// @param gameType The type of the DisputeGame.
    event ImplementationSet(address indexed impl, GameType indexed gameType);

    /// @notice Emitted when a game type's initialization bond is updated
    /// @param gameType The type of the DisputeGame.
    /// @param newBond The new bond (in wei) for initializing the game type.
    event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);

    /// @notice The total number of dispute games created by this factory.
    /// @return gameCount_ The total number of dispute games created by this factory.
    function gameCount() external view returns (uint256 gameCount_);

    /// @notice `games` queries an internal mapping that maps the hash of
    ///         `gameType ++ rootClaim ++ extraData` to the deployed `DisputeGame` clone.
    /// @dev `++` equates to concatenation.
    /// @param _gameType The type of the DisputeGame - used to decide the proxy implementation
    /// @param _rootClaim The root claim of the DisputeGame.
    /// @param _extraData Any extra data that should be provided to the created dispute game.
    /// @return proxy_ The clone of the `DisputeGame` created with the given parameters.
    ///         Returns `address(0)` if nonexistent.
    /// @return timestamp_ The timestamp of the creation of the dispute game.
    function games(
        GameType _gameType,
        Claim _rootClaim,
        bytes calldata _extraData
    )
        external
        view
        returns (IDisputeGame proxy_, Timestamp timestamp_);

    /// @notice `gameAtIndex` returns the dispute game contract address and its creation timestamp
    ///          at the given index. Each created dispute game increments the underlying index.
    /// @param _index The index of the dispute game.
    /// @return gameType_ The type of the DisputeGame - used to decide the proxy implementation.
    /// @return timestamp_ The timestamp of the creation of the dispute game.
    /// @return proxy_ The clone of the `DisputeGame` created with the given parameters.
    ///         Returns `address(0)` if nonexistent.
    function gameAtIndex(uint256 _index)
        external
        view
        returns (GameType gameType_, Timestamp timestamp_, IDisputeGame proxy_);

    /// @notice `gameImpls` is a mapping that maps `GameType`s to their respective
    ///         `IDisputeGame` implementations.
    /// @param _gameType The type of the dispute game.
    /// @return impl_ The address of the implementation of the game type.
    ///         Will be cloned on creation of a new dispute game with the given `gameType`.
    function gameImpls(GameType _gameType) external view returns (IDisputeGame impl_);

    /// @notice Returns the required bonds for initializing a dispute game of the given type.
    /// @param _gameType The type of the dispute game.
    /// @return bond_ The required bond for initializing a dispute game of the given type.
    function initBonds(GameType _gameType) external view returns (uint256 bond_);

    /// @notice Creates a new DisputeGame proxy contract.
    /// @param _gameType The type of the DisputeGame - used to decide the proxy implementation.
    /// @param _rootClaim The root claim of the DisputeGame.
    /// @param _extraData Any extra data that should be provided to the created dispute game.
    /// @return proxy_ The address of the created DisputeGame proxy.
    function create(
        GameType _gameType,
        Claim _rootClaim,
        bytes calldata _extraData
    )
        external
        payable
        returns (IDisputeGame proxy_);

    /// @notice Sets the implementation contract for a specific `GameType`.
    /// @dev May only be called by the `owner`.
    /// @param _gameType The type of the DisputeGame.
    /// @param _impl The implementation contract for the given `GameType`.
    function setImplementation(GameType _gameType, IDisputeGame _impl) external;

    /// @notice Sets the bond (in wei) for initializing a game type.
    /// @dev May only be called by the `owner`.
    /// @param _gameType The type of the DisputeGame.
    /// @param _initBond The bond (in wei) for initializing a game type.
    function setInitBond(GameType _gameType, uint256 _initBond) external;

    /// @notice Returns a unique identifier for the given dispute game parameters.
    /// @dev Hashes the concatenation of `gameType . rootClaim . extraData`
    ///      without expanding memory.
    /// @param _gameType The type of the DisputeGame.
    /// @param _rootClaim The root claim of the DisputeGame.
    /// @param _extraData Any extra data that should be provided to the created dispute game.
    /// @return uuid_ The unique identifier for the given dispute game parameters.
    function getGameUUID(
        GameType _gameType,
        Claim _rootClaim,
        bytes memory _extraData
    )
        external
        pure
        returns (Hash uuid_);
}
</code></pre>
<h2 id="disputegame-interface"><a class="header" href="#disputegame-interface"><code>DisputeGame</code> Interface</a></h2>
<p>The dispute game interface defines a generic, black-box dispute. It exposes stateful information such as the status of
the dispute, when it was created, as well as the bootstrap data and dispute type. This interface exposes one state
mutating function, <code>resolve</code>, which when implemented should deterministically yield an opinion about the <code>rootClaim</code>
and reflect the opinion by updating the <code>status</code> to <code>CHALLENGER_WINS</code> or <code>DEFENDER_WINS</code>.</p>
<p>Clones of the <code>IDisputeGame</code>'s <code>initialize</code> functions will be called by the <code>DisputeGameFactory</code> atomically upon
creation.</p>
<pre><code class="language-solidity">/// @title IDisputeGame
/// @notice The generic interface for a DisputeGame contract.
interface IDisputeGame is IInitializable {
    /// @notice Emitted when the game is resolved.
    /// @param status The status of the game after resolution.
    event Resolved(GameStatus indexed status);

    /// @notice Returns the timestamp that the DisputeGame contract was created at.
    /// @return createdAt_ The timestamp that the DisputeGame contract was created at.
    function createdAt() external view returns (Timestamp createdAt_);

    /// @notice Returns the current status of the game.
    /// @return status_ The current status of the game.
    function status() external view returns (GameStatus status_);

    /// @notice Getter for the game type.
    /// @dev The reference impl should be entirely different depending on the type (fault, validity)
    ///      i.e. The game type should indicate the security model.
    /// @return gameType_ The type of proof system being used.
    function gameType() external view returns (GameType gameType_);

    /// @notice Getter for the root claim.
    /// @dev `clones-with-immutable-args` argument #1
    /// @return rootClaim_ The root claim of the DisputeGame.
    function rootClaim() external pure returns (Claim rootClaim_);

    /// @notice Getter for the extra data.
    /// @dev `clones-with-immutable-args` argument #2
    /// @return extraData_ Any extra data supplied to the dispute game contract by the creator.
    function extraData() external pure returns (bytes memory extraData_);

    /// @notice If all necessary information has been gathered, this function should mark the game
    ///         status as either `CHALLENGER_WINS` or `DEFENDER_WINS` and return the status of
    ///         the resolved game. It is at this stage that the bonds should be awarded to the
    ///         necessary parties.
    /// @dev May only be called if the `status` is `IN_PROGRESS`.
    /// @return status_ The status of the game after resolution.
    function resolve() external returns (GameStatus status_);

    /// @notice A compliant implementation of this interface should return the components of the
    ///         game UUID's preimage provided in the cwia payload. The preimage of the UUID is
    ///         constructed as `keccak256(gameType . rootClaim . extraData)` where `.` denotes
    ///         concatenation.
    /// @return gameType_ The type of proof system being used.
    /// @return rootClaim_ The root claim of the DisputeGame.
    /// @return extraData_ Any extra data supplied to the dispute game contract by the creator.
    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="fault-dispute-game"><a class="header" href="#fault-dispute-game">Fault Dispute Game</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="experimental/fault-proof/fault-dispute-game.html#overview">Overview</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#definitions">Definitions</a>
<ul>
<li><a href="experimental/fault-proof/fault-dispute-game.html#virtual-machine-vm">Virtual Machine (VM)</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#preimageoracle">PreimageOracle</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#execution-trace">Execution Trace</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#claims">Claims</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#dag">DAG</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#subgame">Subgame</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#game-tree">Game Tree</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#position">Position</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#game_duration">GAME_DURATION</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#game-mechanics">Game Mechanics</a>
<ul>
<li><a href="experimental/fault-proof/fault-dispute-game.html#actors">Actors</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#moves">Moves</a>
<ul>
<li><a href="experimental/fault-proof/fault-dispute-game.html#attack">Attack</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#defend">Defend</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#step">Step</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#step-types">Step Types</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#preimageoracle-interaction">PreimageOracle Interaction</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#team-dynamics">Team Dynamics</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#game-clock">Game Clock</a></li>
<li><a href="experimental/fault-proof/fault-dispute-game.html#resolution">Resolution</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<!-- Glossary References -->
<h2 id="overview-19"><a class="header" href="#overview-19">Overview</a></h2>
<p>The Fault Dispute Game (FDG) is a specific type of <a href="experimental/fault-proof/dispute-game-interface.html">dispute game</a> that verifies the
validity of a root claim by iteratively bisecting over <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output roots</a> and execution traces of single
block state transitions down to a single instruction step. It relies on a Virtual Machine (VM) to falsify invalid
claims made at a single instruction step.</p>
<p>Actors, i.e. Players, interact with the game by making claims that dispute other claims in the FDG.
Each claim made narrows the range over the entire historical state of L2, until the source of dispute is a single
state transition. Once a time limit is reached, the dispute game is <em>resolved</em>, based on claims made that are disputed
and which aren't, to determine the winners of the game.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<h3 id="virtual-machine-vm"><a class="header" href="#virtual-machine-vm">Virtual Machine (VM)</a></h3>
<p>This is a state transition function (STF) that takes a <em>pre-state</em> and computes the post-state.
The VM may access data referenced during the STF and as such, it also accepts a <em>proof</em> of this data.
Typically, the pre-state contains a commitment to the <em>proof</em> to verify the integrity of the data referenced.</p>
<p>Mathematically, we define the STF as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> where</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the pre-state</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is an optional proof needed for the transition from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<h3 id="preimageoracle"><a class="header" href="#preimageoracle">PreimageOracle</a></h3>
<p>This is a pre-image data store. It is often used by VMs to read external data during its STF.
Before successfully executing a VM STF, it may be necessary to preload the PreimageOracle with pertinent data.
The method for key-based retrieval of these pre-images varies according to the specific VM.</p>
<h3 id="execution-trace"><a class="header" href="#execution-trace">Execution Trace</a></h3>
<p>An execution trace <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is a sequence <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> where each <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a VM state and
for each <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.
Every execution trace has a unique starting state, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, that's preset to a FDG implementation.
We refer to this state as the <strong>ABSOLUTE_PRESTATE</strong>.</p>
<h3 id="claims"><a class="header" href="#claims">Claims</a></h3>
<p>Claims assert an <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output root</a> or the state of the FPVM at a given instruction. This is represented as
<code>ClaimHash</code>, a <code>bytes32</code> representing either an <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output root</a> or a commitment to the last VM state in a
trace. A FDG is initialized with an output root that corresponds to the state of L2 at a given L2 block number, and
execution trace subgames at <code>SPLIT_DEPTH + 1</code> are initialized with a claim that commits to the entire execution trace
between two consecutive output roots (a block <code>n -&gt; n+1</code> state transition). As we'll see later, there can be multiple
claims, committing to different output roots and FPVM states in the FDG.</p>
<h3 id="dag"><a class="header" href="#dag">DAG</a></h3>
<p>A Directed Acyclic Graph <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> representing the relationship between claims, where:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is the set of nodes, each representing a claim. Formally, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>,
where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a claim.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the set of <em>directed</em> edges. An edge <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> exists if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> is a direct dispute
against <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> through either an &quot;Attack&quot; or &quot;Defend&quot; <a href="experimental/fault-proof/fault-dispute-game.html#moves">move</a>.</li>
</ul>
<h3 id="subgame"><a class="header" href="#subgame">Subgame</a></h3>
<p>A sub-game is a DAG of depth 1, where the root of the DAG is a <code>Claim</code> and the children are <code>Claim</code>s that counter the
root. A good mental model around this structure is that it is a fundamental dispute between two parties over a single
piece of information. These subgames are chained together such that a child within a subgame is the root of its own
subgame, which is visualized in the <a href="experimental/fault-proof/fault-dispute-game.html#resolution">resolution</a> section. There are two types of sub-games in the fault
dispute game:</p>
<ol>
<li>Output Roots</li>
<li>Execution Trace Commitments</li>
</ol>
<p>At and above the split depth, all subgame roots correspond to <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output roots</a>, or commitments to the full
state of L2 at a given L2 block number. Below the split depth, subgame roots correspond to commitments to the fault
proof VM's state at a given instruction step.</p>
<h3 id="game-tree"><a class="header" href="#game-tree">Game Tree</a></h3>
<p>The Game Tree is a binary tree of positions. Every claim in the DAG references a position in the Game Tree.
The Game Tree has a split depth and maximum depth, <code>SPLIT_DEPTH</code> and <code>MAX_GAME_DEPTH</code> respectively, that are both
preset to an FDG implementation. The split depth defines the maximum depth at which claims about
<a href="experimental/fault-proof/../../glossary.html#L2-output-root">output roots</a> can occur, and below it, execution trace bisection occurs. Thus, the Game Tree contains
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">âˆ’</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> positions, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the <code>MAX_GAME_DEPTH</code> (unless <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, in which case there's only 1 position).</p>
<p>The full game tree, with a layer of the tree allocated to output bisection, and sub-trees after an arbitrary split
depth, looks like:</p>
<p><img src="experimental/fault-proof/../../static/assets/ob-tree.png" alt="ob-tree" /></p>
<h3 id="position"><a class="header" href="#position">Position</a></h3>
<p>A position represents the location of a claim in the Game Tree. This is represented by a
&quot;generalized index&quot; (or <strong>gindex</strong>) where the high-order bit is the level in the tree and the remaining
bits is a unique bit pattern, allowing a unique identifier for each node in the tree.</p>
<p>The <strong>gindex</strong> of a position <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> can be calculated as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, where:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> is a function returning the depth of the position in the Game Tree</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> is a function returning the index of the position at its depth (starting from the left).</li>
</ul>
<p>Positions at the deepest level of the game tree correspond to indices in the execution trace, whereas claims at the
split depth represent single L2 blocks' <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output roots</a>.
Positions higher up the game tree also cover the deepest, right-most positions relative to the current position.
We refer to this coverage as the <strong>trace index</strong> of a Position.</p>
<blockquote>
<p>This means claims commit to an execution trace that terminates at the same index as their Position's trace index.
That is, for a given trace index <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, its ClaimHash corresponds to the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> th state in the trace.</p>
</blockquote>
<p>Note that there can be multiple positions covering the same <em>trace index</em>.</p>
<h3 id="game_duration"><a class="header" href="#game_duration">GAME_DURATION</a></h3>
<p>This is an immutable, preset to a FDG implementation, representing the duration of the game. Each top level team will
receive half of this duration on their initial chess clocks.</p>
<h2 id="game-mechanics"><a class="header" href="#game-mechanics">Game Mechanics</a></h2>
<h3 id="actors"><a class="header" href="#actors">Actors</a></h3>
<p>The game involves two types of participants (or Players): <strong>Challengers</strong> and <strong>Defenders</strong>.
These players are grouped into separate teams, each employing distinct strategies to interact with the game.
Team members share a common goal regarding the game's outcome. Players interact with the game primarily through
<em>moves</em>.</p>
<h3 id="moves"><a class="header" href="#moves">Moves</a></h3>
<p>A Move is a challenge against an existing claim and must include an alternate claim asserting a different trace.
Moves can either be attacks or defenses and serve to update to DAG by adding nodes and edges targeting the disputed
claim.</p>
<p>Moves within the fault dispute game can claim two separate values: <a href="experimental/fault-proof/../../glossary.html#L2-output-root">output roots</a> and execution trace
commitments. At and above the <code>SPLIT_DEPTH</code>, claims correspond to output roots, while below the split depth, they
correspond to execution trace commitments.</p>
<p>Initially, claims added to the DAG are <em>uncontested</em> (i.e. not <strong>countered</strong>). Once a move targets a claim, that claim
is considered countered.
The status of a claim â€” whether it's countered or not â€” helps determine its validity and, ultimately, the
game's winner.</p>
<h4 id="attack"><a class="header" href="#attack">Attack</a></h4>
<p>A logical move made when a claim is disagreed with.
A claim at the relative attack position to a node, <code>n</code>, in the Game Tree commits to half
of the trace of the <code>n</code>â€™s claim.
The attack position relative to a node can be calculated by multiplying its gindex by 2.</p>
<p>To illustrate this, here's a Game Tree highlighting an attack on a Claim positioned at 6.</p>
<p><img src="experimental/fault-proof/../../static/assets/attack.png" alt="Attacking node 6" /></p>
<p>Attacking the node at 6 moves creates a new claim positioned at 12.</p>
<h4 id="defend"><a class="header" href="#defend">Defend</a></h4>
<p>The logical move against a claim when you agree with both it and its parent.
A defense at the relative position to a node, <code>n</code>, in the Game Tree commits to the first half of n + 1â€™s trace range.</p>
<p><img src="experimental/fault-proof/../../static/assets/defend.png" alt="Defend at 4" /></p>
<p>Note that because of this, some nodes may never exist within the Game Tree.
However, they're not necessary as these nodes have complimentary, valid positions
with the same trace index within the tree. For example, a Position with gindex 5 has the same
trace index as another Position with gindex 2. We can verify that all trace indices have valid moves within the game:</p>
<p><img src="experimental/fault-proof/../../static/assets/valid-moves.png" alt="Game Tree Showing All Valid Move Positions" /></p>
<p>There may be multiple claims at the same position, so long as their <code>ClaimHash</code> are unique.</p>
<p>Each move adds new claims to the Game Tree at strictly increasing depth.
Once a claim is at <code>MAX_GAME_DEPTH</code>, the only way to dispute such claims is to <strong>step</strong>.</p>
<h3 id="step"><a class="header" href="#step">Step</a></h3>
<p>At <code>MAX_GAME_DEPTH</code>, the position of claims correspond to indices of an execution trace.
It's at this point that the FDG is able to query the VM to determine the validity of claims,
by checking the states they're committing to.
This is done by applying the VM's STF to the state a claim commits to.
If the STF post-state does not match the claimed state, the challenge succeeds.</p>
<pre><code class="language-solidity">/// @notice Perform an instruction step via an on-chain fault proof processor.
/// @dev This function should point to a fault proof processor in order to execute
///      a step in the fault proof program on-chain. The interface of the fault proof
///      processor contract should adhere to the `IBigStepper` interface.
/// @param _claimIndex The index of the challenged claim within `claimData`.
/// @param _isAttack Whether or not the step is an attack or a defense.
/// @param _stateData The stateData of the step is the preimage of the claim at the given
///        prestate, which is at `_stateIndex` if the move is an attack and `_claimIndex` if
///        the move is a defense. If the step is an attack on the first instruction, it is
///        the absolute prestate of the fault proof VM.
/// @param _proof Proof to access memory nodes in the VM's merkle state tree.
function step(uint256 _claimIndex, bool _isAttack, bytes calldata _stateData, bytes calldata _proof) external;
</code></pre>
<h3 id="step-types"><a class="header" href="#step-types">Step Types</a></h3>
<p>Similar to moves, there are two ways to step on a claim; attack or defend.
These determine the pre-state input to the VM STF and the expected output.</p>
<ul>
<li><strong>Attack Step</strong> - Challenges a claim by providing a pre-state, proving an invalid state transition.
It uses the previous state in the execution trace as input and expects the disputed claim's state as output.
There must exist a claim in the DAG that commits to the input.</li>
<li><strong>Defense Step</strong> - Challenges a claim by proving it was an invalid attack,
thereby defending the disputed ancestor's claim. It uses the disputed claim's state as input and expects
the next state in the execution trace as output. There must exist a claim in the DAG that commits to the
expected output.</li>
</ul>
<p>The FDG step handles the inputs to the VM and asserts the expected output.
A step that successfully proves an invalid post-state (when attacking) or pre-state (when defending) is a
successful counter against the disputed claim.
Players interface with <code>step</code> by providing an indicator of attack and state data (including any proofs)
that corresponds to the expected pre/post state (depending on whether it's an attack or defend).
The FDG will assert that an existing claim commits to the state data provided by players.</p>
<h3 id="preimageoracle-interaction"><a class="header" href="#preimageoracle-interaction">PreimageOracle Interaction</a></h3>
<p>Certain steps (VM state transitions) require external data to be available by the <code>PreimageOracle</code>.
To ensure a successful state transition, players should provide this data in advance.
The FDG provides the following interface to manage data loaded to the <code>PreimageOracle</code>:</p>
<pre><code class="language-solidity">/// @notice Posts the requested local data to the VM's `PreimageOralce`.
/// @param _ident The local identifier of the data to post.
/// @param _execLeafIdx The index of the leaf claim in an execution subgame that requires the local data for a step.
/// @param _partOffset The offset of the data to post.
function addLocalData(uint256 _ident, uint256 _execLeafIdx, uint256 _partOffset) external;
</code></pre>
<p>The <code>addLocalData</code> function loads local data into the VM's <code>PreimageOracle</code>. This data consists of bootstrap data for
the program. There are multiple sets of local preimage keys that belong to the <code>FaultDisputeGame</code> contract due to the
ability for players to bisect to any block <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> state transition since the configured genesis, the
<code>_execLeafIdx</code> parameter enables a search for the starting / disputed outputs to be performed such that the contract
can write to and reference unique local keys in the <code>PreimageOracle</code> for each of these <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
transitions.</p>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>Parent L1 head hash at the time of the proposal</td></tr>
<tr><td><code>1</code></td><td>Starting output root hash (commits to block # <code>n</code>)</td></tr>
<tr><td><code>2</code></td><td>Disputed output root hash (commits to block # <code>n + 1</code>)</td></tr>
<tr><td><code>3</code></td><td>Starting L2 block number (block # <code>n</code>)</td></tr>
<tr><td><code>4</code></td><td>Chain ID</td></tr>
</tbody></table>
</div>
<p>For global <code>keccak256</code> preimages, there are two routes for players to submit:</p>
<ol>
<li>Small preimages atomically.</li>
<li>Large preimages via streaming.</li>
</ol>
<p>Global <code>keccak256</code> preimages are non-context specific and can be submitted directly to the <code>PreimageOracle</code> via the
<code>loadKeccak256PreimagePart</code> function, which takes the part offset as well as the full preimage. In the event that the
preimage is too large to be submitted through calldata in a single block, challengers must resort to the streaming
option.</p>
<p><strong>Large Preimage Proposals</strong></p>
<p>Large preimage proposals allow for submitters to stream in a large preimage over multiple transactions, along-side
commitments to the intermediate state of the <code>keccak256</code> function after absorbing/permuting the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1088</span></span></span></span> bit block.
This data is progressively merkleized on-chain as it is streamed in, with each leaf constructed as follows:</p>
<pre><code class="language-solidity">/// @notice Returns a leaf hash to add to a preimage proposal merkle tree.
/// @param input A single 136 byte chunk of the input.
/// @param blockIndex The index of the block that `input` corresponds to in the full preimage's absorbtion.
/// @param stateCommitment The hash of the full 5x5 state matrix *after* absorbing and permuting `input`.
function hashLeaf(
    bytes memory input,
    uint256 blockIndex,
    bytes32 stateCommitment
) internal view returns (bytes32 leaf) {
    require(input.length == 136, &quot;input must be exactly the size of the keccak256 rate&quot;);

    leaf = keccak256(abi.encodePacked(input, blockIndex, stateCommitment));
}
</code></pre>
<p>Once the full preimage and all intermediate state commitments have been posted, the large preimage proposal enters a
challenge period. During this time, a challenger can reconstruct the merkle tree that was progressively built on-chain
locally by scanning the block bodies that contain the proposer's leaf preimages. If they detect that a commitment to
the intermediate state of the hash function is incorrect at any step, they may perform a single-step dispute for the
proposal in the <code>PreimageOracle</code>. This involves:</p>
<ol>
<li>Creating a merkle proof for the agreed upon prestate leaf (not necessary if the invalid leaf is the first one, the
setup state of the matrix is constant.) within the proposal's merkle root.</li>
<li>Creating a merkle proof for the disputed post state leaf within the proposal's merkle root.</li>
<li>Computing the state matrix at the agreed upon prestate (not necessary if the invalid leaf is the first one, the
setup state of the matrix is constant.)</li>
</ol>
<p>The challenger then submits this data to the <code>PreimageOracle</code>, where the post state leaf's claimed input is absored into
the pre state leaf's state matrix and the SHA3 permutation is executed on-chain. After that, the resulting state matrix
is hashed and and compared with the proposer's claim in the post state leaf. If the hash does not match, the proposal
is marked as challenged, and it may not be finalized. If, after the challenge period is concluded, a proposal has no
challenges, it may be finalized and the preimage part may be placed into the authorized mappings for the FPVM to read.</p>
<h3 id="team-dynamics"><a class="header" href="#team-dynamics">Team Dynamics</a></h3>
<p>Challengers seek to dispute the root claim, while Defenders aim to support it.
Both types of actors will move accordingly to support their team. For Challengers, this means
attacking the root claim and disputing claims positioned at even depths in the Game Tree.
Defenders do the opposite by disputing claims positioned at odd depths.</p>
<p>Players on either team are motivated to support the actions of their teammates.
This involves countering disputes against claims made by their team (assuming these claims are honest).
Uncontested claims are likely to result in a loss, as explained later under <a href="experimental/fault-proof/fault-dispute-game.html#resolution">Resolution</a>.</p>
<h3 id="game-clock"><a class="header" href="#game-clock">Game Clock</a></h3>
<p>Every claim in the game has a Clock. A claim inherits the clock of its grandparent claim in the
DAG (and so on). Akin to a chess clock, it keeps track of the total time each team takes to make
moves, preventing delays.
Making a move resumes the clock for the disputed claim and puases it for the newly added one.</p>
<p>A move against a particular claim is no longer possible once the parent of the disputed claim's Clock
has exceeded half of the <code>GAME_DURATION</code>. By which point, the claim's clock has <em>expired</em>.</p>
<h3 id="resolution"><a class="header" href="#resolution">Resolution</a></h3>
<p>Resolving the FDG determines which team won the game. To do this, we use the internal sub game structure.
Each claim within the game is the root of its own sub game. These subgames are modeled as nested DAGs, each with a max
depth of 1. In order for a claim to be considered countered, only one of its children must be uncountered. Subgames
can also not be resolved until all of their children, which are subgames themselves, have been resolved and
the potential opponent's chess clock has run out. Because each claim is the root of its own sub-game,
truth percolates upwards towards the root claim by resolving each individual sub-game bottom-up.</p>
<p>In a game like the one below, we can resolve up from the deepest subgames. Here, we'd resolve <code>b0</code>
to uncountered and <code>a0</code> to countered by walking up from their deepest children, and once all children of the
root game are recursively resolved, we can resolve the root to countered due to <code>b0</code> remaining uncountered.</p>
<!-- https://gist.github.com/clabby/e98bdd80ef3c038424f3372b70e34e08 -->
<!-- markdownlint-disable no-inline-html -->
<p><a href="https://github.com/ethereum-optimism/optimism/assets/8406232/d2b708a0-539e-439d-96bd-c2f66f3a45f8">https://github.com/ethereum-optimism/optimism/assets/8406232/d2b708a0-539e-439d-96bd-c2f66f3a45f8</a></p>
<p>Another example is this game, which has a slightly different structure. Here, the root claim will also
be countered due to <code>b0</code> remaining uncountered.</p>
<!--
digraph G {
    rankdir=LR
    newrank=true
  node [shape=plaintext]
  subgraph cluster_01 {
    label = "Legend";
    key [label=<<table border="0" cellpadding="2" cellspacing="0" cellborder="0">
      <tr><td align="right" port="i1">bisection</td></tr>
      <tr><td align="right" port="i2">resolution</td></tr>
      </table>>]
    key2 [label=<<table border="0" cellpadding="" cellspacing="0" cellborder="0">
      <tr><td port="i1">&nbsp;</td></tr>
      <tr><td port="i2">&nbsp;</td></tr>
      </table>>]
    key:i1:e -> key2:i1:w [color=green]
    key:i2:e -> key2:i2:w [color=coral1, style=dotted]
  }
  subgraph cluster_0 {
    color=cornflowerblue;
    node [style=filled];
    a0 -> a1 [color=green];
    a1 -> a0 [color=coral1, style=dotted];
    subgraph cluster_0_0 {
        label = "subgame #5";
        color=purple;
        a1 -> a2 [color=green];
        a2 -> a1 [color=coral1, style=dotted];
        subgraph cluster_0_1 {
            label = "subgame #6";
            color=magenta;
            a2 -> a3 [color=green];
            a3 -> a2 [color=coral1, style=dotted];
            a2 -> a4 [color=green];
            a4 -> a2 [color=coral1, style=dotted];
            subgraph cluster_0_2 {
                label = "subgame #7";
                color=lightpink;
                a3
            }
            subgraph cluster_0_3 {
                label = "subgame #8";
                color=lightpink;
                a4 -> a5 [color=green];
                a5 -> a4 [color=coral1, style=dotted];
                subgraph cluster_0_4 {
                    label = "subgame #9";
                    color=palegreen;
                    a5
                }
            }
        }
    }
    label = "subgame #4";
  }
  subgraph cluster_1 {
    node [style=filled];
    label = "subgame #1";
    color=cornflowerblue
    b0 -> b1 [color=green];
    b1 -> b0 [color=coral1, style=dotted];
    subgraph cluster_1_0 {
        label = "subgame #2";
        color=purple;
        b1 -> b2 [color=green];
        b2 -> b1 [color=coral1, style=dotted];
        subgraph cluster_1_1 {
            label = "subgame #3";
            edge [style=invis]
            color=magenta;
            b2
        }
    }
  }
  Root -> a0 [color=green];
  Root -> b0 [color=green];
  a0 -> Root [color=coral1, style=dotted];
  b0 -> Root [color=coral1, style=dotted];
  Root [shape=Mdiamond];
}
-->
<!-- markdownlint-disable no-inline-html -->
<p align="center">
<img src="https://github.com/ethereum-optimism/optimism/assets/8406232/9b20ba8d-0b64-47b3-9962-5533f7eb4ef7" width=60%>
</p>
<p>Given these rules, players are motivated to move quickly to challenge all dishonest claims.
Each move bisects the historical state of L2 and eventually, <code>MAX_GAME_DEPTH</code> is reached where disputes
can be settled conclusively. Dishonest players are disincentivized to participate, via backwards induction,
as an invalid claim won't remain uncontested. Further incentives can be added to the game by requiring
claims to be bonded, while rewarding game winners using the bonds of dishonest claims.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="honest-challenger-fault-dispute-game"><a class="header" href="#honest-challenger-fault-dispute-game">Honest Challenger (Fault Dispute Game)</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#overview">Overview</a></li>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#fdg-responses">FDG Responses</a>
<ul>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#root-claims">Root Claims</a></li>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#counter-claims">Counter Claims</a></li>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#steps">Steps</a></li>
</ul>
</li>
<li><a href="experimental/fault-proof/honest-challenger-fdg.html#resolution">Resolution</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="overview-20"><a class="header" href="#overview-20">Overview</a></h2>
<p>The honest challenger is an agent interacting in the <a href="experimental/fault-proof/fault-dispute-game.html">Fault Dispute Game</a>
(FDG) that supports honest claims and disputes false claims.
An honest challenger strives to ensure a correct, truthful, game resolution.
The honest challenger is also <em>rational</em> as any deviation from its behavior will result in
negative outcomes.
This document specifies the expected behavior of an honest challenger.</p>
<p>The Honest Challenger has two primary duties:</p>
<ol>
<li>Support valid root claims in Fault Dispute Games.</li>
<li>Dispute invalid root claims in Fault Dispute Games.</li>
</ol>
<p>The honest challenger polls the <code>DisputeGameFactory</code> contract for new and on-going Fault
Dispute Games.
For verifying the legitimacy of claims, it relies on a synced, trusted rollup node
as well as a trace provider (ex: <a href="experimental/fault-proof/cannon-fault-proof-vm.html">Cannon</a>).
The trace provider must be configured with the <a href="experimental/fault-proof/fault-dispute-game.html#execution-trace">ABSOLUTE_PRESTATE</a>
of the FDG being interacted with to generate the traces needed to make truthful claims.</p>
<h2 id="fdg-responses"><a class="header" href="#fdg-responses">FDG Responses</a></h2>
<h3 id="root-claims"><a class="header" href="#root-claims">Root Claims</a></h3>
<p>When a <code>FaultDisputeGame</code> is created, the honest challenger has two possible correct responses
to its root claim:</p>
<ol>
<li><a href="experimental/fault-proof/fault-dispute-game.html#attack"><strong>Attack</strong></a> if they disagree with the root claim.
The root claim commits to the entire execution trace, so the first move here is to
attack with the <a href="experimental/fault-proof/fault-dispute-game.html#claims">ClaimHash</a> at the midpoint
instruction within their execution trace.</li>
<li><strong>Do Nothing</strong> if they agree with the root claim. They do nothing because if the root
claim is left un-countered, the game resolves to their agreement.
NOTE: The honest challenger will still track this game in order to defend any subsequent
claims made against the root claim - in effect, &quot;playing the game&quot;.</li>
</ol>
<h3 id="counter-claims"><a class="header" href="#counter-claims">Counter Claims</a></h3>
<p>For every claim made in a dispute game with a <a href="experimental/fault-proof/fault-dispute-game.html#game-tree">game tree</a>
depth in the range of <code>[1, MAX_DEPTH]</code>, the honest challenger processes them and performs
a response.</p>
<p>To determine the appropriate response, the challenger first needs to know which
<a href="experimental/fault-proof/fault-dispute-game.html#team-dynamics"><em>team</em></a> it belongs to.
This determines the set of claims it should respond to in the FDG.
If the agent determines itself to be a Defender, which aims to support the root claim,
then it must dispute claims positioned at odd depths in the game tree.
Otherwise, it disputes claims positioned at even depths in the game tree.
This means an honest challenger only responds to claims made by the opposing team.</p>
<p>The next step is to determine if the claim, now known to be for the opposing team,
disputes another claim the honest challenger <em>agrees</em> with.
An honest challenger agrees with a claim iff every other claim along its path to the
root claim commits to a valid <code>ClaimHash</code>. Put differently, an honest challenger will
avoid countering a claim if it disagrees with the path of claims leading to that
specific claim. But if the honest challenger agrees with the path leading to the claim,
then the claim is countered.</p>
<p>The last step is to determine whether the claim has a valid commitment (i.e. <code>ClaimHash</code>).
If the <code>ClaimHash</code> matches the honest challenger's at the same trace index, then we
disagree with the claim's stance by moving to <a href="experimental/fault-proof/fault-dispute-game.html#defend">defend</a>.
Otherwise, the claim is <a href="experimental/fault-proof/fault-dispute-game.html#attack">attacked</a>.</p>
<p>The following pseudocode illustrates the response logic.</p>
<pre><code class="language-python">class Team(Enum):
    DEFENDER = 0
    CHALLENGER = 1

class Claim:
    parent: Claim
    position: uint64
    claim_hash: ClaimHash

MAX_TRACE = 2**MAX_GAME_DEPTH

def agree_with(claim: Claim, chal_trace: List[ClaimHash, MAX_TRACE]):
    if chal_trace[claim.trace_index] != claim.claim_hash:
        return False
    grand_parent = claim.parent.parent if claim.parent is not None else None
    if grand_parent is not None:
        return agree_with(grand_parent)
    return True

def respond(claim: Claim, chal: Team, chal_trace: List[ClaimHash, MAX_TRACE]):
    if depth(claim.position) % 2 != chal.value:
        if claim.parent is None or agree_with(claim.parent, chal_trace):
            if chal_trace[trace_index(claim.position)] == claim.claim_hash:
                defend()
            else:
                attack()
        else: pass # avoid supporting invalid claims on the same team
</code></pre>
<p>In attack or defense, the honest challenger submit a <code>ClaimHash</code> corresponding to the
state identified by the trace index of their response position.</p>
<p>The honest challenger responds to claims as soon as possible to avoid the clock of its
counter-claim from expiring.</p>
<h3 id="steps"><a class="header" href="#steps">Steps</a></h3>
<p>At the max depth of the game, claims represent commitments to the state of the fault proof VM
at a single instruction step interval.
Because the game can no longer bisect further, when the honest challenger has a valid move
against these claims (valid defined by the response in <a href="experimental/fault-proof/honest-challenger-fdg.html#counter-claims">Counter Claims</a>),
the only option for an honest challenger is to execute a VM step on-chain to disprove the claim at <code>MAX_GAME_DEPTH</code>.</p>
<p>Similar to the above section, the honest challenger will issue an
<a href="experimental/fault-proof/fault-dispute-game.html#step-types">attack step</a> when in response to such claims with
invalid <code>ClaimHash</code> commitments. Otherwise, it issues a <em>defense step</em>.</p>
<h2 id="resolution-1"><a class="header" href="#resolution-1">Resolution</a></h2>
<p>When the <a href="experimental/fault-proof/fault-dispute-game.html#game-clock">chess clock</a> of a
<a href="experimental/fault-proof/fault-dispute-game.html#resolution">subgame root</a> has run out, the subgame can be resolved.
The honest challenger should resolve all subgames in bottom-up order, until the subgame
rooted at the FDG root is resolved.</p>
<p>The honest challenger accomplishes this by calling the <code>resolveClaim</code> function on the
<code>FaultDisputeGame</code> contract. Once the root claim's subgame is resolved,
the challenger then finally calls the <code>resolve</code> function to resolve the entire game.</p>
<p>The <code>FaultDisputeGame</code> does not put a time cap on resolution - because of the liveness
assumption on honest challengers and the bonds attached to the claims theyâ€™ve countered,
challengers are economically incentivized to resolve the game promptly to capture the bonds.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="glossary.html#general-terms">General Terms</a>
<ul>
<li><a href="glossary.html#layer-1-l1">Layer 1 (L1)</a></li>
<li><a href="glossary.html#layer-2-l2">Layer 2 (L2)</a></li>
<li><a href="glossary.html#block">Block</a></li>
<li><a href="glossary.html#eoa">EOA</a></li>
<li><a href="glossary.html#merkle-patricia-trie">Merkle Patricia Trie</a></li>
<li><a href="glossary.html#chain-re-organization">Chain Re-Organization</a></li>
<li><a href="glossary.html#predeployed-contract-predeploy">Predeployed Contract (&quot;Predeploy&quot;)</a></li>
<li><a href="glossary.html#preinstalled-contract-preinstall">Preinstalled Contract (&quot;Preinstall&quot;)</a></li>
<li><a href="glossary.html#receipt">Receipt</a></li>
<li><a href="glossary.html#transaction-type">Transaction Type</a></li>
<li><a href="glossary.html#fork-choice-rule">Fork Choice Rule</a></li>
<li><a href="glossary.html#priority-gas-auction">Priority Gas Auction</a></li>
</ul>
</li>
<li><a href="glossary.html#sequencing">Sequencing</a>
<ul>
<li><a href="glossary.html#sequencer">Sequencer</a></li>
<li><a href="glossary.html#sequencing-window">Sequencing Window</a></li>
<li><a href="glossary.html#sequencing-epoch">Sequencing Epoch</a></li>
<li><a href="glossary.html#l1-origin">L1 Origin</a></li>
</ul>
</li>
<li><a href="glossary.html#deposits">Deposits</a>
<ul>
<li><a href="glossary.html#deposited-transaction">Deposited Transaction</a></li>
<li><a href="glossary.html#l1-attributes-deposited-transaction">L1 Attributes Deposited Transaction</a></li>
<li><a href="glossary.html#user-deposited-transaction">User-Deposited Transaction</a></li>
<li><a href="glossary.html#depositing-call">Depositing Call</a></li>
<li><a href="glossary.html#depositing-transaction">Depositing Transaction</a></li>
<li><a href="glossary.html#depositor">Depositor</a></li>
<li><a href="glossary.html#deposited-transaction-type">Deposited Transaction Type</a></li>
<li><a href="glossary.html#deposit-contract">Deposit Contract</a></li>
</ul>
</li>
<li><a href="glossary.html#withdrawals">Withdrawals</a>
<ul>
<li><a href="glossary.html#relayer">Relayer</a></li>
<li><a href="glossary.html#finalization-period">Finalization Period</a></li>
</ul>
</li>
<li><a href="glossary.html#batch-submission">Batch Submission</a>
<ul>
<li><a href="glossary.html#data-availability">Data Availability</a></li>
<li><a href="glossary.html#data-availability-provider">Data Availability Provider</a></li>
<li><a href="glossary.html#sequencer-batch">Sequencer Batch</a></li>
<li><a href="glossary.html#channel">Channel</a></li>
<li><a href="glossary.html#channel-frame">Channel Frame</a></li>
<li><a href="glossary.html#batcher">Batcher</a></li>
<li><a href="glossary.html#batcher-transaction">Batcher Transaction</a></li>
<li><a href="glossary.html#channel-timeout">Channel Timeout</a></li>
</ul>
</li>
<li><a href="glossary.html#l2-output-root-proposals">L2 Output Root Proposals</a>
<ul>
<li><a href="glossary.html#proposer">Proposer</a></li>
</ul>
</li>
<li><a href="glossary.html#l2-chain-derivation">L2 Chain Derivation</a>
<ul>
<li><a href="glossary.html#l2-derivation-inputs">L2 Derivation Inputs</a></li>
<li><a href="glossary.html#system-configuration">System Configuration</a></li>
<li><a href="glossary.html#payload-attributes">Payload Attributes</a></li>
<li><a href="glossary.html#l2-genesis-block">L2 Genesis Block</a></li>
<li><a href="glossary.html#l2-chain-inception">L2 Chain Inception</a></li>
<li><a href="glossary.html#safe-l2-block">Safe L2 Block</a></li>
<li><a href="glossary.html#safe-l2-head">Safe L2 Head</a></li>
<li><a href="glossary.html#unsafe-l2-block">Unsafe L2 Block</a></li>
<li><a href="glossary.html#unsafe-l2-head">Unsafe L2 Head</a></li>
<li><a href="glossary.html#unsafe-block-consolidation">Unsafe Block Consolidation</a></li>
<li><a href="glossary.html#finalized-l2-head">Finalized L2 Head</a></li>
</ul>
</li>
<li><a href="glossary.html#other-l2-chain-concepts">Other L2 Chain Concepts</a>
<ul>
<li><a href="glossary.html#address-aliasing">Address Aliasing</a></li>
<li><a href="glossary.html#rollup-node">Rollup Node</a></li>
<li><a href="glossary.html#rollup-driver">Rollup Driver</a></li>
<li><a href="glossary.html#l1-attributes-predeployed-contract">L1 Attributes Predeployed Contract</a></li>
<li><a href="glossary.html#l2-output-root">L2 Output Root</a></li>
<li><a href="glossary.html#l2-output-oracle-contract">L2 Output Oracle Contract</a></li>
<li><a href="glossary.html#validator">Validator</a></li>
<li><a href="glossary.html#fault-proof">Fault Proof</a></li>
<li><a href="glossary.html#time-slot">Time Slot</a></li>
<li><a href="glossary.html#block-time">Block Time</a></li>
<li><a href="glossary.html#unsafe-sync">Unsafe Sync</a></li>
</ul>
</li>
<li><a href="glossary.html#execution-engine-concepts">Execution Engine Concepts</a>
<ul>
<li><a href="glossary.html#execution-engine">Execution Engine</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<hr />
<h1 id="general-terms"><a class="header" href="#general-terms">General Terms</a></h1>
<h2 id="layer-1-l1"><a class="header" href="#layer-1-l1">Layer 1 (L1)</a></h2>
<p>Refers the Ethereum blockchain, used in contrast to <a href="glossary.html#layer-2-L2">layer 2</a>, which refers to Optimism.</p>
<h2 id="layer-2-l2"><a class="header" href="#layer-2-l2">Layer 2 (L2)</a></h2>
<p>Refers to the Optimism blockchain (specified in this repository), used in contrast to <a href="glossary.html#layer-1-L1">layer 1</a>, which
refers to the Ethereum blockchain.</p>
<h2 id="block"><a class="header" href="#block">Block</a></h2>
<p>Can refer to an <a href="glossary.html#layer-1-L1">L1</a> block, or to an <a href="glossary.html#layer-2-L2">L2</a> block, which are structured similarly.</p>
<p>A block is a sequential list of transactions, along with a couple of properties stored in the <em>header</em> of the block. A
description of these properties can be found in code comments <a href="https://github.com/norswap/nanoeth/blob/cc5d94a349c90627024f3cd629a2d830008fec72/src/com/norswap/nanoeth/blocks/BlockHeader.java#L22-L156">here</a>, or in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum yellow paper
(pdf)</a>, section 4.3.</p>
<p>It is useful to distinguish between input block properties, which are known before executing the transactions in the
block, and output block properties, which are derived after executing the block's transactions. These include various
<a href="glossary.html#merkle-patricia-trie">Merkle Patricia Trie roots</a> that notably commit to the L2 state and to the log events emitted during execution.</p>
<h2 id="eoa"><a class="header" href="#eoa">EOA</a></h2>
<p>&quot;Externally Owned Account&quot;, an Ethereum term to designate addresses operated by users, as opposed to contract addresses.</p>
<h2 id="merkle-patricia-trie"><a class="header" href="#merkle-patricia-trie">Merkle Patricia Trie</a></h2>
<p>A <a href="https://github.com/norswap/nanoeth/blob/d4c0c89cc774d4225d16970aa44c74114c1cfa63/src/com/norswap/nanoeth/trees/patricia/README.md">Merkle Patricia Trie (MPT)</a> is a sparse trie, which is a tree-like structure that maps keys to values.
The root hash of a MPT is a commitment to the contents of the tree, which allows a
proof to be constructed for any key-value mapping encoded in the tree. Such a proof is called a Merkle proof, and can be
verified against the Merkle root.</p>
<h2 id="chain-re-organization"><a class="header" href="#chain-re-organization">Chain Re-Organization</a></h2>
<p>A re-organization, or re-org for short, is whenever the head of a blockchain (its last block) changes (as dictated by
the <a href="glossary.html#fork-choice-rule">fork choice rule</a>) to a block that is not a child of the previous head.</p>
<p>L1 re-orgs can happen because of network conditions or attacks. L2 re-orgs are a consequence of L1 re-orgs, mediated via
<a href="glossary.html#L2-chain-derivation">L2 chain derivation</a>.</p>
<h2 id="predeployed-contract-predeploy"><a class="header" href="#predeployed-contract-predeploy">Predeployed Contract (&quot;Predeploy&quot;)</a></h2>
<p>A contract placed in the L2 genesis state (i.e. at the start of the chain).</p>
<p>All predeploy contracts are specified in the <a href="./protocol/predeploys.html">predeploys specification</a>.</p>
<h2 id="preinstalled-contract-preinstall"><a class="header" href="#preinstalled-contract-preinstall">Preinstalled Contract (&quot;Preinstall&quot;)</a></h2>
<p>A contract placed in the L2 genesis state (i.e. at the start of the chain). These contracts do not share the same
security guarantees as <a href="glossary.html#predeployed-contract-predeploy">predeploys</a>, but are general use contracts made
available to improve the L2's UX.</p>
<p>All preinstall contracts are specified in the <a href="./protocol/preinstalls.html">preinstalls specification</a>.</p>
<h2 id="receipt"><a class="header" href="#receipt">Receipt</a></h2>
<p>A receipt is an output generated by a transaction, comprising a status code, the amount of gas used, a list of log
entries, and a <a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a> indexing these entries. Log entries are most notably used to encode <a href="https://docs.soliditylang.org/en/latest/contracts.html?highlight=events#events">Solidity events</a>.</p>
<p>Receipts are not stored in blocks, but blocks store a <a href="glossary.html#merkle-patricia-trie">Merkle Patricia Trie root</a> for a tree containing the receipt
for every transaction in the block.</p>
<p>Receipts are specified in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">yellow paper (pdf)</a> section 4.3.1.</p>
<h2 id="transaction-type"><a class="header" href="#transaction-type">Transaction Type</a></h2>
<p>Ethereum provides a mechanism (as described in <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a>) for defining different transaction types.
Different transaction types can contain different payloads, and be handled differently by the protocol.</p>
<h2 id="fork-choice-rule"><a class="header" href="#fork-choice-rule">Fork Choice Rule</a></h2>
<p>The fork choice rule is the rule used to determine which block is to be considered as the head of a blockchain. On L1,
this is determined by the proof of stake rules.</p>
<p>L2 also has a fork choice rule, although the rules vary depending on whether we want the <a href="glossary.html#safe-l2-head">safe L2 head</a>,
the <a href="glossary.html#unsafe-l2-head">unsafe L2 head</a> or the <a href="glossary.html#finalized-l2-head">finalized L2 head</a>.</p>
<h2 id="priority-gas-auction"><a class="header" href="#priority-gas-auction">Priority Gas Auction</a></h2>
<p>Transactions in ethereum are ordered by the price that the transaction pays to the miner. Priority Gas Auctions
(PGAs) occur when multiple parties are competing to be the first transaction in a block. Each party continuously
updates the gas price of their transaction. PGAs occur when there is value in submitting a transaction before other
parties (like being the first deposit or submitting a deposit before there is not more guaranteed gas remaining).
PGAs tend to have negative externalities on the network due to a large amount of transactions being submitted in a
very short amount of time.</p>
<hr />
<h1 id="sequencing"><a class="header" href="#sequencing">Sequencing</a></h1>
<p>Transactions in the rollup can be included in two ways:</p>
<ul>
<li>Through a <a href="glossary.html#deposited-transaction">deposited transaction</a>, enforced by the system</li>
<li>Through a regular transaction, embedded in a <a href="glossary.html#sequencer-batch">sequencer batch</a></li>
</ul>
<p>Submitting transactions for inclusion in a batch saves costs by reducing overhead, and enables the sequencer to
pre-confirm the transactions before the L1 confirms the data.</p>
<h2 id="sequencer"><a class="header" href="#sequencer">Sequencer</a></h2>
<p>A sequencer is either a <a href="glossary.html#rollup-node">rollup node</a> ran in sequencer mode, or the operator of this rollup node.</p>
<p>The sequencer is a privileged actor, which receives L2 transactions from L2 users, creates L2 blocks using them, which
it then submits to <a href="glossary.html#data-availability-provider">data availability provider</a> (via a <a href="glossary.html#batcher">batcher</a>). It also submits <a href="glossary.html#l2-output-root">output
roots</a> to L1.</p>
<h2 id="sequencing-window"><a class="header" href="#sequencing-window">Sequencing Window</a></h2>
<p>A sequencing window is a range of L1 blocks from which a <a href="glossary.html#sequencing-epoch">sequencing epoch</a> can be derived.</p>
<p>A sequencing window whose first L1 block has number <code>N</code> contains <a href="glossary.html#batcher-transaction">batcher transactions</a> for epoch
<code>N</code>. The window contains blocks <code>[N, N + SWS)</code> where <code>SWS</code> is the sequencer window size.</p>
<p>The current default <code>sws</code> is 3600 epochs.</p>
<p>Additionally, the first block in the window defines the <a href="glossary.html#depositing-transaction">depositing transactions</a> which determine the
<a href="glossary.html#deposits">deposits</a> to be included in the first L2 block of the epoch.</p>
<h2 id="sequencing-epoch"><a class="header" href="#sequencing-epoch">Sequencing Epoch</a></h2>
<p>A sequencing epoch is sequential range of L2 blocks derived from a <a href="glossary.html#sequencing-window">sequencing window</a> of L1 blocks.</p>
<p>Each epoch is identified by an epoch number, which is equal to the block number of the first L1 block in the
sequencing window.</p>
<p>Epochs can have variable size, subject to some constraints. See the <a href="./protocol/derivation.html">L2 chain derivation specification</a>
for more details.</p>
<h2 id="l1-origin"><a class="header" href="#l1-origin">L1 Origin</a></h2>
<p>The L1 origin of an L2 block is the L1 block corresponding to its <a href="glossary.html#sequencing-epoch">sequencing epoch</a>.</p>
<hr />
<h1 id="deposits-2"><a class="header" href="#deposits-2">Deposits</a></h1>
<p>In general, a deposit is an L2 transaction derived from an L1 block (by the <a href="glossary.html#rollup-driver">rollup driver</a>).</p>
<p>While transaction deposits are notably (but not only) used to &quot;deposit&quot; (bridge) ETH and tokens to L2, the word
<em>deposit</em> should be understood as &quot;a transaction <em>deposited</em> to L2 from L1&quot;.</p>
<p>This term <em>deposit</em> is somewhat ambiguous as these &quot;transactions&quot; exist at multiple levels. This section disambiguates
all deposit-related terms.</p>
<p>Notably, a <em>deposit</em> can refer to:</p>
<ul>
<li>A <a href="glossary.html#deposited-transaction">deposited transaction</a> (on L2) that is part of a deposit block.</li>
<li>A <a href="glossary.html#depositing-call">depositing call</a> that causes a <a href="glossary.html#deposited-transaction">deposited transaction</a> to be derived.</li>
<li>The event/log data generated by the <a href="glossary.html#depositing-call">depositing call</a>, which is what the <a href="glossary.html#rollup-driver">rollup driver</a> reads to
derive the <a href="glossary.html#deposited-transaction">deposited transaction</a>.</li>
</ul>
<p>We sometimes also talk about <em>user deposit</em> which is a similar term that explicitly excludes <a href="glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited
transactions</a>.</p>
<p>Deposits are specified in the <a href="./protocol/deposits.html">deposits specification</a>.</p>
<h2 id="deposited-transaction"><a class="header" href="#deposited-transaction">Deposited Transaction</a></h2>
<p>A <em>deposited transaction</em> is a L2 transaction that was derived from L1 and included in a L2 block.</p>
<p>There are two kinds of deposited transactions:</p>
<ul>
<li><a href="glossary.html#l1-attributes-deposited-transaction">L1 attributes deposited transaction</a>, which submits the L1 block's attributes to the <a href="glossary.html#l1-attributes-predeployed-contract">L1 Attributes
Predeployed Contract</a>.</li>
<li><a href="glossary.html#user-deposited-transaction">User-deposited transactions</a>, which are transactions derived from an L1 call to the <a href="glossary.html#deposit-contract">deposit
contract</a>.</li>
</ul>
<h2 id="l1-attributes-deposited-transaction-1"><a class="header" href="#l1-attributes-deposited-transaction-1">L1 Attributes Deposited Transaction</a></h2>
<p>An <em>L1 attributes deposited transaction</em> is <a href="glossary.html#deposited-transaction">deposited transaction</a> that is used to register the L1 block
attributes (number, timestamp, ...) on L2 via a call to the <a href="glossary.html#l1-attributes-predeployed-contract">L1 Attributes Predeployed Contract</a>.
That contract can then be used to read the attributes of the L1 block corresponding to the current L2 block.</p>
<p>L1 attributes deposited transactions are specified in the <a href="./protocol/deposits.html#l1-attributes-deposited-transaction">L1 Attributes Deposit</a> section of the
deposits specification.</p>
<h2 id="user-deposited-transaction"><a class="header" href="#user-deposited-transaction">User-Deposited Transaction</a></h2>
<p>A <em>user-deposited transaction</em> is a <a href="glossary.html#deposited-transaction">deposited transaction</a> which is derived from an L1 call to the <a href="glossary.html#deposit-contract">deposit
contract</a> (a <a href="glossary.html#depositing-call">depositing call</a>).</p>
<p>User-deposited transactions are specified in the <a href="./protocol/deposits.html#user-deposited-transactions">Transaction Deposits</a> section of the deposits
specification.</p>
<h2 id="depositing-call"><a class="header" href="#depositing-call">Depositing Call</a></h2>
<p>A <em>depositing call</em> is an L1 call to the <a href="glossary.html#deposit-contract">deposit contract</a>, which will be derived to a
<a href="glossary.html#user-deposited-transaction">user-deposited transaction</a> by the <a href="glossary.html#rollup-driver">rollup driver</a>.</p>
<p>This call specifies all the data (destination, value, calldata, ...) for the deposited transaction.</p>
<h2 id="depositing-transaction"><a class="header" href="#depositing-transaction">Depositing Transaction</a></h2>
<p>A <em>depositing transaction</em> is an L1 transaction that makes one or more <a href="glossary.html#depositing-call">depositing calls</a>.</p>
<h2 id="depositor"><a class="header" href="#depositor">Depositor</a></h2>
<p>The <em>depositor</em> is the L1 account (contract or <a href="glossary.html#EOA">EOA</a>) that makes (is the <code>msg.sender</code> of) the <a href="glossary.html#depositing-call">depositing
call</a>. The <em>depositor</em> is <strong>NOT</strong> the originator of the depositing transaction (i.e. <code>tx.origin</code>).</p>
<h2 id="deposited-transaction-type"><a class="header" href="#deposited-transaction-type">Deposited Transaction Type</a></h2>
<p>The <em>deposited transaction type</em> is an <a href="https://eips.ethereum.org/EIPS/eip-2718">EIP-2718</a> <a href="glossary.html#transaction-type">transaction type</a>, which specifies the input fields
and correct handling of a <a href="glossary.html#deposited-transaction">deposited transaction</a>.</p>
<p>See the <a href="./protocol/deposits.html#the-deposited-transaction-type">corresponding section</a> of the deposits spec for more information.</p>
<h2 id="deposit-contract-1"><a class="header" href="#deposit-contract-1">Deposit Contract</a></h2>
<p>The <em>deposit contract</em> is an <a href="glossary.html#layer-1-L1">L1</a> contract to which <a href="glossary.html#EOA">EOAs</a> and contracts may send <a href="glossary.html#deposits">deposits</a>. The deposits are
emitted as log records (in Solidity, these are called <em>events</em>) for consumption by <a href="glossary.html#rollup-node">rollup nodes</a>.</p>
<p>Advanced note: the deposits are not stored in calldata because they can be sent by contracts, in which case the calldata
is part of the <em>internal</em> execution between contracts, and this intermediate calldata is not captured in one of the
<a href="glossary.html#merkle-patricia-trie">Merkle Patricia Trie roots</a> included in the L1 block.</p>
<p>cf. <a href="./protocol/deposits.html">Deposits Specification</a></p>
<hr />
<h1 id="withdrawals-1"><a class="header" href="#withdrawals-1">Withdrawals</a></h1>
<blockquote>
<p><strong>TODO</strong> expand this whole section to be clearer</p>
</blockquote>
<p>In general, a withdrawal is a transaction sent from L2 to L1 that may transfer data and/or value.</p>
<p>The term <em>withdrawal</em> is somewhat ambiguous as these &quot;transactions&quot; exist at multiple levels. In order to differentiate
between the L1 and L2 components of a withdrawal we introduce the following terms:</p>
<ul>
<li>A <em>withdrawal initiating transaction</em> refers specifically to a transaction on L2 sent to the Withdrawals predeploy.</li>
<li>A <em>withdrawal finalizing transaction</em> refers specifically to an L1 transaction which finalizes and relays the
withdrawal.</li>
</ul>
<h2 id="relayer"><a class="header" href="#relayer">Relayer</a></h2>
<p>An EOA on L1 which finalizes a withdrawal by submitting the data necessary to verify its inclusion on L2.</p>
<h2 id="finalization-period"><a class="header" href="#finalization-period">Finalization Period</a></h2>
<p>The finalization period â€” sometimes also called <em>withdrawal delay</em> â€” is the minimum amount of time (in seconds) that
must elapse before a <a href="glossary.html#withdrawals">withdrawal</a> can be finalized.</p>
<p>The finalization period is necessary to afford sufficient time for <a href="glossary.html#validator">validators</a> to make a <a href="glossary.html#fault-proof">fault
proof</a>.</p>
<blockquote>
<p><strong>TODO</strong> specify current value for finalization period</p>
</blockquote>
<hr />
<h1 id="batch-submission-1"><a class="header" href="#batch-submission-1">Batch Submission</a></h1>
<h2 id="data-availability"><a class="header" href="#data-availability">Data Availability</a></h2>
<p>Data availability is the guarantee that some data will be &quot;available&quot; (i.e. <em>retrievable</em>) during a reasonably long time
window. In Optimism's case, the data in question are <a href="glossary.html#sequencer-batch">sequencer batches</a> that <a href="glossary.html#validator">validators</a>
need in order to verify the sequencer's work and validate the L2 chain.</p>
<p>The <a href="glossary.html#finalization-period">finalization period</a> should be taken as the lower bound on the availability window, since
that is when data availability is the most crucial, as it is needed to perform a <a href="glossary.html#fault-proof">fault proof</a>.</p>
<p>&quot;Availability&quot; <strong>does not</strong> mean guaranteed long-term storage of the data.</p>
<h2 id="data-availability-provider"><a class="header" href="#data-availability-provider">Data Availability Provider</a></h2>
<p>A data availability provider is a service that can be used to make data available. See the <a href="glossary.html#data-availability">Data
Availability</a> for more information on what this means.</p>
<p>Ideally, a good data availability provider provides strong <em>verifiable</em> guarantees of data availability</p>
<p>Currently, the only supported data availability provider is Ethereum call data. <a href="https://www.eip4844.com/">Ethereum data blobs</a> will be
supported when they get deployed on Ethereum.</p>
<h2 id="sequencer-batch"><a class="header" href="#sequencer-batch">Sequencer Batch</a></h2>
<p>A sequencer batch is list of L2 transactions (that were submitted to a sequencer) tagged with an <a href="glossary.html#sequencing-epoch">epoch
number</a> and an L2 block timestamp (which can trivially be converted to a block number, given our
block time is constant).</p>
<p>Sequencer batches are part of the <a href="glossary.html#l2-derivation-inputs">L2 derivation inputs</a>. Each batch represents the inputs needed to build
<strong>one</strong> L2 block (given the existing L2 chain state) â€” except for the first block of each epoch, which also needs
information about deposits (cf. the section on <a href="glossary.html#l2-derivation-inputs">L2 derivation inputs</a>).</p>
<h2 id="channel"><a class="header" href="#channel">Channel</a></h2>
<p>A channel is a sequence of <a href="glossary.html#sequencer-batch">sequencer batches</a> (for sequential blocks) compressed together. The reason
to group multiple batches together is simply to obtain a better compression rate, hence reducing data availability
costs.</p>
<p>A channel can be split in <a href="glossary.html#channel-frame">frames</a> in order to be transmitted via <a href="glossary.html#batcher-transaction">batcher
transactions</a>. The reason to split a channel into frames is that a channel might be too large to
include in a single batcher transaction.</p>
<p>A channel is uniquely identified by its timestamp (UNIX time at which the channel was created) and a random value. See
the <a href="./protocol/derivation.html#frame-format">Frame Format</a> section of the L2 Chain Derivation specification for more information.</p>
<p>On the side of the <a href="glossary.html#rollup-node">rollup node</a> (which is the consumer of channels), a channel is considered to be
<em>opened</em> if its final frame (explicitly marked as such) has not been read, or closed otherwise.</p>
<h2 id="channel-frame"><a class="header" href="#channel-frame">Channel Frame</a></h2>
<p>A channel frame is a chunk of data belonging to a <a href="glossary.html#channel">channel</a>. <a href="glossary.html#batcher-transaction">Batcher transactions</a> carry one or
multiple frames. The reason to split a channel into frames is that a channel might too large to include in a single
batcher transaction.</p>
<h2 id="batcher-1"><a class="header" href="#batcher-1">Batcher</a></h2>
<p>A batcher is a software component (independent program) that is responsible to make channels available on a data
availability provider. The batcher communicates with the rollup node in order to retrieve the channels. The channels are
then made available using <a href="glossary.html#batcher-transaction">batcher transactions</a>.</p>
<blockquote>
<p><strong>TODO</strong> In the future, we might want to make the batcher responsible for constructing the channels, letting it only
query the rollup node for L2 block inputs.</p>
</blockquote>
<h2 id="batcher-transaction"><a class="header" href="#batcher-transaction">Batcher Transaction</a></h2>
<p>A batcher transaction is a transaction submitted by a <a href="glossary.html#batcher">batcher</a> to a data availability provider, in order to make
channels available. These transactions carry one or more full frames, which may belong to different channels. A
channel's frame may be split between multiple batcher transactions.</p>
<p>When submitted to Ethereum calldata, the batcher transaction's receiver must be the sequencer inbox address. The
transaction must also be signed by a recognized batch submitter account. The recognized batch submitter account
is stored in the <a href="glossary.html#system-configuration">System Configuration</a>.</p>
<h2 id="channel-timeout"><a class="header" href="#channel-timeout">Channel Timeout</a></h2>
<p>The channel timeout is a duration (in L1 blocks) during which <a href="glossary.html#channel-frame">channel frames</a> may land on L1 within
<a href="glossary.html#batcher-transaction">batcher transactions</a>.</p>
<p>The acceptable time range for the frames of a <a href="glossary.html#channel">channel</a> is <code>[channel_id.timestamp, channel_id.timestamp + CHANNEL_TIMEOUT]</code>. The acceptable L1 block range for these frames are any L1 block whose timestamp falls inside this
time range. (Note that <code>channel_id.timestamp</code> must be lower than the L1 block timestamp of any L1 block in which frames
of the channel are seen, or else these frames are ignored.)</p>
<p>The purpose of channel timeouts is dual:</p>
<ul>
<li>Avoid keeping old unclosed channel data around forever (an unclosed channel is a channel whose final frame was not
sent).</li>
<li>Bound the number of L1 blocks we have to look back in order to decode <a href="glossary.html#sequencer-batch">sequencer batches</a> from
channels. This is particularly relevant during L1 re-orgs, see the <a href="./protocol/derivation.html#resetting-channel-buffering">Resetting Channel Buffering</a>
section of the L2 Chain Derivation specification for more information.</li>
</ul>
<blockquote>
<p><strong>TODO</strong> specify <code>CHANNEL_TIMEOUT</code></p>
</blockquote>
<hr />
<h1 id="l2-output-root-proposals"><a class="header" href="#l2-output-root-proposals">L2 Output Root Proposals</a></h1>
<h2 id="proposer"><a class="header" href="#proposer">Proposer</a></h2>
<p>The proposer's role is to construct and submit output roots, which are commitments to the L2's state, to the
L2OutputOracle contract on L1 (the settlement layer). To do this, the proposer periodically queries the rollup node for
the latest output root derived from the latest finalized L1 block. It then takes the output root and submits it to the
L2OutputOracle contract on the settlement layer (L1).</p>
<hr />
<h1 id="l2-chain-derivation"><a class="header" href="#l2-chain-derivation">L2 Chain Derivation</a></h1>
<p>L2 chain derivation is a process that reads <a href="glossary.html#l2-derivation-inputs">L2 derivation inputs</a> from L1 in order to derive the L2
chain.</p>
<p>See the <a href="./protocol/derivation.html">L2 chain derivation specification</a> for more details.</p>
<h2 id="l2-derivation-inputs"><a class="header" href="#l2-derivation-inputs">L2 Derivation Inputs</a></h2>
<p>This term refers to data that is found in L1 blocks and is read by the <a href="glossary.html#rollup-node">rollup node</a> to construct <a href="glossary.html#payload-attributes">payload
attributes</a>.</p>
<p>L2 derivation inputs include:</p>
<ul>
<li>L1 block attributes
<ul>
<li>block number</li>
<li>timestamp</li>
<li>basefee</li>
<li>blob base fee</li>
</ul>
</li>
<li><a href="glossary.html#deposits">deposits</a> (as log data)</li>
<li><a href="glossary.html#sequencer-batch">sequencer batches</a> (as transaction data)</li>
<li><a href="glossary.html#system-configuration">System configuration</a> updates (as log data)</li>
</ul>
<h2 id="system-configuration"><a class="header" href="#system-configuration">System Configuration</a></h2>
<p>This term refers to the collection of dynamically configurable rollup parameters maintained
by the <a href="glossary.html#system-configuration"><code>SystemConfig</code></a> contract on L1 and read by the L2 <a href="glossary.html#L2-chain-derivation">derivation</a> process.
These parameters enable keys to be rotated regularly and external cost parameters to be adjusted
without the network upgrade overhead of a hardfork.</p>
<h2 id="payload-attributes"><a class="header" href="#payload-attributes">Payload Attributes</a></h2>
<p>This term refers to an object that can be derived from <a href="glossary.html#l2-derivation-inputs">L2 chain derivation inputs</a> found on L1, which are
then passed to the <a href="glossary.html#execution-engine">execution engine</a> to construct L2 blocks.</p>
<p>The payload attributes object essentially encodes <a href="glossary.html#block">a block without output properties</a>.</p>
<p>Payload attributes are originally specified in the <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/shanghai.md#PayloadAttributesV2">Ethereum Engine API specification</a>, which we expand in
the <a href="./protocol/exec-engine.html">Execution Engine Specification</a>.</p>
<p>See also the <a href="./protocol/rollup-node.html#building-the-payload-attributes">Building The Payload Attributes</a> section of the rollup node specification.</p>
<h2 id="l2-genesis-block"><a class="header" href="#l2-genesis-block">L2 Genesis Block</a></h2>
<p>The L2 genesis block is the first block of the L2 chain in its current version.</p>
<p>The state of the L2 genesis block comprises:</p>
<ul>
<li>State inherited from the previous version of the L2 chain.
<ul>
<li>This state was possibly modified by &quot;state surgeries&quot;. For instance, the migration to Bedrock entailed changes on
how native ETH balances were stored in the storage trie.</li>
</ul>
</li>
<li><a href="glossary.html#predeployed-contract-predeploy">Predeployed contracts</a></li>
</ul>
<p>The timestamp of the L2 genesis block must be a multiple of the <a href="glossary.html#block-time">block time</a> (i.e. a even number, since the
block time is 2 seconds).</p>
<p>When updating the rollup protocol to a new version, we may perform a <em>squash fork</em>, a process that entails the creation
of a new L2 genesis block. This new L2 genesis block will have block number <code>X + 1</code>, where <code>X</code> is the block number of
the final L2 block before the update.</p>
<p>A squash fork is not to be confused with a <em>re-genesis</em>, a similar process that we employed in the past, which also
resets L2 block numbers, such that the new L2 genesis block has number 0. We will not employ re-genesis in the future.</p>
<p>Squash forks are superior to re-geneses because they avoid duplicating L2 block numbers, which breaks a lot of external
tools.</p>
<h2 id="l2-chain-inception"><a class="header" href="#l2-chain-inception">L2 Chain Inception</a></h2>
<p>The L1 block number at which the output roots for the <a href="glossary.html#l2-genesis-block">genesis block</a> were proposed on the <a href="glossary.html#l2-output-oracle-contract">output
oracle</a> contract.</p>
<p>In the current implementation, this is the L1 block number at which the output oracle contract was deployed or upgraded.</p>
<h2 id="safe-l2-block"><a class="header" href="#safe-l2-block">Safe L2 Block</a></h2>
<p>A safe L2 block is an L2 block that can be derived entirely from L1 by a <a href="glossary.html#rollup-node">rollup node</a>. This can vary
between different nodes, based on their view of the L1 chain.</p>
<h2 id="safe-l2-head"><a class="header" href="#safe-l2-head">Safe L2 Head</a></h2>
<p>The safe L2 head is the highest <a href="glossary.html#safe-l2-block">safe L2 block</a> that a <a href="glossary.html#rollup-node">rollup node</a> knows about.</p>
<h2 id="unsafe-l2-block"><a class="header" href="#unsafe-l2-block">Unsafe L2 Block</a></h2>
<p>An unsafe L2 block is an L2 block that a <a href="glossary.html#rollup-node">rollup node</a> knows about, but which was not derived from the L1
chain. In sequencer mode, this will be a block sequenced by the sequencer itself. In validator mode, this will be a
block acquired from the sequencer via <a href="glossary.html#unsafe-sync">unsafe sync</a>.</p>
<h2 id="unsafe-l2-head"><a class="header" href="#unsafe-l2-head">Unsafe L2 Head</a></h2>
<p>The unsafe L2 head is the highest <a href="glossary.html#unsafe-l2-block">unsafe L2 block</a> that a <a href="glossary.html#rollup-node">rollup node</a> knows about.</p>
<h2 id="unsafe-block-consolidation"><a class="header" href="#unsafe-block-consolidation">Unsafe Block Consolidation</a></h2>
<p>Unsafe block consolidation is the process through which the <a href="glossary.html#rollup-node">rollup node</a> attempts to move the <a href="glossary.html#safe-l2-head">safe L2
head</a> a block forward, so that the oldest <a href="glossary.html#unsafe-l2-block">unsafe L2 block</a> becomes the new safe L2 head.</p>
<p>In order to perform consolidation, the node verifies that the <a href="glossary.html#payload-attributes">payload attributes</a> derived from the L1
chain match the oldest unsafe L2 block exactly.</p>
<p>See the <a href="./protocol/derivation.html#engine-queue">Engine Queue section</a> of the L2 chain derivatiaon spec for more information.</p>
<h2 id="finalized-l2-head"><a class="header" href="#finalized-l2-head">Finalized L2 Head</a></h2>
<p>The finalized L2 head is the highest L2 block that can be derived from <em><a href="https://hackmd.io/@prysmaticlabs/finality">finalized</a></em> L1 blocks â€” i.e. L1
blocks older than two L1 epochs (64 L1 <a href="glossary.html#time-slot">time slots</a>).</p>
<hr />
<h1 id="other-l2-chain-concepts"><a class="header" href="#other-l2-chain-concepts">Other L2 Chain Concepts</a></h1>
<h2 id="address-aliasing-1"><a class="header" href="#address-aliasing-1">Address Aliasing</a></h2>
<p>When a contract submits a <a href="glossary.html#deposits">deposit</a> from L1 to L2, its address (as returned by <code>ORIGIN</code> and <code>CALLER</code>) will be
aliased with a modified representation of the address of a contract.</p>
<ul>
<li>cf. <a href="./protocol/deposits.html#address-aliasing">Deposit Specification</a></li>
</ul>
<h2 id="rollup-node"><a class="header" href="#rollup-node">Rollup Node</a></h2>
<p>The rollup node is responsible for <a href="glossary.html#L2-chain-derivation">deriving the L2 chain</a> from the L1 chain (L1 <a href="glossary.html#block">blocks</a> and their
associated <a href="glossary.html#receipt">receipts</a>).</p>
<p>The rollup node can run either in <em>validator</em> or <em>sequencer</em> mode.</p>
<p>In sequencer mode, the rollup node receives L2 transactions from users, which it uses to create L2 blocks. These are
then submitted to a <a href="glossary.html#data-availability-provider">data availability provider</a> via <a href="glossary.html#batch-submission">batch submission</a>. The L2 chain
derivation then acts as a sanity check and a way to detect L1 chain <a href="glossary.html#chain-re-organization">re-orgs</a>.</p>
<p>In validator mode, the rollup node performs derivation as indicated above, but is also able to &quot;run ahead&quot; of the L1
chain by getting blocks directly from the sequencer, in which case derivation serves to validate the sequencer's
behaviour.</p>
<p>A rollup node running in validator mode is sometimes called <em>a replica</em>.</p>
<blockquote>
<p><strong>TODO</strong> expand this to include output root submission</p>
</blockquote>
<p>See the <a href="./protocol/rollup-node.html">rollup node specification</a> for more information.</p>
<h2 id="rollup-driver"><a class="header" href="#rollup-driver">Rollup Driver</a></h2>
<p>The rollup driver is the <a href="glossary.html#rollup-node">rollup node</a> component responsible for <a href="glossary.html#L2-chain-derivation">deriving the L2 chain</a>
from the L1 chain (L1 <a href="glossary.html#block">blocks</a> and their associated <a href="glossary.html#receipt">receipts</a>).</p>
<blockquote>
<p><strong>TODO</strong> delete this entry, alongside its reference â€” can be replaced by &quot;derivation process&quot; or &quot;derivation logic&quot;
where needed</p>
</blockquote>
<h2 id="l1-attributes-predeployed-contract-1"><a class="header" href="#l1-attributes-predeployed-contract-1">L1 Attributes Predeployed Contract</a></h2>
<p>A <a href="glossary.html#predeployed-contract-predeploy">predeployed contract</a> on L2 that can be used to retrieve the L1 block attributes of L1 blocks with a given
block number or a given block hash.</p>
<p>cf. <a href="./protocol/deposits.html#l1-attributes-predeployed-contract">L1 Attributes Predeployed Contract Specification</a></p>
<h2 id="l2-output-root"><a class="header" href="#l2-output-root">L2 Output Root</a></h2>
<p>A 32 byte value which serves as a commitment to the current state of the L2 chain.</p>
<p>cf. <a href="./protocol/proposals.html#l2-output-root-proposals-specification">Proposing L2 output commitments</a></p>
<h2 id="l2-output-oracle-contract"><a class="header" href="#l2-output-oracle-contract">L2 Output Oracle Contract</a></h2>
<p>An L1 contract to which <a href="glossary.html#l2-output-root">L2 output roots</a> are posted by the <a href="glossary.html#sequencer">sequencer</a>.</p>
<h2 id="validator"><a class="header" href="#validator">Validator</a></h2>
<p>A validator is an entity (individual or organization) that runs a <a href="glossary.html#rollup-node">rollup node</a> in validator mode.</p>
<p>Doing so grants a lot of benefits similar to running an Ethereum node, such as the ability to simulate L2 transactions
locally, without rate limiting.</p>
<p>It also lets the validator verify the work of the <a href="glossary.html#sequencer">sequencer</a>, by re-deriving <a href="glossary.html#l2-output-root">output roots</a> and comparing
them against those submitted by the sequencer. In case of a mismatch, the validator can perform a <a href="glossary.html#fault-proof">fault
proof</a>.</p>
<h2 id="fault-proof-1"><a class="header" href="#fault-proof-1">Fault Proof</a></h2>
<p>An on-chain <em>interactive</em> proof, performed by <a href="glossary.html#validator">validators</a>, that demonstrates that a <a href="glossary.html#sequencer">sequencer</a> provided
erroneous <a href="glossary.html#l2-output-root">output roots</a>.</p>
<p>cf. <a href="./experimental/fault-proof/index.html">Fault Proofs</a></p>
<h2 id="time-slot"><a class="header" href="#time-slot">Time Slot</a></h2>
<p>On L2, there is a block every 2 second (this duration is known as the <a href="glossary.html#block-time">block time</a>).</p>
<p>We say that there is a &quot;time slot&quot; every multiple of 2s after the timestamp of the <a href="glossary.html#l2-genesis-block">L2 genesis block</a>.</p>
<p>On L1, post-<a href="https://ethereum.org/en/eth2/merge/">merge</a>, the time slots are every 12s. However, an L1 block may not be produced for every time slot, in case
of even benign consensus issues.</p>
<h2 id="block-time"><a class="header" href="#block-time">Block Time</a></h2>
<p>The L2 block time is 2 second, meaning there is an L2 block at every 2s <a href="glossary.html#time-slot">time slot</a>.</p>
<p>Post-<a href="https://ethereum.org/en/eth2/merge/">merge</a>, it could be said that the L1 block time is 12s as that is the L1 <a href="glossary.html#time-slot">time slot</a>. However, in
reality the block time is variable as some time slots might be skipped.</p>
<p>Pre-merge, the L1 block time is variable, though it is on average 13s.</p>
<h2 id="unsafe-sync"><a class="header" href="#unsafe-sync">Unsafe Sync</a></h2>
<p>Unsafe sync is the process through which a <a href="glossary.html#validator">validator</a> learns about <a href="glossary.html#unsafe-l2-block">unsafe L2 blocks</a> from
the <a href="glossary.html#sequencer">sequencer</a>.</p>
<p>These unsafe blocks will later need to be confirmed by the L1 chain (via <a href="glossary.html#unsafe-block-consolidation">unsafe block consolidation</a>).</p>
<hr />
<h1 id="execution-engine-concepts"><a class="header" href="#execution-engine-concepts">Execution Engine Concepts</a></h1>
<h2 id="execution-engine"><a class="header" href="#execution-engine">Execution Engine</a></h2>
<p>The execution engine is responsible for executing transactions in blocks and computing the resulting state roots,
receipts roots and block hash.</p>
<p>Both L1 (post-<a href="https://ethereum.org/en/eth2/merge/">merge</a>) and L2 have an execution engine.</p>
<p>On L1, the executed blocks can come from L1 block synchronization; or from a block freshly minted by the execution
engine (using transactions from the L1 <a href="https://www.quicknode.com/guides/defi/how-to-access-ethereum-mempool">mempool</a>), at the request of the L1 consensus layer.</p>
<p>On L2, the executed blocks are freshly minted by the execution engine at the request of the <a href="glossary.html#rollup-node">rollup node</a>,
using transactions <a href="glossary.html#L2-chain-derivation">derived from L1 blocks</a>.</p>
<p>In these specifications, &quot;execution engine&quot; always refer to the L2 execution engine, unless otherwise specified.</p>
<ul>
<li>cf. <a href="./protocol/exec-engine.html">Execution Engine Specification</a></li>
</ul>
<!-- Internal Links -->
<!-- External Links -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="meta-processes"><a class="header" href="#meta-processes">Meta Processes</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<p>This directory describes processes that we use to lint/test the specification.</p>
<ul>
<li><a href="meta/markdown-style.html">Markdown Style Guide</a>: how to format and structure Markdown files.</li>
<li><a href="meta/versioning.html">Versioning</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="linting"><a class="header" href="#linting">Linting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="meta/versioning.html#go-modules">Go modules</a>
<ul>
<li><a href="meta/versioning.html#versioning-process">versioning process</a></li>
</ul>
</li>
<li><a href="meta/versioning.html#typescript">Typescript</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="go-modules"><a class="header" href="#go-modules">Go modules</a></h2>
<p>Go modules that are currently versioned:</p>
<pre><code class="language-text">./op-service
./op-bindings
./op-batcher
./op-node
./op-proposer
./op-e2e
</code></pre>
<p>Go modules which are not yet versioned:</p>
<pre><code class="language-text">./indexer          (changesets)
./proxyd           (changesets)
</code></pre>
<h3 id="versioning-process"><a class="header" href="#versioning-process">versioning process</a></h3>
<p>Since changesets versioning is not compatible with Go we are moving away from it.
Starting with new bedrock modules, Go-compatible tags will be used,
formatted as <code>modulename/vX.Y.Z</code> where <code>vX.Y.Z</code> is semver.</p>
<h2 id="typescript"><a class="header" href="#typescript">Typescript</a></h2>
<p>See Changesets.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="markdown-style-guide"><a class="header" href="#markdown-style-guide">Markdown Style Guide</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="meta/markdown-style.html#linting">Linting</a></li>
<li><a href="meta/markdown-style.html#links">Links</a>
<ul>
<li><a href="meta/markdown-style.html#glossary">Glossary</a></li>
</ul>
</li>
<li><a href="meta/markdown-style.html#internal-in-file-links">Internal (In-File) Links</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="linting-1"><a class="header" href="#linting-1">Linting</a></h2>
<p>Respect the <a href="meta/linting.html#markdown">linting rules</a> (you can run the linter with <code>pnpm lint</code>).</p>
<p>Notably:</p>
<ul>
<li>lines should be &lt; 120 characters long
<ul>
<li>in practice, some of our files are justified at 100 characters, some at 120</li>
</ul>
</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>In general:</p>
<ul>
<li>Use link references preferentially.
<ul>
<li>e.g. <code>[my text][link-ref]</code> and then on its own line <code>[link-ref]: https://mylink.com</code></li>
<li>e.g. <code>[my text]</code> and then on its own line: <code>[my text]: https://mylink.com</code></li>
<li>exceptions: where it fits neatly on a single line, in particular in lists of links</li>
</ul>
</li>
<li>Excepted for internal and glossary links (see below), add the link reference definition directly
after the paragraph where the link first appears.</li>
</ul>
<h3 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h3>
<ul>
<li>Use links to the <a href="meta/../glossary.html">glossary</a> liberally.</li>
<li>Include the references to all the glossary links at the top of the file, under the top-level
title.</li>
<li>A glossary link reference should start with the <code>g-</code> prefix. This enables to see what links to the
glossary at a glance when editing the specification.
<ul>
<li>e.g. <code>[g-block]: glossary.md#block</code></li>
</ul>
</li>
<li>Example: <a href="https://raw.githubusercontent.com/ethereum-optimism/optimistic-specs/main/specs/rollup-node.md">Rollup Node Specification source</a></li>
</ul>
<h2 id="internal-in-file-links"><a class="header" href="#internal-in-file-links">Internal (In-File) Links</a></h2>
<p>If linking to another heading to the same file, add the link reference directly under that heading.
This makes it easier to keep the heading and the link in-sync, and signals that the heading is being
linked to from elsewhere.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="specs/static/solidity.min.js"></script>
        <script src="specs/static/mermaid.min.js"></script>
        <script src="specs/static/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
