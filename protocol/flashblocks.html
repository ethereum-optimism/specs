<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flashblocks - OP Stack Specification</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-YNLKSPKGWN"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());
            gtag('config', 'G-YNLKSPKGWN');
        </script>
        <meta name="google-site-verification" content="1XjEcxxHshd6NM_mxbl_uv-SyamI6_99aOpILYI3_mk" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/footer.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OP Stack Specification</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ethereum-optimism/specs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ethereum-optimism/specs/edit/main/specs/protocol/flashblocks.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="flashblocks"><a class="header" href="#flashblocks">Flashblocks</a></h1>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#specification">Specification</a>
<ul>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#data-structures">Data structures</a>
<ul>
<li><a href="#flashblockspayloadv1"><strong><code>FlashblocksPayloadV1</code></strong></a></li>
<li><a href="#executionpayloadflashblockdeltav1"><strong><code>ExecutionPayloadFlashblockDeltaV1</code></strong></a></li>
<li><a href="#executionpayloadstaticv1"><strong><code>ExecutionPayloadStaticV1</code></strong></a></li>
<li><a href="#metadata"><strong><code>Metadata</code></strong></a></li>
<li><a href="#accountmetadata"><strong><code>AccountMetadata</code></strong></a></li>
<li><a href="#storageslot"><strong><code>StorageSlot</code></strong></a></li>
<li><a href="#transactionmetadata"><strong><code>TransactionMetadata</code></strong></a></li>
</ul>
</li>
<li><a href="#system-architecture">System architecture</a></li>
<li><a href="#out-of-protocol-design">Out-of-Protocol Design</a>
<ul>
<li><a href="#in-protocol-vs-out-of-protocol">In-Protocol vs. Out-of-Protocol</a></li>
<li><a href="#design-rationale-and-benefits">Design Rationale and Benefits</a></li>
<li><a href="#implications-for-this-specification">Implications for This Specification</a></li>
</ul>
</li>
<li><a href="#assumptions-about-op-stack">Assumptions About Op Stack</a></li>
<li><a href="#flashblock-lifecycle">Flashblock Lifecycle</a></li>
<li><a href="#flashblock-construction-process">Flashblock Construction Process</a>
<ul>
<li><a href="#handling-of-sequencer-transactions">Handling of Sequencer Transactions</a></li>
<li><a href="#transaction-inclusion-heuristics">Transaction Inclusion Heuristics</a></li>
<li><a href="#post-block-execution-rules">Post-block Execution Rules</a></li>
<li><a href="#construction-steps">Construction Steps</a></li>
</ul>
</li>
<li><a href="#flashblocks-metadata">Flashblocks Metadata</a>
<ul>
<li><a href="#alternative-design-consideration">Alternative Design Consideration</a></li>
</ul>
</li>
<li><a href="#rationale-for-including-state-roots-in-flashblocks">Rationale for Including State Roots in Flashblocks</a>
<ul>
<li><a href="#non-blocking-block-production">Non-Blocking Block Production</a></li>
<li><a href="#builder-availability-and-system-reliability">Builder Availability and System Reliability</a></li>
<li><a href="#future-design-considerations">Future Design Considerations</a></li>
</ul>
</li>
<li><a href="#builder-to-rollup-boost-communication-flow">Builder-to-Rollup-boost Communication Flow</a></li>
<li><a href="#flashblock-validity-rules">Flashblock Validity Rules</a></li>
<li><a href="#flashblock-system-invariants">Flashblock System Invariants</a></li>
<li><a href="#flashblock-propagation">Flashblock Propagation</a>
<ul>
<li><a href="#secure-propagation">Secure propagation</a></li>
</ul>
</li>
<li><a href="#flashblock-json-rpc-apis">Flashblock JSON-RPC APIs</a>
<ul>
<li><a href="#ethereum-json-rpc-modifications">Ethereum JSON RPC Modifications</a></li>
<li><a href="#op_supportedcapabilities">op_supportedCapabilities</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reliability-and-operational-considerations">Reliability and Operational Considerations</a>
<ul>
<li><a href="#transaction-propagation">Transaction Propagation</a></li>
<li><a href="#failover-scenarios">Failover scenarios</a>
<ul>
<li><a href="#block-builder">Block Builder</a></li>
<li><a href="#the-sequencer-or-rollup-boost">The Sequencer or Rollup-boost</a></li>
</ul>
</li>
<li><a href="#integration-with-high-availability-sequencer-setups">Integration with High Availability Sequencer Setups</a></li>
<li><a href="#faults">Faults</a>
<ul>
<li><a href="#safety-faults"><strong>Safety Faults</strong></a></li>
<li><a href="#liveness-faults"><strong>Liveness Faults</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rationale">Rationale</a>
<ul>
<li><a href="#why-out-of-protocol">Why out-of-protocol</a>
<ul>
<li><a href="#why-not-shorter-block-times">Why not shorter block times</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a>
<ul>
<li><a href="#end-users">End Users</a></li>
<li><a href="#infrastructure-operators">Infrastructure Operators</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="abstract"><a class="header" href="#abstract">Abstract</a></h1>
<p>Introduces a standard for partial blocks called “Flashblocks,” inspired but not entirely identical to <a href="https://github.com/solana-foundation/specs/blob/main/p2p/shred.md">Solana
Shreds</a>, enabling rapid preconfirmations on Ethereum
Layer 2 networks such as OP Stack. Flashblocks propagate transaction batches incrementally and expose their state via a
modified Ethereum JSON-RPC interface, giving users immediate feedback equivalent to drastically reduced block times
without modifying the underlying OP Stack protocol. Flashblocks can be combined with Trusted Execution Environment
technology to enable quick verifiability over various networks of machines in addition to protection from equivocation.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>This document assumes knowledge of the terminology, definitions, and other material in</p>
<ul>
<li><a href="https://github.com/ethereum-optimism/">🔗 Ethereum Optimism Protocol Specs</a></li>
<li><a href="https://specs.optimism.io/protocol/exec-engine.html#engine-api">🔗 OP Stack Engine API</a></li>
<li><a href="https://github.com/ethereum-optimism/">🔗 External Block Production in OP Stack Design Doc</a></li>
<li><a href="https://github.com/ethereum/execution-apis/tree/main">🔗 Ethereum Execution APIs</a></li>
<li><a href="https://writings.flashbots.net/introducing-rollup-boost">🔗 Introducing Rollup-Boost - Launching on Unichain</a></li>
<li><a href="https://www.notion.so/RFD-1-Rollup-boost-1996b4a0d876802f95d1c98387e38162?pvs=21">🔗 Rollup-boost design doc</a></li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>As of April 2025, Layer 2 (L2) protocols built with the OP Stack have a minimum block time of one second, imposing
significant constraints on user experience. The limitation on minimum block times is primarily historical and
architectural, reflecting earlier assumptions of Ethereum network as well as deeply-integrated type definitions, from
the L2 blockchain client all the way down to smart contracts on the L1, making modification a very large task.</p>
<p>Due to similar constraints on Ethereum Layer 1, preconfirmations have gained attention as a promising method to
decouple blockchain user experiences from rigid block-time limitations and sidestep the longstanding debate between
block time and block size. Existing preconfirmation solutions predominantly depend on economic security in the form of
cryptoeconomic mechanisms such as staking. As well as focus on per-transaction preconfirmations, inadvertently pushing
protocols into the “Latency Auction” region of the <a href="https://writings.flashbots.net/introducing-rollup-boost">MEV
Trilemma</a>. Furthermore, previous approaches have often
introduced entirely new Ethereum JSON-RPC methods, presenting substantial integration barriers and hindering practical
adoption.</p>
<p>Inspired by modern blockchain networks like Solana and Celestia, Flashblocks introduce an “out-of-protocol” standard
for incremental delivery of partial blocks containing batches of transactions. This approach significantly reduces
perceived latency for end-users  and improves network bandwidth without modifying underlying protocol rules, offering a
streamlined path for incremental adoption by node operators and existing infrastructure.</p>
<h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>All terms, actors, and components are used in this document identically to how they are defined in the <a href="https://github.com/ethereum-optimism/">OP Stack
protocol definition</a></p>
<p>Additional terms introduced:</p>
<ul>
<li><strong>External Block Builder</strong> - External Block Builders are first introduced to the OP Stack in the <a href="https://github.com/ethereum-optimism/">External Block
Production Design Document</a> where
they are described as an external party that the Sequencer can request blocks from.</li>
<li><strong>Rollup Boost</strong> - A sidecar piece of software first introduced without name in the <a href="https://github.com/ethereum-optimism/">External Block Production Design
Document</a> with two
roles:
<ol>
<li>obfuscate the presence of External Block Builder software from the <code>op-node</code> and <code>op-geth</code> software</li>
<li>manage communication from the sequencer with External Block Builders and handle block delivery to <code>op-node</code> .</li>
</ol>
</li>
<li><strong>Fallback EL</strong> - The standard Execution Layer of the Sequencer, used by Rollup Boost as a fallback mechanism when it
cannot successfully build a block through the External Block Builder. This is an unmodified EL node that maintains the
ability to construct valid blocks according to standard OP Stack protocol rules.</li>
<li><strong>RPC Provider</strong> - Ethereum RPC software operator with the purpose of serving Ethereum state.</li>
</ul>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Constant</strong></th><th><strong>Value</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><code>FLASHBLOCKS_TIME</code></td><td>200ms</td><td>Default wall clock time per flashblock.</td></tr>
<tr><td><code>FLASHBLOCKS_PER_L2_BLOCK</code></td><td><code>L2_BLOCK_TIME</code>/<code>FLASHBLOCKS_TIME</code></td><td>Supported number of flashblocks per L2 block. (Ex: 2s/200ms = 10 Flashblocks)</td></tr>
<tr><td><code>MAX_EXTRA_DATA_BYTES</code></td><td>32</td><td>Extra data size in an Optimism block</td></tr>
<tr><td><code>BYTES_PER_LOGS_BLOOM</code></td><td>256</td><td>Size of a logs bloom field in an Optimism block</td></tr>
</tbody></table>
</div>
<h2 id="data-structures"><a class="header" href="#data-structures">Data structures</a></h2>
<h3 id="flashblockspayloadv1"><a class="header" href="#flashblockspayloadv1"><strong><code>FlashblocksPayloadV1</code></strong></a></h3>
<p>The core data structure sent from the Block Builder to Rollup Boost and then external parties.  A container
representing a Flashblock payload, encapsulating block deltas, base configuration, and additional metadata.</p>
<pre><code class="language-python">class FlashblocksPayloadV1():
    version: Bytes4
    payload_id: Bytes8
    parent_flash_hash: Optional[Bytes32]
    index: uint64
    static: Optional[ExecutionPayloadStaticV1]
    diff: ExecutionPayloadFlashblockDeltaV1
    metadata: FlashblocksMetadata
**Field descriptions:**

</code></pre>
<ul>
<li><code>payload_id</code>: PayloadID is an identifier of the payload build process. The same for all flashblocks.</li>
<li><code>index</code>: Index of the Flashblock within the parent block.</li>
<li><code>parent_flash_hash</code>: SSZ hash of the parent flashblock in the sequence. For the first flashblock (index 0), the field
is empty.</li>
<li><code>base</code> <em>(Optional)</em>: Reference execution payload serving as the unchanging base configuration.</li>
<li><code>diff</code>: Container with fields representing changes from the base payload.</li>
<li><code>metadata</code>: Supplementary information about the execution of the flashblock. For example: account state changes,
storage modifications, transaction receipts.</li>
</ul>
<h3 id="executionpayloadflashblockdeltav1"><a class="header" href="#executionpayloadflashblockdeltav1"><strong><code>ExecutionPayloadFlashblockDeltaV1</code></strong></a></h3>
<p>Container encoding only the mutable portions of the execution payload updated during Flashblock construction.</p>
<pre><code class="language-python">class ExecutionPayloadFlashblockDeltaV1():
    state_root: Bytes32
    receipts_root: Bytes32
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    gas_used: uint64
    block_hash: Bytes32
    transactions: List[Transaction]
    withdrawals: List[Withdrawal]
    withdrawals_root: Bytes32
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>state_root</code>: Root hash of the post-execution state trie.</li>
<li><code>receipts_root</code>: Root hash of the transaction receipts trie.</li>
<li><code>logs_bloom</code>: Bloom filter of all logs emitted by the block.</li>
<li><code>gas_used</code>: Gas consumed by included transactions.</li>
<li><code>block_hash</code>: Final hash of the completed execution block.</li>
<li><code>transactions</code>: List of transactions included in the Flashblock.</li>
<li><code>withdrawals</code>: Withdrawals included (as per Optimism specification). Must be non-nil but empty when
<code>withdrawals_root</code> is used directly.</li>
<li><code>withdrawals_root</code>: OP-Stack Isthmus specific field: instead of computing the root from a withdrawals list, set it
directly. The "withdrawals" list attribute must be non-nil but empty.</li>
</ul>
<p><strong>Supporting Type Definitions</strong></p>
<ul>
<li><code>Transaction</code>: Transaction bytes as per execution payload specification.</li>
<li><code>Withdrawal</code>: Standard Ethereum Capella withdrawal container.</li>
</ul>
<p>All fields in this structure represent the cumulative state of the entire block up to and including the current
flashblock, not just the changes from this specific flashblock.</p>
<h3 id="executionpayloadstaticv1"><a class="header" href="#executionpayloadstaticv1"><strong><code>ExecutionPayloadStaticV1</code></strong></a></h3>
<p>Container representing immutable fundamental block properties established at initial block creation, unchanged
throughout construction.</p>
<pre><code class="language-python">class ExecutionPayloadStaticV1():
    parent_beacon_block_root: Bytes32
    parent_hash: Bytes32
    fee_recipient: ExecutionAddress
    prev_randao: Bytes32
    block_number: uint64
    gas_limit: uint64
    timestamp: uint64
    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]
    base_fee_per_gas: uint256
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>parent_beacon_block_root</code>: Ecotone parent beacon block root.</li>
<li><code>parent_hash</code>: Hash of the parent execution block.</li>
<li><code>fee_recipient</code>: Address receiving transaction fees.</li>
<li><code>prev_randao</code>: Previous block’s RANDAO reveal for randomness.</li>
<li><code>block_number</code>: Sequential execution block number.</li>
<li><code>gas_limit</code>: Maximum allowable gas consumption for the block.</li>
<li><code>timestamp</code>: Unix timestamp at block creation.</li>
<li><code>extra_data</code>: Arbitrary extra data bytes included in the block header.</li>
<li><code>base_fee_per_gas</code>: Base fee per gas unit at the block.</li>
</ul>
<h3 id="metadata"><a class="header" href="#metadata"><strong><code>Metadata</code></strong></a></h3>
<p>Container encapsulating all metadata for a flashblock, including account state changes and transaction results.</p>
<pre><code class="language-python">class FlashblockMetadata():
         accounts: List[AccountMetadata]
  transactions: List[TransactionMetadata]
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>accounts</code>: List of accounts with modified state in this flashblock.</li>
<li><code>transactions</code>: List of transaction execution results in this flashblock.</li>
</ul>
<h3 id="accountmetadata"><a class="header" href="#accountmetadata"><strong><code>AccountMetadata</code></strong></a></h3>
<p>Container representing account state changes included in the Flashblock metadata. It is used by providers to fulfill
the RPC requests.</p>
<pre><code class="language-python">class AccountMetadata():
    address: ExecutionAddress
    balance: Optional[uint256]
    nonce: uint64
    code: Optional[Bytes]
    storage_slots: List[StorageSlot]
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>address</code>: Ethereum address of the affected account.</li>
<li><code>balance</code>: Updated account balance after the Flashblock's execution (None if unchanged).</li>
<li><code>nonce</code>: Updated account nonce (transaction count) after the Flashblock's execution.</li>
<li><code>code_created</code>:  Contract bytecode if created in this Flashblock.</li>
<li><code>storage_slots</code>: List of modified storage slots and their new values.</li>
</ul>
<p>Storage slot keys must be de-duplicated (only the final value for each key should be included) and sorted in ascending
byte order for deterministic processing.</p>
<h3 id="storageslot"><a class="header" href="#storageslot"><strong><code>StorageSlot</code></strong></a></h3>
<p>Container representing a single modified storage slot within an account.</p>
<pre><code class="language-python">class StorageSlot():
    key: Bytes32
    value: Bytes32
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>key</code>: Storage slot location (32-byte key).</li>
<li><code>value</code>: New value stored at this slot after the Flashblock's execution.</li>
</ul>
<h3 id="transactionmetadata"><a class="header" href="#transactionmetadata"><strong><code>TransactionMetadata</code></strong></a></h3>
<p>Container representing succinct transaction execution results.</p>
<pre><code class="language-python">class TransactionMetadata():
    status: uint8
    gas_used: uint64
    contract_address: Optional[ExecutionAddress]
</code></pre>
<p><strong>Field descriptions:</strong></p>
<ul>
<li><code>status</code>: Execution status (1 for success, 0 for failure).</li>
<li><code>gas_used</code>: Amount of gas used by this specific transaction.</li>
<li><code>contract_address</code>: Address of created contract (None for non-creation transactions).</li>
</ul>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System architecture</a></h2>
<p>The following diagram illustrates the Flashblocks system architecture, showing the relationships between key components:</p>
<pre class="mermaid">
flowchart LR
    subgraph Sequencer
        ON[OP Node]
        RB[Rollup Boost]
        FEL[Fallback EL]
        BB[Block Builder]
    end

    subgraph Network
        WSP[WebSocket Proxy]
    end

    subgraph Clients
        RPC[RPC Providers]
        Users[End Users]
    end

    ON --&gt; RB
    RB --&gt; FEL
    RB &lt;--&gt; BB
    RB --&gt; WSP
    WSP --&gt; RPC
    RPC --&gt; Users
</pre>
<p>This architecture shows the flow of data through the Flashblocks system:</p>
<ol>
<li>The <strong>OP Node</strong> initiates block production and sends requests to <strong>Rollup Boost</strong></li>
<li><strong>Rollup Boost</strong> coordinates between multiple components:
<ul>
<li>It communicates with the <strong>Block Builder</strong> to create Flashblocks</li>
<li>It maintains a connection to the <strong>Fallback EL</strong> for reliability if the Block Builder fails</li>
<li>It propagates validated Flashblocks to the network via the <strong>WebSocket Proxy</strong></li>
</ul>
</li>
<li>The <strong>WebSocket Proxy</strong> distributes Flashblocks to multiple <strong>RPC Providers</strong></li>
<li><strong>RPC Providers</strong> serve preconfirmation data to <strong>End Users</strong></li>
</ol>
<p>The rest of this document provides detailed specifications for each component and their interactions, explaining the
protocols, data structures, and operational considerations.</p>
<h2 id="out-of-protocol-design"><a class="header" href="#out-of-protocol-design">Out-of-Protocol Design</a></h2>
<p>The Flashblocks specification follows a deliberate "out-of-protocol" design philosophy. This section clarifies what we
mean by this term and explains its implications for the OP Stack ecosystem.</p>
<h3 id="in-protocol-vs-out-of-protocol"><a class="header" href="#in-protocol-vs-out-of-protocol">In-Protocol vs. Out-of-Protocol</a></h3>
<p>In the context of OP Stack, "in-protocol" components form the core protocol itself. These components implement
fundamental consensus rules, are required for basic rollup functionality, and need standardization across all
participants. Modifying in-protocol components requires protocol-level changes and network-wide upgrades.</p>
<p>By contrast, "out-of-protocol" components like Flashblocks operate as optional extensions to the core protocol. They
can be added or removed without breaking the consensus rules of the network, though they may still impact network
performance or operations if implemented poorly.</p>
<p>The only in-protocol guarantee that Flashblocks must uphold is producing valid blocks at the established block time
interval (typically 1-2 seconds in current OP Stack implementations).</p>
<h3 id="design-rationale-and-benefits"><a class="header" href="#design-rationale-and-benefits">Design Rationale and Benefits</a></h3>
<p>The out-of-protocol design for Flashblocks emerged from practical constraints during initial development. Without
strong coordination with the OP Stack team at the outset, and given the complexity of the challenge, working within the
existing protocol boundaries was the most pragmatic approach.</p>
<p>This constraint ultimately proved beneficial, as it forced the design to be minimally invasive. Flashblocks can be
implemented immediately on any OP Stack chain without waiting for protocol upgrades or network-wide consensus.</p>
<p>Any issues with the Flashblocks implementation remain isolated from the core protocol, protecting overall network
stability. In case of serious problems, Flashblocks can be disabled entirely, allowing the system to revert to normal
operation without disrupting the underlying rollup. This clean fallback mechanism benefits from the centralized trust
model of L2s, where the sequencer has the authority to quickly enact such operational changes without requiring
network-wide consensus.</p>
<p>Now that the usefulness of the system has been proven, as more collaboration venues with the OP Stack team emerge,
integrating parts of Flashblocks directly into the protocol could provide even stronger guarantees and open the design
space for future innovations. We are considering that approach too in the future.</p>
<h3 id="implications-for-this-specification"><a class="header" href="#implications-for-this-specification">Implications for This Specification</a></h3>
<p>Most elements defined in this document are out-of-protocol components that operate as extensions to the core OP Stack.
The only hard guarantee the system must provide is that valid blocks are delivered at the expected intervals.</p>
<p>Everything else—from how Flashblocks are constructed and propagated to how RPC providers implement preconfirmation
caches—represents iterative improvements designed to achieve the goal of faster user feedback as efficiently and
impactfully as possible.</p>
<p>This means the specification describes a recommended implementation path rather than rigid protocol requirements.
Components can evolve independently without requiring protocol-level coordination, and implementations may vary in how
they achieve the same functional goals.</p>
<h2 id="assumptions-about-op-stack"><a class="header" href="#assumptions-about-op-stack">Assumptions About Op Stack</a></h2>
<p>The Flashblocks design makes several assumptions about OP Stack behavior:</p>
<ul>
<li><strong>Quick Response for engine_getPayload</strong>: We assume that <code>engine_getPayload</code> requests should return as quickly as
possible for a normal and healthy chain.</li>
<li><strong>Deterministic Payload IDs</strong>: While not specific to Flashblocks but to Rollup Boost in general, we assume that
payload IDs from different execution layer nodes are deterministically computed for the same ForkChoiceUpdate request.
This is not explicitly enforced in specifications, but execution layers tend to maintain this consistency as a
practical implementation detail.</li>
</ul>
<h2 id="flashblock-lifecycle"><a class="header" href="#flashblock-lifecycle">Flashblock Lifecycle</a></h2>
<p>Note that familiarity with Rollup-boost is expected throughout this entire document, as Flashblocks is designed as an
extension built on top of the existing Rollup-boost architecture.</p>
<p>The lifecycle of a Flashblock begins with the Sequencer initiating block creation and ends with a normal L2 block
consisting of all delivered flashblocks propagating according to the OP Stack protocol. The process proceeds as follows:</p>
<ol>
<li>
<p><strong>Fork Choice Update</strong>:</p>
<p>The Sequencer initiates the block-building cycle by sending an <code>engine_forkchoiceUpdated</code> with attributes call to
Rollup Boost as it normally would to its local Execution Engine.</p>
</li>
<li>
<p><strong>Fork Choice Update Forwarding</strong>:</p>
<p>Rollup Boost forwards the <code>engine_forkchoiceUpdated</code> call concurrently to:</p>
<ul>
<li>The Sequencer's local Execution Engine</li>
<li>The External Block Builder</li>
</ul>
</li>
<li>
<p><strong>Flashblock Construction</strong>:</p>
<p>Upon receiving the fork choice update, the External Block Builder constructs and continuously delivers
<code>FlashblocksPayloadV1</code> at intervals defined by <code>FLASHBLOCKS_TIME</code> following the <strong>Flashblocks Construction Process</strong>
defined in this document.</p>
<p>It's important to emphasize that during this process, the External Block Builder sends only the incremental changes
in each Flashblock, not the full block state each time. Each <code>FlashblocksPayloadV1</code> contains just the delta from the
previous state (new transactions, updated state roots, etc.), allowing for efficient bandwidth usage and faster
propagation.</p>
<p>Only the first Flashblock (with <code>index</code> 0) includes the <code>static</code> field containing immutable block data, while
subsequent Flashblocks omit this field since this information remains constant throughout the block's construction.
Each Flashblock includes a <code>parent_flash_hash</code> that references the SSZ hash of the previous Flashblock in the sequence,
creating a hash-linked chain within the block.</p>
<p>The combined information received across all flashblocks is sufficient to fully reconstruct the complete block
without any additional data.</p>
</li>
<li>
<p><strong>Flashblock Validation and Propagation</strong>:</p>
<p>For each received <code>FlashblocksPayloadV1</code>, Rollup Boost validates it against the Sequencer’s local Execution Engine
and according to the <strong>Flashblocks Validity Rules</strong> defined in this document. Upon successful validation, Rollup Boost
propagates the payload to all subscribed Flashblock-compatible RPC providers.</p>
</li>
<li>
<p><strong>Preconfirmed State Updates</strong>:</p>
<p>Flashblock-compatible RPC providers insert validated payloads into their local Preconfirmed State Overlay,
providing immediate preconfirmation states to end-users via Flashblock-enhanced Ethereum JSON-RPC endpoints.</p>
</li>
<li>
<p><strong>Final L2 Block Delivery</strong>:</p>
<p>When the Sequencer calls <code>engine_getPayload</code>, Rollup Boost returns a single coherent block payload based on the
validated Flashblocks received since the last fork choice update. Note that this does not require additional external
requests or any last-minute processing.</p>
</li>
<li>
<p><strong>Full Block Propagation</strong>:</p>
<p>The Sequencer propagates the aggregated block following standard OP Stack protocol rules.</p>
</li>
</ol>
<pre class="mermaid">sequenceDiagram
    participant S as Sequencer Driver (op-node)
    participant RB as Rollup Boost
    participant EE as Sequencer Execution Engine (op-geth)
    participant BB as External Block Builder
    participant RPC as Flashblock RPC Providers
    participant U as End Users

    rect rgb(230,247,255)
        Note over S: 1. **Fork Choice Update**
        S-&gt;&gt;RB: engine_forkchoiceUpdated
    end

    rect rgb(255,242,230)
        Note over RB: 2. **Fork Choice Update Forwarding**
        RB-&gt;&gt;EE: engine_forkchoiceUpdated
        RB-&gt;&gt;BB: engine_forkchoiceUpdated
    end

    rect rgb(230,255,235)
    loop **Flashblock Construction** (every FLASHBLOCKS_TIME)
        Note over BB: **3. Flashblock Construction**
        BB-&gt;&gt;RB: FlashblocksPayloadV1

        rect rgb(252,244,255)
            Note over RB, EE: 4. **Flashblock Validation and Propagation**
            RB-&gt;&gt;EE: Validate Payload
            EE--&gt;&gt;RB: Validation Result

            alt Success
                RB-&gt;&gt;RPC: Propagate Valid Payload
                Note over RPC: 5. **Preconfirmed State Updates**
                RPC-&gt;&gt;RPC: Update State Overlay
                RPC-&gt;&gt;U: Serve Preconfirmed State
            else Failure
                RB--&gt;&gt;RB: Discard and fallback
            end
        end
    end
    end

    rect rgb(255,249,196)
        Note over S, RB: 6. **Final L2 Block Delivery**
        S-&gt;&gt;RB: engine_getPayload
        RB-&gt;&gt;S: Aggregate Payload
    end

    rect rgb(240,240,240)
        Note over S: 7. **Full Block Propagation**
        S-&gt;&gt;S: Propagate Block (standard OP Stack)
    end
</pre>
<h2 id="flashblock-construction-process"><a class="header" href="#flashblock-construction-process">Flashblock Construction Process</a></h2>
<p>The External Block Builder initiates the construction of Flashblocks upon receiving a fork choice update
(<code>engine_forkchoiceUpdated</code>) call forwarded by Rollup Boost. The construction of Flashblocks follows a defined sequence
of steps repeated every <code>FLASHBLOCKS_TIME</code> interval, ensuring consistent, incremental, and ordered propagation of
preconfirmed state to end-users. It's important to note that <code>FLASHBLOCKS_TIME</code> serves as a target interval rather than
a strictly enforced rule in Rollup Boost.</p>
<h3 id="handling-of-sequencer-transactions"><a class="header" href="#handling-of-sequencer-transactions">Handling of Sequencer Transactions</a></h3>
<p>An important protocol rule that the Flashblock construction process must adhere to involves handling "system
transactions" within the OP Stack. These include deposits and system transactions that arrive with the Fork Choice
Update (FCU) and must always be executed as the first transactions in any valid block.</p>
<p>From an "in-protocol" perspective, a block is not considered valid if these sequencer transactions are missing.
Consequently, the minimum valid block that can be constructed must include the execution of these transactions.</p>
<p>The External Block Builder follows this mandate by executing these sequencer transactions first and including them in
the initial Flashblock (index 0). This serves as the foundation upon which all subsequent Flashblocks in the sequence
will build.</p>
<p>When processing these mandatory sequencer transactions, the builder does not apply the same gas allocation heuristics
used for regular transactions in later Flashblocks. While these transactions do consume gas like any other transaction,
they receive special handling as they must be included regardless of gas considerations to maintain protocol validity.</p>
<h3 id="transaction-inclusion-heuristics"><a class="header" href="#transaction-inclusion-heuristics">Transaction Inclusion Heuristics</a></h3>
<p>As part of the flashblock construction process, the External Block Builder makes sophisticated decisions about
transaction inclusion. Unlike rigid gas limit enforcement, the decision of when to stop including transactions in a
flashblock involves nuanced heuristics that may evolve over time.</p>
<p>The builder must balance multiple factors when deciding which transactions to include in each flashblock:</p>
<ul>
<li>Optimizing for user experience by providing quick feedback</li>
<li>Ensuring transactions with higher gas usage aren't permanently excluded</li>
<li>Maintaining efficient gas utilization across the entire block</li>
<li>Accounting for execution time constraints within the <code>FLASHBLOCKS_TIME</code> window</li>
</ul>
<p>In some cases, the builder might include a transaction that exceeds what would be a strict per-flashblock gas limit
because executing that transaction is important for user experience or economic reasons. This flexibility is a key
advantage of the out-of-protocol approach.</p>
<p>The specific heuristics for transaction allocation across flashblocks are intentionally not prescribed in this
specification. Rather than codifying particular strategies, we leave this as an area where builders can innovate and
optimize. Different chains can develop custom heuristics based on their specific transaction patterns, user
expectations, and economic models. As implementations mature, we expect some general principles will emerge for
handling common scenarios, but this specification intentionally avoids prematurely constraining this design space.</p>
<h3 id="post-block-execution-rules"><a class="header" href="#post-block-execution-rules">Post-block Execution Rules</a></h3>
<p>In the OP Stack protocol, certain operations such as withdrawals and system requests are applied at the end of block
execution. Since each flashblock must function as a valid standalone block for preconfirmation purposes, these
post-block execution rules must be applied at the end of each flashblock's construction.</p>
<p>When constructing a flashblock, the builder applies all required post-block operations after executing the selected
transactions. These operations modify the state according to protocol rules, ensuring the flashblock represents a
complete and valid block state.</p>
<p>However, an important implementation detail is that these post-block changes must be reverted before beginning
execution for the next flashblock. This reversion is necessary because the post-block operations should only be applied
once per actual L2 block, not cumulatively for each flashblock. Failing to revert these changes would lead to their
repeated application across multiple flashblocks, potentially creating invalid cumulative state and ultimately an
invalid final block.</p>
<h3 id="construction-steps"><a class="header" href="#construction-steps">Construction Steps</a></h3>
<p>After handling the mandatory sequencer transactions in the initial Flashblock, the External Block Builder proceeds with
constructing subsequent Flashblocks by following these steps for each interval:</p>
<ol>
<li>
<p><strong>Transaction Selection</strong></p>
<ul>
<li>Retrieve transactions from local or external mempool:</li>
<li>Prioritize and sort transactions based on predefined sequencing policies, such as priority ordering or by MEV paid.</li>
</ul>
</li>
<li>
<p><strong>Transaction Execution</strong></p>
<ul>
<li>Sequentially execute selected transactions against a state snapshot derived from the current execution payload base
(ExecutionPayloadBaseV1) or the last validated flashblock</li>
<li>Apply the transaction inclusion heuristics described earlier to determine when to stop including transactions</li>
<li>After transaction execution completes, apply all post-block execution rules as described in the Post-Block Execution
Rules section</li>
</ul>
</li>
<li>
<p><strong>Flashblock Payload Assembly</strong></p>
<ul>
<li>After transaction execution, compute and record the following execution state updates:</li>
<li><code>state_root</code>: The new post-execution state root resulting from the executed transactions.</li>
<li><code>receipts_root</code>: The receipts trie root derived from execution outcomes.</li>
<li><code>logs_bloom</code>: Aggregated logs bloom from all emitted transaction logs within this flashblock.</li>
<li><code>gas_used</code>: Total gas consumed by executed transactions.</li>
<li><code>transactions</code>: Serialized transaction payloads included within the flashblock.</li>
<li><code>withdrawals</code> (if applicable): Withdrawals executed during the current flashblock interval (as per OP Stack
withdrawal specification).</li>
<li><code>block_hash</code>: Computed block hash uniquely identifying this flashblock execution state.</li>
</ul>
<p>Note that each flashblock builds upon the state of all previous flashblocks, with these fields reflecting the
cumulative state after applying the new transactions in this particular flashblock.</p>
<ul>
<li>Encapsulate these computed updates into <code>ExecutionPayloadFlashblockDeltaV1</code>.</li>
</ul>
</li>
<li>
<p><strong>Flashblock Indexing and Metadata</strong></p>
<ul>
<li>Assign a monotonically incremented <code>index</code> to the newly constructed Flashblock payload.</li>
<li>Compute the SSZ hash of the previous Flashblock and assign it as the <code>parent_flash_hash</code> (for the first Flashblock
with index 0, this field is empty)</li>
</ul>
</li>
<li>
<p><strong>Flashblock Delivery</strong></p>
<ul>
<li>Package the <code>index</code>, <code>payload_id</code>,  <code>ExecutionPayloadFlashblockDeltaV1</code>, and metadata into a <code>FlashblocksPayloadV1</code>
payload.</li>
<li>Deliver the assembled <code>FlashblocksPayloadV1</code> payload promptly to Rollup Boost via the designated Flashblocks
submission API.</li>
</ul>
</li>
<li>
<p><strong>Subsequent Flashblock Construction</strong></p>
<ul>
<li>Immediately after successful delivery, increment the Flashblock <code>index</code>.</li>
<li>Revert any post-block execution changes as described in the Post-Block Execution Rules section</li>
<li>Reset the transaction execution context based on the newly delivered state.</li>
<li>Begin constructing the next <code>FlashblocksPayloadV1</code> payload, repeating from step 1 until a termination condition is
reached (e.g., end of block building period via <code>engine_getPayload</code> request).</li>
</ul>
</li>
<li>
<p><strong>Flashblock Construction Termination</strong></p>
<ul>
<li>Flashblock construction continues iteratively until:</li>
<li>Rollup Boost signals final block aggregation and propagation via <code>engine_getPayload</code>.</li>
<li>A failure or timeout condition arises requiring failover procedures, detailed separately.</li>
</ul>
</li>
</ol>
<pre class="mermaid">sequenceDiagram
    participant BB as External Block Builder
    participant RB as Rollup Boost
    participant EE as Execution Engine (local)
    participant M as Mempool

    loop Every FLASHBLOCKS_TIME
        BB-&gt;&gt;M: Retrieve and Prioritize Transactions
        M--&gt;&gt;BB: Transactions batch
        Note over BB: Execute transactions sequentially
        BB-&gt;&gt;EE: Execute transactions and compute state root
        EE--&gt;&gt;BB: Execution results (state root, receipts, gas used)

        Note over BB: Construct Flashblock Delta
        BB-&gt;&gt;BB: Assemble FlashblocksPayloadV1 (state_root, receipts_root, logs_bloom, gas_used, block_hash, txs,
withdrawals, metadata)

        BB-&gt;&gt;RB: Submit FlashblocksPayloadV1
        RB--&gt;&gt;BB: Acknowledge reception (async)
        Note over BB: Increment index, prepare next Flashblock
    end
</pre>
<h2 id="flashblocks-metadata"><a class="header" href="#flashblocks-metadata">Flashblocks Metadata</a></h2>
<p>The <code>FlashblocksPayloadV1</code> structure defined above contains the minimum required data for Rollup Boost to return a
valid block. The <code>metadata</code> field provides additional information to enable preconfirmations.</p>
<p>This metadata contains supplementary information about the execution state that is not strictly necessary for block
construction but is valuable for RPC providers to offer comprehensive preconfirmation services. Examples of such
metadata include:</p>
<ul>
<li>Account state changes (which accounts have been modified)</li>
<li>Updated account balances</li>
<li>Storage slot modifications</li>
<li>Contract deployment information</li>
<li>Detailed transaction execution results</li>
</ul>
<h3 id="alternative-design-consideration"><a class="header" href="#alternative-design-consideration">Alternative Design Consideration</a></h3>
<p>While this specification includes detailed metadata in Flashblocks, a viable alternative would be for RPC providers to
execute transactions themselves as they receive them through the stream. In this approach, providers would receive only
transaction data, execute them in order, maintain their own state cache, and use it to fulfill RPC requests. This would
significantly reduce bandwidth requirements by eliminating metadata transmission.</p>
<h2 id="rationale-for-including-state-roots-in-flashblocks"><a class="header" href="#rationale-for-including-state-roots-in-flashblocks">Rationale for Including State Roots in Flashblocks</a></h2>
<p>One of the most discussed aspects of the Flashblocks design is the decision to include state roots with every
flashblock. This section explains the rationale behind this design choice.</p>
<h3 id="non-blocking-block-production"><a class="header" href="#non-blocking-block-production">Non-Blocking Block Production</a></h3>
<p>We operate under the assumption that <code>engine_getPayload</code> requests should return quickly with a valid, complete block.
This assumption, which we believe to be correct based on our understanding of the OP Stack, guides our design decisions.</p>
<p>Currently in OP Stack implementations, execution layer nodes compute payloads in the background and can return them
immediately when requested via <code>engine_getPayload</code>. This allows for near-instant responses, maintaining the flow of
block production without delays. For Flashblocks to provide similar performance, it must have all block components -
including state roots - readily available when <code>engine_getPayload</code> is called.</p>
<p>Without pre-computed state roots for each flashblock, Rollup Boost would face a critical decision when handling
<code>engine_getPayload</code>:</p>
<ol>
<li><strong>Request the state root from the Execution Layer</strong>: This approach would be problematic because the Execution Layer
does not maintain a "hot" state that matches the current flashblock sequence. It would need to apply all pending
transactions and compute a new state root, which is exactly the operation we're trying to optimize with flashblocks.</li>
<li><strong>Request the state root from the External Block Builder</strong>: This would require an additional synchronous request to
the builder with a protocol which is not engine-specific. Not only does this introduce an extra communication hop and
latency, but it also creates a single point of failure - if the builder is unavailable at that moment, Rollup Boost
cannot fulfill the request and we fall into the failure path rather than the happy path.</li>
</ol>
<h3 id="builder-availability-and-system-reliability"><a class="header" href="#builder-availability-and-system-reliability">Builder Availability and System Reliability</a></h3>
<p>The key advantage of including state roots with each flashblock is system reliability. By having state roots
immediately available, Rollup Boost can respond to <code>engine_getPayload</code> requests without additional external
dependencies at that critical moment.</p>
<p>Without pre-included state roots, a builder failure at the moment of block production would force the system to either:</p>
<ol>
<li>Recompute the entire state from scratch (time-consuming and potentially disruptive)</li>
<li>Fail to produce a block on time (violating protocol assumptions)</li>
<li>Be unable to fulfill the preconfirmations that have already been exposed to users</li>
</ol>
<h3 id="future-design-considerations"><a class="header" href="#future-design-considerations">Future Design Considerations</a></h3>
<p>This approach represents our current understanding of the optimal design given existing constraints. However, as
mentioned in the Out-of-Protocol Design section, alternative approaches may be worth exploring as we gain production
experience. Future iterations might consider different state root handling approaches, particularly in the context of
high-availability sequencer setups and deeper integration with OP Stack components.</p>
<h2 id="builder-to-rollup-boost-communication-flow"><a class="header" href="#builder-to-rollup-boost-communication-flow">Builder-to-Rollup-boost Communication Flow</a></h2>
<p>Rollup Boost maintains an open WebSocket connection with the External Block Builder. Through this persistent
connection, the builder pushes the <code>FlashblocksPayloadV1</code> payloads as soon as they're constructed, without waiting for
requests from Rollup Boost.</p>
<p>If the WebSocket connection goes down, the builder buffers (queues) the messages internally and attempts to resend them
once the connection is restored. This buffering only applies for the current block being built; when a new block cycle
begins, any queued messages from the previous block are discarded as they are no longer relevant to the current state.</p>
<p><strong>SSZ Encoding for Flashblocks Messages</strong></p>
<p>Flashblocks messages transmitted between the Block Builder and Rollup Boost use Simple Serialize (SSZ) for binary
encoding. Unlike JSON or other self-describing formats, SSZ is schema-less and does not embed field names or type
information in the serialized data. This makes explicit versioning necessary, especially in a streaming context where
message types cannot be inferred from surrounding context.</p>
<p>For the <code>FlashblocksPayloadV1</code> structure, a version field is placed as the first field in the container.</p>
<p>This design leverages SSZ's deterministic encoding characteristics, where fixed-size fields like <code>Bytes4</code> appear at
predictable offsets in the serialized data. When a recipient receives a serialized Flashblocks message over the
WebSocket stream:</p>
<ol>
<li>It first reads the initial 4 bytes to determine the message version</li>
<li>Based on the version identifier, it selects the appropriate container structure for deserializing the remainder of
the data</li>
</ol>
<h2 id="flashblock-validity-rules"><a class="header" href="#flashblock-validity-rules">Flashblock Validity Rules</a></h2>
<p>For a flashblock to be considered valid the following must hold:</p>
<ul>
<li>
<p><strong>Monotonically Increasing Payload Index:</strong> Each successive Flashblock payload delivered within the same L2 block
cycle must have an index exactly one greater than the previous payload. Any skipped indices or duplicated indices
constitute a violation. When a violation occurs, Rollup Boost will ignore the invalid flashblock and maintain its
internal state, only updating when it receives a new flashblock with the correct next index value.</p>
</li>
<li>
<p><strong>Immutable Payload Base:</strong> Immutable block header fields (<code>parent_hash</code>, <code>block_number</code>, <code>prev_randao</code>, etc.) set by
the initial <code>ExecutionPayloadBaseV1</code> cannot be altered by subsequent Flashblocks during the same L2 block period.</p>
</li>
<li>
<p><strong>Execution Validity:</strong> Every Flashblock must be validated successfully against the Sequencer’s local execution
engine state to ensure OP protocol-level correctness.</p>
</li>
<li>
<p><strong>Valid Full Block:</strong> Every flashblock, when combined with prior flashblocks, should be a valid L2 Block without
requiring Rollup Boost to perform any additional operations other than repackaging the data structure. This means that
state roots are calculated on each Flashblock contrary to publication due to the out-of-protocol nature of the
implementation.</p>
<p>A flashblock is considered a valid block if:</p>
</li>
<li>
<p>It includes the first flashblock (with index 0 containing the base data)</p>
</li>
<li>
<p>It comprises a continuous sequence of flashblocks with incrementing indices.</p>
</li>
</ul>
<h2 id="flashblock-system-invariants"><a class="header" href="#flashblock-system-invariants">Flashblock System Invariants</a></h2>
<p>The following invariants must hold true for the Flashblocks protocol to function reliably:</p>
<ul>
<li><strong>No Equivocation:</strong> At no point should multiple distinct Flashblocks for the same payload index be delivered or
propagated to RPC subscribers.</li>
<li><strong>Preconfirmation Preservation:</strong> The system always gives strong preference to maintaining the integrity of issued
preconfirmations. Once a transaction has been included in a flashblock and made visible to users as preconfirmed, the
system will prioritize preserving this state over other considerations such as block value optimization or alternative
builder selection.</li>
</ul>
<h2 id="flashblock-propagation"><a class="header" href="#flashblock-propagation">Flashblock Propagation</a></h2>
<p>Once Rollup Boost has validated a flashblock, it is then propagated to the rest of the network to be included in each
RPC Provider’s Preconfirmation Cache.</p>
<pre class="mermaid">sequenceDiagram
    participant B as Block Builder
    participant R as Rollup-boost
    box Node
    participant RPC as JSON-RPC Interface
    end
    participant U as Users

    B-&gt;&gt;R: Preconfirmation batches
    R-&gt;&gt;R: Validate batches
    R-&gt;&gt;RPC: Preconfirmation updates
    U-&gt;&gt;RPC: Standard RPC queries
    note right of U: Regular users
</pre>
<p>Flashblocks Compatible RPC Providers subscribe to the Flashblocks websocket stream from Rollup Boost and maintain an
in-memory representation of the preconfirmation state. RPC providers validate that the flashblock sequence is correct
before updating their preconfirmation state. This preconfirmation state is ephemeral, maintained only until the
corresponding block is propagated and the information becomes available through standard chain state.</p>
<p>Throughout the entire propagation path, flashblocks are transmitted in binary SSZ-encoded format.</p>
<h3 id="secure-propagation"><a class="header" href="#secure-propagation">Secure propagation</a></h3>
<p>Since the preconfirmation data originates directly from the Sequencer's Rollup Boost instance, exposing this WebSocket
endpoint directly to external parties presents security and scalability concerns. Instead, a reverse proxy should be
implemented between Rollup Boost and external RPC providers to relay this information securely.</p>
<p>This mirror simply relays WebSocket data without requiring any Flashblocks-specific knowledge, acting purely as a
transport layer that forwards WebSocket messages from Rollup Boost to subscribed RPC providers. You can find an example
implementation in the <a href="https://github.com/base/flashblocks-websocket-proxy">flashblocks-websocket-proxy repository</a>.</p>
<pre class="mermaid">flowchart TD
    subgraph Sequencer
        BB[Block Builder]
        RB[Rollup Boost]
        Mirror[Flashblocks Mirror]
    end

    subgraph RPC Providers
        RPC1[RPC Provider 1]
        RPC2[RPC Provider 2]
        RPC3[RPC Provider 3]
        RPCN[RPC Provider N]
    end

    BB --&gt;|Flashblocks| RB
    RB --&gt;|Flashblocks| Mirror
    Mirror --&gt;|Flashblocks| RPC1
    Mirror --&gt;|Flashblocks| RPC2
    Mirror --&gt;|Flashblocks| RPC3
    Mirror --&gt;|Flashblocks| RPCN
</pre>
<h2 id="flashblock-json-rpc-apis"><a class="header" href="#flashblock-json-rpc-apis">Flashblock JSON-RPC APIs</a></h2>
<h3 id="ethereum-json-rpc-modifications"><a class="header" href="#ethereum-json-rpc-modifications">Ethereum JSON RPC Modifications</a></h3>
<p>All modifications done to the existing Ethereum JSON RPC methods are confined to overloading the existing <code>pending</code>
tag. Originally, this tag was designed to return block data being processed by the node's internal miner. It's fitting
that we now use it for a similar purpose: exposing blocks in their preconfirmation stage. When queried with the
<code>pending</code> tag, the endpoint uses the preconfirmation cache state to construct the response. The response might include
not only transactions but also block metadata like state root and receipt root.</p>
<p>The tag is currently in a soft-deprecated state due to inconsistent implementations across clients, particularly after
The Merge. However, it's worth noting that it's still actively used for certain endpoints, particularly
<code>eth_getTransactionCount</code> where it serves the important function of returning the next available nonce for an account
(including transactions in the mempool). This presents an opportunity: the tag is well-defined enough to be supported
by client libraries, yet loosely defined enough to allow for our preconfirmation use case. While there's a possibility
of the tag being removed in the future (see <a href="https://github.com/ethereum/execution-apis/issues/495">EIP discussions</a>),
the design could adapt by introducing a flashblocks-specific tag if needed.</p>
<p>We repurpose the <code>pending</code> tag in the following RPC calls to enable consuming preconfirmed state:</p>
<ul>
<li>eth_getTransactionReceipt</li>
<li>eth_getBlockByHash</li>
<li>eth_getBalance</li>
<li>eth_call</li>
<li>eth_getCode</li>
<li>eth_getTransactionCount</li>
<li>eth_getStorageAt</li>
</ul>
<h3 id="op_supportedcapabilities"><a class="header" href="#op_supportedcapabilities">op_supportedCapabilities</a></h3>
<p>This endpoint allows clients to discover whether the RPC provider supports certain features, including Flashblocks.</p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "op_supportedCapabilities",
  "params": [],
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": ["flashblocksv1"]
}
</code></pre>
<p>When this method is called on a Flashblocks-compatible RPC provider, the response includes "flashblocksv1" in the
returned array of supported capabilities. This allows clients to programmatically determine whether they can utilize
Flashblocks functionality before making related requests.</p>
<p>This endpoint follows a similar pattern to the Engine API's <code>engine_exchangeCapabilities</code> method, which allows
consensus and execution clients to exchange information about supported features.</p>
<p>This is the only new RPC endpoint introduced by the Flashblocks specification. We consider this addition acceptable
because it provides necessary feature discovery while keeping the name abstract enough to accommodate future extensions
to the protocol or for other protocols.</p>
<p><strong><code>eth_getTransactionReceipt</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getTransactionReceipt",
  "params": ["0x..."],// Transaction hash
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">{
  "transactionHash": "0x...",
  "blockHash": "0x0",  // Empty hash as placeholder
  "blockNumber": "0x...",       // Current pending block number
  "transactionIndex": "0x0",
  "from": "0x...",
  "to": "0x...",
  "gasUsed": "0x...",
  "status": "0x1",
  "cumulativeGasUsed": "0x...",
  "effectiveGasPrice": "0x...",
  "contractAddress": "0x...",   // For contract creations
  "logs": [],
  "logsBloom": "0x..."
}
</code></pre>
<p>When queried, this endpoint first checks the preconfirmation cache for the requested transaction hash before falling
back to the standard chain state lookup.</p>
<p>Some fields in the response cannot be final at the preconfirmation stage and require placeholder values:</p>
<ul>
<li><code>blockHash</code>: Uses empty hash as placeholder</li>
<li><code>blockNumber</code>: Can be set to the current block number being processed</li>
</ul>
<p><strong><code>eth_getBlockByHash</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getBlockByHash",
  "params": ["pending", false],  // Second parameter indicates full transaction objects (true) or only hashes (false)
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">{
  "hash": "0x0",  // Empty hash as placeholder
  "parentHash": "0x...",
  "stateRoot": "0x...",
  "transactionsRoot": "0x...",
  "receiptsRoot": "0x...",
  "number": "0x...",  // Current pending block number
  "gasUsed": "0x...",
  "gasLimit": "0x...",
  "timestamp": "0x...",
  "extraData": "0x...",
  "mixHash": "0x...",
  "nonce": "0x...", // // Used to signal flashblock index
  "transactions": []  // Array of transaction hashes or full transaction objects
}
</code></pre>
<p>The endpoint implements an append-only pattern - multiple queries during the same block's preconfirmation phase will
show an expanding list of transactions as new flashblocks are processed. Each query reflects the current state of all
preconfirmed transactions at that moment.</p>
<pre class="mermaid">sequenceDiagram
    participant U as User
    participant RPC
    participant R as Rollup-boost

    Note over R: Block building starts
    R-&gt;&gt;RPC: Batch 1 (txs: A, B)

    U-&gt;&gt;RPC: Query 1
    RPC--&gt;&gt;U: Block with txs: A, B

    R-&gt;&gt;RPC: Batch 2 (txs: C, D)
    U-&gt;&gt;RPC: Query 2
    RPC--&gt;&gt;U: Block with txs: A, B, C, D

    R-&gt;&gt;RPC: Batch 3 (txs: E)
    U-&gt;&gt;RPC: Query 3
    RPC--&gt;&gt;U: Block with txs: A, B, C, D, E

    R-&gt;&gt;RPC: Batch 4 (txs: F, G)
    U-&gt;&gt;RPC: Query 4
    RPC--&gt;&gt;U: Block with txs: A, B, C, D, E, F, G

    Note over R: Block sealed
</pre>
<p><strong><code>eth_getBalance</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getBalance",
  "params": ["0x...", "pending"],  // Account address and block parameter
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">"0x..." // Balance in wei
</code></pre>
<p>When queried with the "pending" tag, the endpoint uses the preconfirmation cache state to return the account balance.
If the requested account appears in the <code>AccountMetadata</code> of a received Flashblock with a non-null <code>balance</code> field, the
RPC provider can directly return this value without needing to access the full state. The response reflects all changes
from preconfirmed transactions that affect the requested account's balance.</p>
<p><strong><code>eth_call</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_call",
  "params": [{"to": "0x...", "data": "0x..."}, "pending"],  // Transaction call object and block parameter
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">"0x..." // Return data from the call
</code></pre>
<p>When queried with the "pending" tag, the endpoint uses the preconfirmation cache state to return the call result. For
this endpoint to work, the preconfirmation stream needs to include state differences for both accounts and storage
after each flashblock.</p>
<p>Similar to the current override functionality in <code>eth_call</code> where EVM transitions are executed on top of modified
state, this implementation executes the call on top of the preconfirmation state changes.</p>
<p><strong><code>eth_getCode</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getCode",
  "params": ["0x...", "pending"],// Contract address and block parameter
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">"0x..."// Contract bytecode
</code></pre>
<p>When queried with the "pending" tag, the endpoint returns the contract bytecode from the preconfirmation cache state.
If the requested account appears in the <code>AccountMetadata</code> of a received Flashblock with a non-null <code>code</code> field, the
RPC provider can directly return this value without accessing the full state.</p>
<p><strong><code>eth_getTransactionCount</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getTransactionCount",
  "params": ["0x...", "pending"],// Account address and block parameter
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">"0x..."// Nonce value as a hex string
</code></pre>
<p>When queried with the "pending" tag, the endpoint returns the transaction count (nonce) of the account from the
preconfirmation cache. If the requested account appears in the <code>AccountMetadata</code> of a received Flashblock, the RPC
provider can directly use the <code>nonce</code> field without additional state access.</p>
<p><strong><code>eth_getStorageAt</code></strong></p>
<p><strong>Request</strong></p>
<pre><code class="language-json">{
  "method": "eth_getStorageAt",
  "params": ["0x...", "0x...", "pending"],// Contract address, storage position, and block parameter
  "id": 1,
  "jsonrpc": "2.0"
}
</code></pre>
<p><strong>Response</strong></p>
<pre><code class="language-json">"0x..." // Storage value as a hex string
</code></pre>
<p>When queried with the "pending" tag, the endpoint returns the value from the specified storage slot using the
preconfirmation cache state. If the requested account appears in the <code>AccountMetadata</code> of a received Flashblock, the
RPC provider scans the <code>storage_slots</code> list for the requested key and returns the corresponding value directly.</p>
<h1 id="reliability-and-operational-considerations"><a class="header" href="#reliability-and-operational-considerations">Reliability and Operational Considerations</a></h1>
<h2 id="transaction-propagation"><a class="header" href="#transaction-propagation">Transaction Propagation</a></h2>
<p>Similar to the design laid out in the <a href="https://github.com/ethereum-optimism/">External Block Production</a> design
document, Flashblocks makes no assumptions about how transactions are delivered to the block builder. A non-exhaustive
list of valid approaches:</p>
<ul>
<li>transaction forwarding via mutliplex’ing software at the Rollup Operator’s RPC</li>
<li>Private p2p connections between Sequencer transaction ingress nodes and block building nodes</li>
</ul>
<h2 id="failover-scenarios"><a class="header" href="#failover-scenarios">Failover scenarios</a></h2>
<h3 id="block-builder"><a class="header" href="#block-builder">Block Builder</a></h3>
<p>As per the normal Rollup-boost behavior, if the builder is down, the Rollup-boost picks up the block from the fallback
builder. However, since we are dealing with preconfirmations, we must consider the relative value of preserving
preconfirmations versus building a potentially more valuable block.</p>
<p>In this design document, we follow the invariant that preserving preconfirmations takes precedence. If the block
builder goes down after the first flashblocks have been delivered, we still return those flashblocks to maintain the
integrity of any preconfirmations already issued to users. The next block would work as expected through the normal
fallback mechanism, as the builder is down and the fallback builder would be used.</p>
<p>We could technically discard the partial flashblocks and use the fallback block entirely, but this would violate the
preconfirmations commitment. Our design assumes normal execution conditions. If losing the builder mid-flashblock
becomes a common occurrence, this would indicate fundamental architectural issues that require separate improvements
beyond the scope of this failover mechanism.</p>
<h3 id="the-sequencer-or-rollup-boost"><a class="header" href="#the-sequencer-or-rollup-boost">The Sequencer or Rollup-boost</a></h3>
<p>These failure scenarios are addressed as part of the High Availability (HA) sequencer setups. The HA architecture
ensures continuity of operations by automatically failing over to standby instances when failures occur.</p>
<h2 id="integration-with-high-availability-sequencer-setups"><a class="header" href="#integration-with-high-availability-sequencer-setups">Integration with High Availability Sequencer Setups</a></h2>
<p>The integration of Flashblocks with High Availability (HA) Sequencer setups is outside the scope of this initial
specification document. For details on managing Flashblock state across multiple sequencer instances and maintaining
preconfirmation integrity during failovers, please refer to the resources linked below.</p>
<ul>
<li>what do with a rotating set of sequencers like with OP conductor
<a href="https://github.com/ethereum-optimism/optimism/tree/develop/op-conductor">op-conductor</a></li>
<li>World HA design discussion<a href="https://github.com/flashbots/">flashbots</a></li>
<li>Base Technical Design Document <a href="https://www.notion.so/TDD-Rollup-Boost-Integration-with-HA-Sequencer-1d0c9d820ca380348f21e44a5442feaf?pvs=21">TDD: Rollup Boost Integration with HA
Sequencer</a></li>
</ul>
<h2 id="faults"><a class="header" href="#faults">Faults</a></h2>
<h3 id="safety-faults"><a class="header" href="#safety-faults"><strong>Safety Faults</strong></a></h3>
<p>In the rollup security vocabulary <em>safety</em> implies that “<strong>no one can create or withdraw assets they are not entitled
to.</strong>” A <strong>safety fault</strong> therefore occurs the moment an <strong>invalid L2 state root</strong> is accepted on Ethereum <strong>and</strong> at
least one L2→L1 action (withdrawal, message relay, etc.) that depends on that root is executed <strong>and</strong> the dispute game
period has ended. After that point the canonical record on Ethereum says the invalid state is <em>final</em> and the rollup’s
honesty assumption is broken.</p>
<p>The safety of a flashblock is directly equivalent to the safety of an L2 block. Additionally, on each submission of a
flashblock to Rollup Boost, it is simulated against the Sequencer’s local execution engine, ensuring the Block
Builder’s view is equivalent to the Sequencer’s.</p>
<p>The real thing we are interested in regards to safety faults for the Flashblock stream is whether they can be reorged.
The answer to this question is that the preconfirmed state can be reorged out if the Sequencer reorgs. Given that the
sequencer is the one validating the block builder blocks, then there is no additional risk of reorg from the
introduction of the External Block Builder and Flashblocks stream, as in both cases, the reorg is due to Sequencer
Operator error.</p>
<h3 id="liveness-faults"><a class="header" href="#liveness-faults"><strong>Liveness Faults</strong></a></h3>
<p>In the rollup vocabulary *Liveness implies that “*every honest user can (a) get a transaction included within a bounded
time and (b) complete a withdrawal within the 7‑day challenge window.” A <strong>liveness fault</strong> is any condition that makes
either promise untrue <em>without violating safety</em> (no invalid state is accepted).</p>
<p>The liveness of a flashblock is therefore directly equivalent to the liveness of L2 blocks as user’s are able to force
include via the L1 as normal.</p>
<h1 id="rationale"><a class="header" href="#rationale">Rationale</a></h1>
<h2 id="why-out-of-protocol"><a class="header" href="#why-out-of-protocol">Why out-of-protocol</a></h2>
<p>The design is implemented as an out-of-protocol solution rather than a core protocol modification to allow for faster
iteration and development. This approach respects the stability guarantees of the OP Stack while allowing participants
to adopt the features at their own pace.</p>
<p>We do not, however, discard the possibility of enshrining these features inside the OP Stack protocol as both teams
become more comfortable working together and more familiar with the specification. This out-of-protocol approach serves
as a proving ground that can inform a potential future core integration.</p>
<h3 id="why-not-shorter-block-times"><a class="header" href="#why-not-shorter-block-times">Why not shorter block times</a></h3>
<p>While reducing block times is a potential solution, it would require non-trivial changes to the OP Stack codebase,
where the current minimum timestamp used is 1 second. Additionally, extremely short block times (sub-200ms) might
introduce significant performance issues in other blockchain infrastructure like block explorers and indexers.</p>
<p>Flashblocks provide a more balanced approach: they maintain reasonable block times for network decentralization and
stability, while offering a fast-lane feedback mechanism for users who need immediate transaction status.</p>
<p>This approach also opens the door to an interesting possibility: chains could potentially implement longer block times
(tens of seconds) while still maintaining quick preconfirmations via Flashblocks. This combination might enable new and
interesting use cases that benefit from both paradigms.</p>
<h1 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h1>
<h2 id="end-users"><a class="header" href="#end-users">End Users</a></h2>
<p>At present, consuming Flashblocks data is completely opt-in through the use of the <code>pending</code> tag, therefore once turned
on, no applications will require changes to how they consume data from their RPC. Instead an additional opt-in flow is
enabled.</p>
<h2 id="infrastructure-operators"><a class="header" href="#infrastructure-operators">Infrastructure Operators</a></h2>
<p>For Sequencer Operators, Flashblocks and Rollup Boost can be enabled and disabled with no additional harm to the system.</p>
<p>For RPC Operators, Flashblocks will require a modified RPC node that subscribes to the Flashblock stream in addition to
maintaining a Preconfirmation cache and responding with the relevant data on request with the <code>pending</code> tag.</p>
<h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>A feature complete implementation of all components described in this document can be found in the
<a href="https://github.com/flashbots/">rollup-boost</a>
<a href="https://github.com/flashbots/">op-rbuilder</a>
<a href="https://github.com/base/flashblocks-websocket-proxy">flashblocks-websocket-proxy</a>, and
<a href="https://github.com/danyalprout/reth-flashblocks">reth-flashblocks</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../protocol/batcher.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../fault-proof/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../protocol/batcher.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../fault-proof/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../specs/static/solidity.min.js"></script>
        <script src="../specs/static/mermaid.min.js"></script>
        <script src="../specs/static/mermaid-init.js"></script>
        <script src="../theme/js/footer.js"></script>


    </div>
    </body>
</html>
